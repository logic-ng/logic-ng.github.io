{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LogicNG - The Next Generation Logic Framework","text":""},{"location":"#introduction","title":"Introduction","text":"<p>LogicNG is a Java Library for creating, manipulating and solving Boolean and Pseudo-Boolean formulas. It includes 100% Java implementations of popular tools like MiniSAT, Glucose, PBLib, or OpenWBO.</p> <p>Its main focus lies on memory-efficient data-structures for Boolean formulas and efficient algorithms for manipulating and solving them. The library is designed to be used in industrial systems which have to manipulate and solve millions of formulas per day.</p>"},{"location":"#high-level-overview","title":"High Level Overview","text":"<p>If you want a high-level overview of LogicNG and how it is used in many applications in the area of product configuration, you can read our white paper.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>The most important philosophy of the library is to avoid unnecessary object creation. Therefore formulas can only be generated via formula factories. A formula factory assures that a formula is only created once in memory. If another instance of the same formula is created by the user, the already existing one is returned by the factory. This leads to a small memory footprint and fast execution of algorithms. Formulas can cache the results of algorithms executed on them and since every formula is hold only once in memory it is assured that the same algorithm on the same formula is also executed only once.</p> <p>Compared to other implementation of logic libraries on the JVM this is a huge memory and performance improvement.</p>"},{"location":"#usage-in-your-project","title":"Usage in Your Project","text":"<p>LogicNG is released in the Maven Central Repository. To include the latest version, you can use the following snippet in you build tool of choice:</p> MavenGradle Groovy DSLGradle Kotlin DSLScala SBTLeiningen <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.logicng&lt;/groupId&gt;\n  &lt;artifactId&gt;logicng&lt;/artifactId&gt;\n  &lt;version&gt;2.4.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>implementation 'org.logicng:logicng:2.4.0'\n</code></pre> <pre><code>implementation(\"org.logicng:logicng:2.4.0\")\n</code></pre> <pre><code>libraryDependencies += \"org.logicng\" % \"logicng\" % \"2.4.0\"\n</code></pre> <pre><code>[org.logicng/logicng \"2.4.0\"]\n</code></pre>"},{"location":"#development-model","title":"Development Model","text":"<p>The <code>master</code> branch contains the latest release of LogicNG. If you want a stable and well tested version you should choose this branch. The <code>development</code> branch reflects the current state of the next version. This branch will always compile, but code might not be as well tested and APIs may still change before the next release. If you want to try cutting edge features, you can checkout this branch at your own risk. It is not recommended to use the development version for production systems. Larger features will be developed in their own branches and will be merged to the development branch when ready.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#tutorial","title":"Tutorial","text":"<p>For a gentle start with LogicNG, look at the tutorial.  The tutorial introduces basic concepts and shows how to use LogicNG in a small practical example.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation on this side provides an in-depth look at LogicNG.</p>"},{"location":"#compilation","title":"Compilation","text":"<p>To compile LogicNG simply run <code>mvn compile</code> to build the parsers and compile the source code. You can build a jar of the library with <code>mvn package</code> or install it in your local maven repository via <code>mvn install</code>.</p>"},{"location":"#first-steps","title":"First Steps","text":"<p>The following code creates the Boolean Formula A and not (B or not C) programmatically:</p> <pre><code>FormulaFactory f = new FormulaFactory();\nVariable a = f.variable(\"A\");\nVariable b = f.variable(\"B\");\nLiteral notC = f.literal(\"C\", false);\nFormula formula = f.and(a, f.not(f.or(b, notC)));\n</code></pre> <p>Alternatively you can just parse the formula from a string:</p> <pre><code>FormulaFactory f = new FormulaFactory();\nPropositionalParser p = new PropositionalParser(f);\nFormula formula = p.parse(\"A &amp; ~(B | ~C)\");\n</code></pre> <p>Once you created the formula you can for example convert it to NNF or CNF or solve it with an instance of MiniSAT:</p> <pre><code>Formula nnf = formula.nnf();\nFormula cnf = formula.cnf();\nSATSolver miniSat = MiniSat.miniSat(f);\nminiSat.add(formula);\nTristate result = miniSat.sat();\n</code></pre>"},{"location":"#license-commercial-support","title":"License &amp; Commercial Support","text":"<p>  The library is released under the Apache License and therefore is free to use in any private, educational, or commercial projects. Commercial support is available through the German company BooleWorks GmbH - the company behind LogicNG. Please contact Christoph Zengler at christoph@logicng.org for further details.</p>"},{"location":"blog/2022/09/14/feature-preview-logicng-240-graphics-generators/","title":"Feature Preview LogicNG 2.4.0: Graphics Generators","text":"<p>LogicNG 2.4.0 introduces a completely rewritten graphics generation for DAGs and ASTs of formulas, BDDs, and graphs.  There are two major new features:</p> <ol> <li>There is a new output format besides the DOT language: The markdown-like syntax of Mermaid.js.  With Mermaid.js you can easily integrate the generated graphs in a web page or application and can play around with it in the interactive live editor.</li> <li>You can now style all nodes and edges when generating a graph.  So you can now decide, what content should be in the node label, what stroke, text, and background color the nodes should have, and how the edges should be styled.  This can be done by a fixed style or by dynamically styling the nodes and edges depending on their content.</li> </ol>"},{"location":"blog/2022/09/14/feature-preview-logicng-240-graphics-generators/#a-simple-example","title":"A Simple Example","text":"<p>To demonstrate these new features, let's look at the AST (abstract syntax tree, c.f. here) of a formula from our documentation.  We consider the Formula <code>A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)</code> and create its default representation.</p> <pre><code>FormulaFactory f = new FormulaFactory();\nFormula formula = f.parse(\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\");\nFormulaAstGraphicalGenerator generator =\n        FormulaAstGraphicalGenerator.builder().build();\nGraphicalRepresentation representation = generator.translate(formula);\n</code></pre> <p>For DOT we write the output in a file, for Mermaid.js we just get the <code>String</code> of the representation.</p> Mermaid.jsDOT <pre><code>String mermaidString = representation.writeString(GraphicalMermaidWriter.get());\n</code></pre> <pre><code>representation.write(\"dot-file.dot\", GraphicalDotWriter.get());\n</code></pre> <p>This representation with Mermaid.js looks like this:</p> <pre><code>graph TD\n  id0([\"\u21d4\"])\n  id1([\"\u2227\"])\n  id2([\"A\"])\n  id3([\"B\"])\n  id4([\"\u2228\"])\n  id5([\"A\"])\n  id6([\"B\"])\n  id7([\"\u2227\"])\n  id8([\"C\"])\n  id9([\"\u2228\"])\n  id10([\"A\"])\n  id11([\"B\"])\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre> <p>Note how this graph automatically changes its colors depending on the light/dark theme of this page.</p>"},{"location":"blog/2022/09/14/feature-preview-logicng-240-graphics-generators/#customizing-the-node-label","title":"Customizing the Node Label","text":"<p>Perhaps you don't want the default node labels with just the UTF-8 characters \"\u2227\", \"\u2228\", or \"\u21d4\" for the operators.  Then you can configure the generator with your own <code>LabelMapper</code> which decides how to fill the label of a node.  In this case, perhaps you want to write the whole subformula in each label.  You can either implement your own sub-class of <code>LabelMapper</code> or just use a lambda function in the builder of the generator:</p> <pre><code>FormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .build();\n</code></pre> <p>Now the representation looks like this:</p> <pre><code>graph TD\n  id0([\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"])\n  id1([\"A &amp; B &amp; (A | B)\"])\n  id2([\"A\"])\n  id3([\"B\"])\n  id4([\"A | B\"])\n  id5([\"A\"])\n  id6([\"B\"])\n  id7([\"C &amp; (A | B)\"])\n  id8([\"C\"])\n  id9([\"A | B\"])\n  id10([\"A\"])\n  id11([\"B\"])\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre> <p>Of course you could use your own <code>FormulaStringRepresentation</code> for the string formatter of the formula.</p>"},{"location":"blog/2022/09/14/feature-preview-logicng-240-graphics-generators/#styling-nodes-and-edges-with-a-fixed-style","title":"Styling Nodes and Edges with a Fixed Style","text":"<p>You can configure the generator with a default style for nodes in edges.  If no dynamic style mapper is given, this style will be applied to all nodes and edges.  Let us style our representation with dotted edges and blue rectangles for the nodes.</p> <pre><code>FormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .defaultEdgeStyle(GraphicalEdgeStyle.dotted(null)) // (1)!\n        .defaultNodeStyle(GraphicalNodeStyle.rectangle(\n            GraphicalColor.BLUE, GraphicalColor.WHITE, GraphicalColor.BLUE)) // (2)!\n        .build();\n</code></pre> <ol> <li>If you pass <code>null</code> as the color, the default value of the framework will be taken.  In this case, Mermaid.js decides depending on light/dark mode how to color the edge.  Try it: if you switch to dark mode, the edges are white, in light mode, they are black.</li> <li>You can use some predefined color in the class <code>GraphicalColor</code> or define your own in RGB or HEX.</li> </ol> <p>This leads to the following graphics:</p> <pre><code>graph TD\n  id0[\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"]\n    style id0 stroke:#004f93,color:#ffffff,fill:#004f93\n  id1[\"A &amp; B &amp; (A | B)\"]\n    style id1 stroke:#004f93,color:#ffffff,fill:#004f93\n  id2[\"A\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3[\"B\"]\n    style id3 stroke:#004f93,color:#ffffff,fill:#004f93\n  id4[\"A | B\"]\n    style id4 stroke:#004f93,color:#ffffff,fill:#004f93\n  id5[\"A\"]\n    style id5 stroke:#004f93,color:#ffffff,fill:#004f93\n  id6[\"B\"]\n    style id6 stroke:#004f93,color:#ffffff,fill:#004f93\n  id7[\"C &amp; (A | B)\"]\n    style id7 stroke:#004f93,color:#ffffff,fill:#004f93\n  id8[\"C\"]\n    style id8 stroke:#004f93,color:#ffffff,fill:#004f93\n  id9[\"A | B\"]\n    style id9 stroke:#004f93,color:#ffffff,fill:#004f93\n  id10[\"A\"]\n    style id10 stroke:#004f93,color:#ffffff,fill:#004f93\n  id11[\"B\"]\n    style id11 stroke:#004f93,color:#ffffff,fill:#004f93\n\n  id1 --&gt; id2\n    linkStyle 0 stroke-width:2,stroke-dasharray:3\n  id1 --&gt; id3\n    linkStyle 1 stroke-width:2,stroke-dasharray:3\n  id4 --&gt; id5\n    linkStyle 2 stroke-width:2,stroke-dasharray:3\n  id4 --&gt; id6\n    linkStyle 3 stroke-width:2,stroke-dasharray:3\n  id1 --&gt; id4\n    linkStyle 4 stroke-width:2,stroke-dasharray:3\n  id7 --&gt; id8\n    linkStyle 5 stroke-width:2,stroke-dasharray:3\n  id9 --&gt; id10\n    linkStyle 6 stroke-width:2,stroke-dasharray:3\n  id9 --&gt; id11\n    linkStyle 7 stroke-width:2,stroke-dasharray:3\n  id7 --&gt; id9\n    linkStyle 8 stroke-width:2,stroke-dasharray:3\n  id0 --&gt; id1\n    linkStyle 9 stroke-width:2,stroke-dasharray:3\n  id0 --&gt; id7\n    linkStyle 10 stroke-width:2,stroke-dasharray:3</code></pre>"},{"location":"blog/2022/09/14/feature-preview-logicng-240-graphics-generators/#styling-nodes-and-edges-dynamically","title":"Styling Nodes and Edges Dynamically","text":"<p>Now we want to change the look of the nodes dynamically by their content.  In this case we want to distinguish between nodes with literals (terminals) and nodes with sub-formulas (inner nodes) - but you could look at arbitrary properties of the node content.  To do this, you have to configure the generator with its own <code>NodeStyleMapper</code>.  As above: you can either implement a sub-class or just pass a lambda function.</p> <pre><code>GraphicalNodeStyle terminalNodeStyle =\n        GraphicalNodeStyle.rectangle(BLUE, WHITE, BLUE);\nGraphicalNodeStyle innerNodeStyle =\n        GraphicalNodeStyle.ellipse(YELLOW, BLACK, YELLOW);\n\nFormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .nodeStyleMapper((phi) -&gt;\n            phi.type() == FType.LITERAL ? terminalNodeStyle : innerNodeStyle)\n        .build();\n</code></pre> <p>This leades exactly to the representation of our documentation:</p> <pre><code>graph TD\n  id0([\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"])\n    style id0 stroke:#ffc612,color:#000000,fill:#ffc612\n  id1([\"A &amp; B &amp; (A | B)\"])\n    style id1 stroke:#ffc612,color:#000000,fill:#ffc612\n  id2[\"A\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3[\"B\"]\n    style id3 stroke:#004f93,color:#ffffff,fill:#004f93\n  id4([\"A | B\"])\n    style id4 stroke:#ffc612,color:#000000,fill:#ffc612\n  id5[\"A\"]\n    style id5 stroke:#004f93,color:#ffffff,fill:#004f93\n  id6[\"B\"]\n    style id6 stroke:#004f93,color:#ffffff,fill:#004f93\n  id7([\"C &amp; (A | B)\"])\n    style id7 stroke:#ffc612,color:#000000,fill:#ffc612\n  id8[\"C\"]\n    style id8 stroke:#004f93,color:#ffffff,fill:#004f93\n  id9([\"A | B\"])\n    style id9 stroke:#ffc612,color:#000000,fill:#ffc612\n  id10[\"A\"]\n    style id10 stroke:#004f93,color:#ffffff,fill:#004f93\n  id11[\"B\"]\n    style id11 stroke:#004f93,color:#ffffff,fill:#004f93\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre> <p>And here the corresponding dot file output:</p> <p></p> <p>Since this is a statically generated PNG graphics, of course there is no dynamic color switching for light/dark mode like with the Mermaid.js output.</p>"},{"location":"documentation/","title":"LogicNG Documentation","text":"<p>If you are already familiar with the basics of LogicNG (e.g. from the tutorial), you can read about specific topics in our extensive documentation with the following subjects. See the sidebar on the left for all topics of the documentation.</p>"},{"location":"documentation/#versioning","title":"Versioning","text":"<p>The documentation is always up to date to the latest release of LogicNG which can be found in the upper right corner of this website.  Major releases will get a completely new version of the documentation.  Features introduced with a minor version will be denoted with a tag symbol and the respective minor version, e.g.  2.3.0</p>"},{"location":"documentation/#info-boxes","title":"Info Boxes","text":"<p>Throughout the documentation there will be some info boxes with the following content:</p> <p>Info</p> <p>Some additional or in-depth information on a topic.</p> <p>Note</p> <p>Some small notion on a subject.</p> <p>Example</p> <p>An additional example on a subject.</p> <p>Warning</p> <p>Something to look out when using a functionality.</p> <p>Danger</p> <p>A really dangerous or deprected behaviour or functionality.</p> <p>Application Insight</p> <p>An insight how a LogicNG feature is used in some real-life applications.</p>"},{"location":"documentation/backbones/","title":"Backbones","text":"<p>The backbone of a formula is the set of variables which must always be assigned to a specific truth value (<code>true</code> or <code>false</code>) in order to make the formula satisfiable. The variables which have to be assigned to <code>true</code> can be thought of as forced variables, and those variables which have to be assigned to <code>false</code> can be thought of as forbidden variables.</p> <p>One can also think of the backbone of a formula as the set of literals (positive and negative variables) which are present in their respective polarity in every satisfying assignment (model) of the formula.</p> <p>The backbone of the formulas loaded on a SAT Solver can be computed with the <code>SATSolver</code> method <code>backbone()</code>. The method takes two parameters:</p> <ol> <li> <p>The mandatory parameter <code>relevantVariables</code> indicates over which variables the backbone shall be computed.</p> </li> <li> <p>The optional parameter BackboneType enables to control which parts of the backbone shall be computed: Only positive (<code>ONLY_POSITIVE</code>) variables, only negative (<code>ONLY_NEGATIVE</code>) variables, or both (<code>POSITIVE_AND_NEGATIVE</code>).</p> </li> </ol> <p>If no <code>BackboneType</code> is specified, then the complete backbone (<code>POSITIVE_AND_NEGATIVE</code>) is computed. If you are only interested in one part (only positive or negative) you can specify the <code>BackboneType</code> to the relevant parameter in order to save computation time. If you don't mind performance or are interested in both the positive and negative part, there is no need to specify this parameter.</p> <p>As an example, consider:</p> <pre><code>SATSolver solver = MiniSat.miniSat(this.f);\nFormula formula1 = p.parse(\"A &amp; (~B | C) &amp; ~D\");\nFormula formula2 = p.parse(\"D | E\");\nsolver.add(formula1);\nsolver.add(formula2);\nBackbone backboneFull = solver.backbone(solver.knownVariables());\nBackbone backboneRestricted = solver.backbone(formula1.variables());\nBackbone backboneOnlyPos =\n        solver.backbone(formula1.variables(), BackboneType.ONLY_POSITIVE);\n</code></pre> <p>Then <code>backboneFull</code> returns the backbone over all variables on the solver:</p> <ul> <li>Positive variables (\"forced variables\"): <code>A, E</code></li> <li>Negative variables (\"forbidden variables\"): <code>D</code></li> <li>Optional variables (neither \"forced\" nor \"forbidden\"): <code>B, C</code></li> </ul> <p>One can also compute the backbone restricted to a subset of variables: <code>backboneRestricted()</code> returns the backbone restricted to the variables of <code>formula1</code>, which are <code>A, B, C, D</code>. Thus, only the backbone information about those variables is returned: - <code>A</code> is forced - <code>D</code> is forbidden - <code>B, C</code> are optional</p> <p>The backbone can be restricted to one part (positive or negative) by the <code>BackboneType</code>. The computed backbone from <code>backboneOnlyPos</code> is therefore simply <code>A</code>.</p>"},{"location":"documentation/backbones/#computing-the-backbone-with-a-handler","title":"Computing the backbone with a handler","text":"<p>The <code>backbone()</code> method on the solver internally calls the BackboneFunction. You can use this function directly in order to specify a handler for the computation.</p> <p>Consider the following example for when a handler aborts the computation:</p> <pre><code>SATSolver solver = MiniSat.miniSat(this.f);\nFormula formula = p.parse(\"~A &amp; B &amp; C &amp; D &amp; (~E &amp; F | G | H)\");\nsolver.add(formula);\nSATHandler handler = new BoundedSatHandler(3);\nBackbone backbone = solver.execute(BackboneFunction.builder()\n        .handler(handler)\n        .variables(formula.variables())\n        .build()\n);\n</code></pre> <p>The BoundedSatHandler aborts the computation in case the number of starts needed exceeds 3. Since the handler aborts the computation, the computed backbone is null. For more information about handlers, see the chapter on handlers.</p>"},{"location":"documentation/backbones/#empty-backbones","title":"Empty backbones","text":"<p>If the formulas for which you're trying to compute the backbone are unsatisfiable or do not contain variables, then an empty backbone is returned.</p> <p>As an example, consider:</p> <pre><code>SATSolver solver = MiniSat.miniSat(this.f);\nFormula formula = p.parse(\"A &amp; (~A | B) &amp; ~B\");\nsolver.add(formula);\nBackbone backbone = solver.execute(BackboneFunction.builder()\n        .variables(formula.variables())\n        .build()\n);\n</code></pre> <p>Since the formula is unsatisfiable, an empty backbone is returned:</p> <pre><code>Backbone{positiveBackbone=[], negativeBackbone=[], optionalVariables=[]}\n</code></pre> <p>You can check whether the formulas for which you're computing the backbone are satisfiable using <code>backbone.isSat()</code>.</p> <p>By the way: The simplifier which propagates the backbone through a formula is the Backbone Simplifier.</p> <p>For theoretical insights on the backbone computation, see the paper Algorithms for Computing Backbones of Propositional Formulae.</p>"},{"location":"documentation/formula-factory/","title":"The Formula Factory","text":"<p>The formula factory is the central concept of LogicNG and is always required when working with LogicNG.  A formula factory is an object consisting of two major components:</p> <p>A factory, which creates formulas, and a container, which stores created formulas.</p> <p>The container function is 'smart': A formula factory guarantees that syntactically equivalent formulas are created only once.  This mechanism also extends to variants of the formula in terms of associativity and commutativity. Therefore, if the user creates formulas for</p> <ul> <li><code>A &amp; B</code></li> <li><code>B &amp; A</code></li> <li><code>(B &amp; A)</code></li> </ul> <p>all of them are represented by only one formula in memory.  This approach is only possible, because formulas in LogicNG are immutable data structures.  So once created, a formula can never be altered again.</p> <p>In order to use the fact that formula factories avoid unnecessary formula creations, it is generally recommended to use only one formula factory for a certain task.</p> <p>During this documentation, we consider the formulas <code>f1</code>, <code>f2</code> and <code>f3</code> and use the following notion of a formula factory:</p> <pre><code>FormulaFactory f = new FormulaFactory();\n</code></pre>"},{"location":"documentation/formula-factory/#creating-formulas-with-a-formula-factory","title":"Creating Formulas with a Formula Factory","text":"<p>Formulas in LogicNG cannot be constructed directly but must be created by an instance of a formula factory. This factory ensures the following five invariants:</p> <ol> <li>A constant (<code>true</code> or <code>false</code>) cannot be an operand to any other formula, i.e. constants are automatically removed.</li> <li>The operand of a conjunction may not be another conjunction; the same applies to disjunctions. These cases are merged in one big conjunction/disjunction.</li> <li>The operand of a negation may only be a binary operator, an n-ary operator or a pseudo-Boolean constraint. For other operands the respective simplifications are performed.</li> <li>An n-ary operator has unique operands.  Duplicate operands in a disjunction or conjunction are filtered.</li> <li>Every positive literal is guaranteed to be an instance of class <code>Variable</code>.</li> </ol> <p>In the default configuration there is also a sixth invariant, which however can be deactivated by a configuration flag (see below):</p> <ol> <li>Inverse operands of an n-ary operator are simplified, this means <code>f1 &amp; ~f1</code> is parsed to <code>$false</code>, and <code>f1 | ~f1</code> is parsed to <code>$true</code>.</li> </ol> <p>Furthermore, some further simplifications are performed when parsing or creating formulas, such as <code>A &lt;=&gt; A</code> is equivalent to <code>$true</code>, or <code>A &lt;=&gt; ~A</code> is equivalent to <code>$false</code>.</p> <p>While being rather easy to realize, these restrictions simplify reasoning about the structure of a formula and thus significantly reduce the number of corner cases algorithms have to face.</p> <p>Together with the smart container function presented in the last section, the example can be extended.  Not only are formulas <code>A &amp; B</code>, <code>B &amp; A</code>, or <code>(B &amp; A)</code> represented by only one formula object in memory, but also variants like</p> <ul> <li><code>A &amp; A &amp; B</code></li> <li><code>B &amp; A &amp; $true</code></li> <li><code>(B &amp; A) &amp; B &amp; ($false | A) &amp; ($true | C)</code></li> </ul> <p>There are two ways to create formulas using a formula factory:</p> <p>Firstly, one can parse a formula from a string: E.g. <code>Formula created = p.parse(\"A &amp; B\");</code>.</p> <p>Secondly, one can create a formula of a certain type with the methods for formula creation in the formula factory. An overview about how to create those formulas is here:</p> Object Factory Method Syntax True <code>f.verum()</code> <code>$true</code> False <code>f.falsum()</code> <code>$false</code> Variable <code>f.variable(\"A\")</code> <code>A</code> Literal <code>f.literal(\"A\", false)</code> <code>~A</code> Negation <code>f.not(f1)</code> <code>~f1</code> Implication <code>f.implication(f1, f2)</code> <code>f1 =&gt; f2</code> Equivalence <code>f.equivalence(f1, f2)</code> <code>f1 &lt;=&gt; f2</code> Conjunction <code>f.and(f1, f2, f3)</code> <code>f1 &amp; f2 &amp; f3</code> Disjunction <code>f.or(f1, f2, f3)</code> <code>f1 | f2 | f3</code> <p>The order of operands in the resulting formula does not follow an overall ordering but depends on the formulas created first. If a formula <code>B &amp; A</code> was created, the order of the operands will be always <code>B, A</code>. Thus, when creating another formula <code>A &amp; B</code> it will result in <code>B &amp; A</code>. If another formula <code>A &amp; B &amp; C</code> is created, the operands occur in the order <code>A, B, C</code>, since <code>A &amp; B &amp; C</code> was the first created formula.</p> <p>It is also possible to write Pseudo-Boolean constraints, especially cardinality constraints like e.g. <code>A + B + C &lt;= 1</code>:</p> <pre><code>f.cc(CType.LE, 1, Arrays.asList(f.variable(\"A\"), f.variable(\"B\"), f.variable(\"C\")))\n</code></pre> <p>which means from variables <code>A</code>, <code>B</code>, <code>C</code> can be at most one variable assigned to true.  An example for a Pseudo-Boolean constraint is <code>A + 2* ~B - 3*C = 2</code>:</p> <pre><code>List&lt;Literal&gt; lits =\n        Arrays.asList(f.variable(\"A\"), f.literal(\"B\", false), f.variable(\"C\"));\nList&lt;Integer&gt; coeffs = Arrays.asList(1, 2, -3);\nf.pbc(CType.EQ, 2, lits, coeffs);\n</code></pre> <p>Beside the mentioned factory methods there are many convenience methods to create formulas. Examples are:</p> <ul> <li><code>constant(boolean value)</code> which creates a <code>$true</code> or <code>$false</code> constant depending on the given Boolean value</li> <li><code>cnf(Formula... clauses)</code> creating a conjunctive normal form (CNF) for the given clauses</li> <li><code>clause(Literal... literals)</code> creating a clause for the given literals</li> <li><code>variables(Collection&lt;String&gt; names)</code> and <code>variables(String... names)</code> creating a set of variables from the given names (since  2.4.0)</li> </ul> <p>For information about properties of formulas check out the next chapter Formulas.</p> <p>When creating a formula factory, the factory does not contain any formulas except from the constants <code>true</code> and <code>false</code>, which are always generated when creating a formula factory.</p> <p>Another option for using a formula within a formula factory without creating it, is to import a formula from a different formula factory (see further below).</p>"},{"location":"documentation/formula-factory/#configuring-the-formula-factory","title":"Configuring the Formula Factory","text":"<p>The user can configure some settings of the formula factory.  Those are given over via the <code>FormulaFactoryConfiguration</code> (see FormulaFactoryConfig), with which the formula factory can be generated. If the formula factory is generated with no parameter, then the default formula factory configuration is chosen. The parameters that can be configured are:</p> <ul> <li>The formula merge strategy:   The formula merge strategy is concerned with combining formulas of different formula factories. A formula from a different factory can only be used in the current factory after importing it.  In order to avoid bugs by using formulas from different factories without importing it, the default behaviour of the formula factory is to panic and throw an exception.  This however can be changed to the import strategy - then a formula from a different factory is automatically imported.  The respective configuration flags are <code>PANIC</code>, and <code>IMPORT</code>.</li> <li>A flag, whether complementary operands shall be simplified. This is the flag whether complementary operands within a conjunction or disjunction should be simplified. For example, shall a formula like <code>A &amp; ~A</code>, <code>(A | ~A) &amp; C</code>, or <code>(A &amp; B) | ~(A &amp; B)</code> be simplified or not.  If the flag is set to <code>true</code>, these formulas will be simplified during creation to <code>$false</code>, <code>C</code>, and <code>$true</code> respectively.  If the flag is set to <code>false</code> such trivial tautologies and contradictions are not simplified but kept.</li> <li>The string representation:  This is the default string representation of formulas when using Java's standard <code>toString()</code> method.  In LogicNG there are three default implementations:</li> <li>UTF8StringRepresentation for a UTF-8 representation with nice symbols for the operands and sub-script for indexed variables</li> <li>LatexStringRepresentation for a LaTeX notation of the formulas</li> <li>DefaultStringRepresentation, which is the default string representation and outputs the formulas in the LogicNG syntax which can be parsed again by the LogicNG parsers.</li> </ul> <p>Consider the formula <code>A &amp; B | C</code>.  The UTF-8 representation gives the formula out as <code>A \u2227 B \u2228 C</code> and the Latex style representation as <code>A \\land B \\lor C</code>. The default representation is <code>A &amp; B | C</code>.</p> <ul> <li>the name: An optional name for the formula factory (which can be useful when using more than one formula factory at the time).  The default is the empty string <code>\"\"</code>. Note that the name will appear in all auxiliary variables (constructed variables for CNF, PB and CC encodings) and will not be changed when imported to other factories.</li> </ul> <p>The parameters of the default configuration is summarized here:</p> <p>Default Configuration</p> <p>When constructing a formula factory without configuration, the default configuration <code>FormulaFactoryConfig</code> is constructed. The settings are:</p> <ul> <li>name: <code>\"\"</code></li> <li>formula merge strategy: <code>PANIC</code></li> <li>string representation: <code>DefaultStringRepresentation</code></li> <li>simplify complementary operands: <code>true</code></li> <li>ccPrefix: <code>@RESERVED_CC_</code>, pbPrefix: <code>@RESERVED_PB_</code>, cnfPrefix: <code>@RESERVED_CNF_</code></li> </ul> <p>In order to create a formula factory with different parameters, one can use the <code>FormulaFactoryConfig</code> builder as follows:</p> <pre><code>FormulaFactory f = new FormulaFactory(\n  FormulaFactoryConfig.builder()\n    .formulaMergeStrategy(FormulaFactoryConfig.FormulaMergeStrategy.IMPORT)\n    .stringRepresentation(UTF8StringRepresentation::new)\n    .name(\"New factory\")\n  .build());\n</code></pre>"},{"location":"documentation/formula-factory/#configuring-further-aspects-of-logicng-in-the-formula-factory","title":"Configuring Further Aspects of LogicNG in the Formula Factory","text":"<p>A formula factory can also hold configurations for different algorithms in LogicNG.  These algorithms can be configured when using or by putting an initial configuration in the formula factory.</p> <p>E.g. currently the following configurations can be put on the formula factory:</p> <ul> <li>CNF configuration (see CNFConfig), defining the encoding procedure used to generate a CNF of a formula, e.g. when <code>f1.cnf()</code> is called.</li> <li>Cardinality constraint configuration (see CCConfig), defining the encoding procedure used when a cardinality constraints is encoded, e.g. when <code>f1.cc()</code> is called.</li> <li>Pseudo-Boolean configuration (see PBConfig),  defining the encoding procedure used when a Pseudo-Boolean constraint is encoded, e.g. when <code>f1.pb()</code> is called.</li> <li>Formula randomizer (see FormulaRandomizerConfig), a configuration for random formula generation, which can be a useful tool for testing.</li> <li>MUS (see MUSConfig), the configuration object for the MUS (minimal unsatisfiable set) generation.</li> </ul> <p>Further, one can specify parameters for the different solvers:</p> <ul> <li>MiniSAT solver (see MiniSatConfig)</li> <li>MaxSAT solver (see MaxSATConfig)</li> <li>Glucose SAT solver (see GlucoseConfig)</li> </ul> <p>More information about these can be found in the chapter on solvers.</p> <p>Using <code>f.putConfiguration(config)</code>, for some configuration <code>config</code>, one can put a new configuration into the configuration database. Existing configurations for this type will be overwritten. <code>f.configurationFor(configType)</code> (for some configuration type <code>configType</code>) returns the configuration of a specific configuration type.</p> <p>Example: Changing a configuration of the formula factory</p> <p>Consider the cardinality constraint</p> <pre><code>A + B + C &lt;= 1\n</code></pre> <p>Using the default cardinality constraint configuration, the cardinality constraint is encoded to:</p> <pre><code>(~A | ~B) &amp; (~A | ~C) &amp; (~B | ~C)\n</code></pre> <p>However, if you'd like to encode the cardinality constraint differently, you may choose to set a different algorithm for the encoding of cardinality constraints in the formula factory.  For example, changing the formula factory's default algorithm for encoding at-most-one constraints with the LADDER encoding, one could configure the formula factory in the following way:</p> <pre><code>CCConfig config = CCConfig.builder().amoEncoding(CCConfig.AMO_ENCODER.LADDER).build();\nf.putConfiguration(config);\n</code></pre> <p>The resulting cardinality constraint encoding is then, for the auxiliary variables <code>x1</code> and <code>x2</code>: <pre><code>(~A | x1) &amp; (~B | x2) &amp; (~x1 | x2) &amp; (~B | ~x1) &amp; (~C | ~x1)\n</code></pre></p>"},{"location":"documentation/formula-factory/#more-methods-on-formula-factories","title":"More Methods on Formula Factories","text":"<p>Some more useful methods on formula factories are:</p> <ul> <li>Remove all formulas from the factories cache with <code>f.clear()</code>: Use this method if you want to hold on to the \"settings\" of the formula factory, but get rid of all formulas created so far</li> <li>Import a formula from another formula factory into this factory and return it: <code>f.importFormula(f1)</code>. If the current factory of the formula is already this formula factory (<code>f</code>), the same instance will be returned</li> <li>Check whether a variable is a generated variable with <code>f.isGeneratedVariable(v)</code> for some variable <code>v</code>. A variable is considered to be a generated variable (or auxiliary variable) if it was generated during a CNF, PG or cardinality constraints encoding</li> <li>Get some statistics about the formula factory: <code>f.statistics()</code> returns a <code>FormulaFactoryStatistics</code> which includes some relevant information about the factory, for example:<ul> <li>The number of formulas the formula factory holds in total</li> <li>The number of formulas the formula factory holds for each formula type</li> </ul> </li> </ul>"},{"location":"documentation/formula-factory/#caching-formulas-in-practice-and-the-extended-formula-factory","title":"Caching Formulas in Practice and the Extended Formula Factory","text":"<p>While caching formulas in the formula factory in most cases greatly improves heap space usage and performance, there are some cases where this behaviour could be undesirable. An example is an application which holds a large base rule set and there are many requests for other large formulas, which are checked against this base rule set. If the application runs in a server environment and uses one formula factory, this formula factory would potentially grow with every request. Usually this does not happen too often in practice, since in our experience, also the base rule set is something which is not static and is created with each request. However, for the described scenario, the ever-caching formula factory would be a suboptimal approach.</p> <p>Therefore, there is an <code>ExtendedFormulaFactory</code> which extends the normal formula factory by the ability of saving and loading the state of the factory, therefore temporarily adding formulas to the factory and then removing them again. Thus, in the described scenario, one could add the base rule set and save the formula factory state. Then we add some large other formulas, perform our computations, and when we are done, we load the saved state.  By these operations, all internal data structures of the formula factory are shrunk to their length as stored in the saved state and therefore the formulas added after the state save are removed.  Also, for internal consistency reasons, the caches of all formulas are cleared.</p> <p>The following code example shows the usage of this feature</p> <pre><code>ExtendedFormulaFactory f = new ExtendedFormulaFactory();\nPropositionalParser p = new PropositionalParser(f);\n\n// read and work with a large base formula\n\nFormulaFactoryState state = f.save(); // (1)!\np.parse(\"...\"); // (2)!\nf.load(state); // (3)!\n</code></pre> <ol> <li>saves the current state</li> <li>work with large additional formulas</li> <li>reset the factory to the state after adding the base formula</li> </ol> <p>Formula Factories and Thread Safety</p> <p>A formula factory has many internal data structures which are not thread safe.  Therefore, one must never use a single formula factory object in a multi-threaded fashion.  Different threads accessing the same formula factory at the same time can lead to concurrency exceptions, undefined behaviour, and incorrect computations.  In a multi-threaded application, each thread should have its own formula factory on which it operates.</p>"},{"location":"documentation/graphs/","title":"Graphs","text":"<p>LogicNG has a very simple implementation of graph and hypergraph data structures with some useful algorithms implemented on them.  These can in no way compete with dedicated graph libraries, but provide enough performance and capabilities to be useful for certain scenarios.  There are two main use cases:</p> <ol> <li>Generating constraint graphs for formulas</li> <li>Generating hypergraphs for formulas</li> </ol>"},{"location":"documentation/graphs/#constraint-graphs-and-connected-components","title":"Constraint Graphs and Connected Components","text":"<p>Constraint graphs can be used to represent relations among different formulas. The nodes of the graph are the variables in the formulas, and the edges indicate whether two variables occur in the same formula.</p> <p>In LogicNG, you can generate a constraint graph with the ConstraintGraphGenerator in the following way:</p> <pre><code>List&lt;Formula&gt; formulas = Arrays.asList(p.parse(\"A | ~B | C\"),\n        p.parse(\"D | ~A\"), p.parse(\"D + E = 1\"), p.parse(\"G\"));\nGraph&lt;Variable&gt; constraintGraph =\n        ConstraintGraphGenerator.generateFromFormulas(formulas);\n</code></pre> <p>In this example, the result is a graph looking like this:</p> <pre><code>graph TD\n  id0((\"A\"))\n    style id0 stroke:#009432,color:#ffffff,fill:#009432\n  id1((\"B\"))\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id2((\"C\"))\n    style id2 stroke:#009432,color:#ffffff,fill:#009432\n  id3((\"D\"))\n    style id3 stroke:#009432,color:#ffffff,fill:#009432\n  id4((\"E\"))\n    style id4 stroke:#009432,color:#ffffff,fill:#009432\n  id5((\"G\"))\n    style id5 stroke:#009432,color:#ffffff,fill:#009432\n\n  id0 --- id1\n  id0 --- id2\n  id0 --- id3\n  id1 --- id2\n  id3 --- id4</code></pre> <p>Application Insight</p> <p>The constraint graph itself can be interesting for a visualization of formulas and their dependencies, but one can also use the constraint graph to improve computations.  For example one can compute strongly connected components of the graph.  A strongly connected component is a set of nodes where each node is reachable by all other nodes via some edges.  If a constraint graph has more than one connected component, some algorithms can be performed independently on the single components, therefore allowing parallelization and complexity reductions.  E.g. if you want to compute the model count for a large set of formulas and the constraint graph has three components <code>A</code>, <code>B</code>, and <code>C</code>, then you can compute the count of the three components independently and then multiply the three counts.  The LogicNG internal model counter e.g. makes use of this and computes strongly connected components before computing the count.</p> <p>You can compute the strongly connected components in the following way:</p> <pre><code>final Set&lt;Set&lt;Node&lt;Variable&gt;&gt;&gt; ccs =\n        ConnectedComponentsComputation.compute(constraintGraph);\nfinal List&lt;List&lt;Formula&gt;&gt; components =\n        ConnectedComponentsComputation.splitFormulasByComponent(formulas, ccs);\n</code></pre> <p>Then the set of connected set of nodes <code>ccs</code> contains:</p> <pre><code>- Set1:\n    - Node{content=A, neighbours:B,C,D}\n    - Node{content=B, neighbours:A,C}\n    - Node{content=C, neighbours:A,B}\n    - Node{content=D, neighbours:A,E}\n    - Node{content=E, neighbours:D}\n- Set2:\n    - Node{content=G, neighbours}\n</code></pre> <p>and the <code>components</code> are:</p> <pre><code>- [A | ~B | C, D | ~A, D + E = 1]\n- [G]\n</code></pre>"},{"location":"documentation/graphs/#hypergraphs","title":"Hypergraphs","text":"<p>In a hypergraph an edge can connect more than two nodes.  Hypergraph decomposition is an important method used in many algorithms to find a good variable ordering, e.g. for BDD or DNNF generation.  Since hypergraph decomposition is a very complex subject and there are dedicated libraries for that, LogicNG does not implement its own hypergraph decomposition.  However, the FORCE heuristic of BDDs uses an approximation of hypergraph decomposition on the hypergraph.</p> <p>For this case, each edge in the hypergraph represents a single clause in the CNF (remember, the edge can connect more than two nodes).  Such a hypergraph of a CNF can be generated in the following way:</p> <pre><code>List&lt;Formula&gt; formulas = Arrays.asList(p.parse(\"A | ~B | C\"), p.parse(\"D | ~A\"),\n        p.parse(\"D | ~E\"), p.parse(\"G\"));\nHypergraph&lt;Variable&gt; hypergraph = HypergraphGenerator.fromCNF(formulas);\n</code></pre> <p>The result is then a hypergraph with four edges:</p> <pre><code>Hypergraph{\n  ...\n  edges=[\n    HypergraphEdge{nodes=[\n      HypergraphNode{content=A},\n      HypergraphNode{content=B},\n      HypergraphNode{content=C}\n    ]},\n    HypergraphEdge{nodes=[\n      HypergraphNode{content=A},\n      HypergraphNode{content=D}\n    ]},\n    HypergraphEdge{nodes=[\n      HypergraphNode{content=D},\n      HypergraphNode{content=E}\n    ]},\n    HypergraphEdge{nodes=[\n      HypergraphNode{content=G}]}\n    ]}\n</code></pre>"},{"location":"documentation/handlers/","title":"Handlers","text":"<p>Handlers in general are user provided objects to algorithms which allow to take control over certain aspects of the algorithm and stopping the computation if given criteria are met.  Especially the computationally expensive algorithms like SAT and MaxSAT Solving, knowledge compilation, formula simplification, or MUS computation take handlers.  You can either use one of the handlers which are implemented in LogicNG or implement your own handler. The hierarchy of the classes and interfaces in the package <code>handlers</code> is here:</p> <pre><code>classDiagram\n  Handler &lt;|-- DnnfCompilationHandler\n  Handler &lt;|-- SATHandler\n    SATHandler &lt;|-- TimeoutSATHandler\n  Handler &lt;|-- MaxSATHandler\n    MaxSATHandler &lt;|-- TimeoutMaxSATHandler\n  Handler &lt;|-- FactorizationHandler\n  Handler &lt;|-- OptimizationHandler\n    OptimizationHandler &lt;|-- TimeoutOptimizationHandler\n  Handler &lt;|-- BDDHandler\n    BDDHandler &lt;|-- TimeoutBDDHandler\n  Handler &lt;|-- ModelEnumerationHandler\n    ModelEnumerationHandler &lt;|-- TimeoutModelEnumerationHandler\n  Handler &lt;|-- ComputationHandler\n    ComputationHandler &lt;|-- TimeoutHandler\n    ComputationHandler &lt;|-- NumberOfNodesBDDHandler\n    ComputationHandler &lt;|-- NumberOfModelsHandler\n  TimeoutHandler &lt;|.. TimeoutSATHandler\n  TimeoutHandler &lt;|.. TimeoutMaxSATHandler\n  TimeoutHandler &lt;|.. TimeoutOptimizationHandler\n  TimeoutHandler &lt;|.. TimeoutBDDHandler\n  TimeoutHandler &lt;|.. TimeoutModelEnumerationHandler</code></pre> <p>The interface Handler has two methods which can be overridden:</p> <ol> <li><code>aborted()</code> returns whether the computation was aborted or not</li> <li><code>started()</code> is called whenever the computation is started and can be used to initialize the handler</li> </ol> <p>A number of interfaces implement the <code>Handler</code>. The handler you're using has to implement the relevant interface, depending on what sort of computation you are performing.</p> <p>These are the top level handler interfaces:</p> <ul> <li>FactorizationHandler is an interface for handling factorization methods for normal forms (CNF, DNF). It has two methods: <code>performedDistristibution()</code> is called each time a distribution is performed, <code>createdClause()</code> is called each time a new clause is created.</li> <li>SATHandler is an interface for handling the solving process of a SAT solver. <code>detectedConflict()</code> is called each time a conflict is found, and <code>finishedSolving()</code> is called when the SAT solver finished solving.</li> <li>MaxSATHandler is an interface for handling the solving process of a Max-SAT solver.  It has itself a <code>SATHandler</code> which is used for its underlying SAT solver and provides the two methods <code>foundUpperBound()</code> and <code>foundLowerBound()</code> which are called whenever a new upper or lower bound is found in the solving process as well as the two methods <code>lowerBoundApproximation()</code> and <code>upperBoundApproximation()</code> which return the current approximation of the lower/upper bound of the problem.  These methods can e.g. be used to abort the computation when a certain bound is found or to return the current bound when the computation is aborted.</li> <li>BDDHandler is an interface for BDD compilation handlers.  The method <code>newRefAdded()</code> is called every time a new node reference is added to the BDD kernel.</li> <li>DnnfCompilationHandler is an interface for DNNF compilation handlers. The method <code>shannonExpansion()</code> is called each time a Shannon expansion is performed.</li> <li>ModelEnumerationHandler is an interface for (projected) model enumeration on the SAT solver with the <code>ModelEnumerationFunction</code>.  It has its own <code>SATHandler</code> for its underlying SAT solver as well as a method <code>foundModel</code> which is called every time a model is found.</li> <li>OptimizationHandler is an interface for optimizations on the SAT solver.  It has a <code>SATHandler</code> for its underlying SAT solver as well as the method <code>foundBetterBound</code> which is called every time a new better bound for the optimization problem is found.  It is used in the <code>OptimizationFunction</code> of the SAT solver and in internal optimization calls in the <code>AdvancedSimplifier</code> .</li> </ul>"},{"location":"documentation/handlers/#some-useful-handlers-implemented-in-logicng","title":"Some Useful Handlers Implemented in LogicNG","text":"<p>All handlers implemented in LogicNG inherit from the abstract class ComputationHandler. There are three classes extending the <code>ComputationHandler</code>:</p> <ol> <li>TimeoutHandler for aborting computations based on their computation time.</li> <li>NumberOfNodesBDDHandler for aborting BDD generations based on the number of generated nodes in the kernel.</li> <li>NumberOfModelsHandler for aborting model enumerations based on the number of enumerated model.</li> </ol>"},{"location":"documentation/handlers/#the-timeouthandler","title":"The TimeoutHandler","text":"<p>The <code>TimeoutHandler</code> stops the computation after a specific time. The constructor of a <code>TimeoutHandler</code> takes a timeout in milliseconds and a <code>TimerType</code>, which specifies the type of the timeout. The timer types are:</p> <ul> <li><code>SINGLE_TIMEOUT</code>: The timeout is started when <code>started()</code> on the handler is called. Subsequent calls to <code>started()</code> have no effect on the timeout. Thus, the timeout can only be started once.</li> <li><code>RESTARTING_TIMEOUT</code>: The timeout is restarted when <code>started()</code> on the handler is called.</li> <li><code>FIXED_END</code>: Timeout which is interpreted as fixed point in time (in milliseconds) at which the computation should be aborted. The method <code>started()</code> must still be called, but does not have an effect on the timeout.</li> </ul> <p>Handler Responsiveness</p> <p>Note that it might take a few milliseconds more until the computation is actually canceled, since the cancellation depends on the next call to the handler and for performance reasons calls to the handler are only performed on certain points during the computation.  For the overloaded constructor, that takes only a timeout in milliseconds, the timer type is <code>SINGLE_TIMEOUT</code>.</p> <p>A number of classes extend the <code>TimeoutHandler</code>. For those classes, the interpretation of the timer type is identical. However, they implement different interfaces and can thus be used for different use cases:</p> <ul> <li>TimeoutSATHandler handles the solving process of a SAT solver.  It aborts the solving process when the time limit is exceeded.</li> <li>TimeoutMaxSATHandler handles the solving process of a MaxSAT solver.  It aborts the solving process when the time limit is exceeded.</li> <li>TimeoutOptimizationHandler handles optimization problems, for example the <code>OptimizationFunction</code> or the <code>AdvancedSimplifier</code> (cf. here).</li> <li>TimeoutBDDHandler handles the construction process of BDDs.</li> <li>TimeoutModelEnumerationHandler handles the process of enumerating models. For more information see the chapter on Model counting and enumeration.</li> </ul>"},{"location":"documentation/handlers/#the-numberofnodesbddhandler","title":"The NumberOfNodesBDDHandler","text":"<p>The <code>NumberOfNodesBDDHandler</code> cancels the build process of a BDD after a given number of added nodes is reached.</p>"},{"location":"documentation/handlers/#the-numberofmodelshandler","title":"The NumberOfModelsHandler","text":"<p>The <code>NumberOfModelsHandler</code> terminates the model enumeration process after a given number of models is reached. For more information see the chapter on Model counting and enumeration|.</p> <p>Creating your own Handler</p> <p>Consider the following example for creating an own handler. We implement a <code>SATHandler</code> which stops the computation after a certain number of conflicts is reached. To make our implementation easier, we extend the <code>ComputationHandler</code> which already provides the <code>aborted</code> attribute.</p> <pre><code>public class MaxNumberOfConflictsSATHandler extends ComputationHandler implements SATHandler {\n    private final int maxNumberOfConflicts;\n    private int numConflicts;\n\n    /**\n     * Constructs a new instance with the given maximal number of conflicts.\n     * @param maxNumberOfConflicts the maximal number of conflicts limit,\n     *                             if -1 then no limit is set\n     */\n    public MaxNumberOfConflictsSATHandler(final int maxNumberOfConflicts) {\n        this.maxNumberOfConflicts = maxNumberOfConflicts;\n        this.numConflicts = 0;\n    }\n\n    @Override\n    public void started() {\n        this.started();\n        this.numConflicts = 0;\n    }\n\n    @Override\n    public boolean detectedConflict() {\n        this.aborted = maxNumberOfConflicts != -1 &amp;&amp; ++numConflicts &gt;= maxNumberOfConflicts;\n        return !aborted;\n    }\n}\n</code></pre>"},{"location":"documentation/io/","title":"I/O","text":"<p>There are some useful I/O classes for parsing/reading/writing formulas and other data structures.</p>"},{"location":"documentation/io/#parsers","title":"Parsers","text":"<p>Parsers are used to parse formula strings into LogicNG formulas.  Throughout the documentation, we use the pseudo-Boolean parser PseudoBooleanParser by calling <code>p.parse(...)</code>, but - most important - we can also implement own parsers for our applications.</p> <p>Parsers in LogicNG are generated by the parser framework ANTRL (LogicNG's only external dependency).  You only define a grammar file and ANTLR generates the Java classes for the parser at compile time.  LogicNG's parser grammars lie here.  There are two parsers:</p> <ol> <li>PropositionalParser for parsing propositional formulas without cardinality or pseudo-Boolean constraints.  Its grammar can be found here</li> <li>PseudoBooleanParser for parsing formulas with cardinality or pseudo-Boolean constraints.</li> </ol> <p>Info</p> <p>Since LogicNG  2.5.0 parsers for formula strings have been moved into an own project parser to avoid the ANTLR dependency which is unwanted for some applications.</p> <p>Application Insight</p> <p>You can easily implement you own parsers for you propositional language by looking at these grammar files and implementing your own parser inheriting from FormulaParser.  Then you only need to write minimal code.</p>"},{"location":"documentation/io/#readers","title":"Readers","text":"<p>There are two formula readers implemented in LogicNG:</p> <ul> <li>DIMACS reader for reading CNF files as used in the SAT competition in the DIMACS CNF format.</li> <li>Formula reader for reading files in LogicNG syntax from a file.</li> </ul> <p>The formula reader can read propositional formulas with or without pseudo-Boolean constraints.  Multiple lines in a file are interpreted as a conjunction of the formulas in each line.</p>"},{"location":"documentation/io/#writers","title":"Writers","text":"<p>There are three writers for formulas in the <code>org.logicng.io</code> package:</p> <ul> <li>DIMACS writer for writing CNFs as DIMACS CNF files like described above.</li> <li>Formula writer for writing formulas in LogicNG syntax.  The formula writer has the option <code>splitAndMultiline</code> which, if set to <code>true</code>, writes the different operands of a top-level conjunction in single lines.  This can often improve readability, and the corresponding <code>FormulaReader</code> can read this format.</li> </ul> <p>For graphs, there are two writers:</p> <ul> <li>DIMACS writer for writing a DIMACS graph file of the graph.</li> </ul>"},{"location":"documentation/io/#graphical-writers","title":"Graphical Writers","text":"<p> 2.4.0</p> <p>Instead of writing plain text files of formulas, BDDs, or graphs, it is often desireable to generate graphical representations of these data structures.  LogicNG has a generic framework for generating such graphical output in the package <code>org.logicng.io.graphical</code>.  The framework has the following features:</p> <ol> <li>It can produce output in two different formats:<ul> <li>DOT language: for generating files which can be turned into graphical representations by e.g. GraphViz</li> <li>Mermaid.js: With Mermaid.js you can easily integrate the generated graphs in a web page or application and can play around with it in the interactive live editor.</li> </ul> </li> <li>Individual node labels: the node label can be dynamically generated depending on the node's content.</li> <li>Individual styling of nodes: The shape, stroke color, text color, and background color of nodes for the graph can be styled either by a fixed style or with a dynamically depending on their content.</li> <li>Individual styling of edges: The type and color of edges for the graph can be styled either by a fixed style or with a dynamically depending on the nodes they connect.</li> </ol>"},{"location":"documentation/io/#basics","title":"Basics","text":"<p>There are some basic classes which are used in all graphical representations:</p> <ul> <li><code>GraphicalColor</code> for the representation of colors either in hex or in RGB whith some nice-looking predefined colors.</li> <li><code>GraphicalNode</code> for a node in the graphical representation.</li> <li><code>GraphicalEdge</code> for an edge in the graphical representation.</li> <li><code>GraphicalNodeStyle</code> for the style of a node.</li> <li><code>GraphicalEdgeStyle</code> for the style of an edge.</li> </ul> <p>From these basic building blocks, a <code>GraphicalRepresentation</code> is built.  This is always the first step and is usually done by using one of the implemented graphical generators (see next section).  Once you have generated this representation, you can decide in which format and how it is written - either as string or directly to a file.</p>"},{"location":"documentation/io/#graphical-generators","title":"Graphical Generators","text":"<p>There are four different generators for graphs:</p> <ol> <li><code>BddGraphicalGenerator</code> for generating graphical output of BDDs</li> <li><code>FormulaAstGraphicalGenerator</code> for generating graphical outputs of formula ASTs</li> <li><code>FormulaDagGraphicalGenerator</code> for generating graphical outputs of formula DAGs</li> <li><code>GraphGraphicalGenerator</code> for generating graphical outputs of graphs</li> </ol>"},{"location":"documentation/io/#using-the-default-styling","title":"Using the Default Styling","text":"<p>If you do not use any further styling, a sensible default look will be applied to the graph.  As an example consider the AST (abstract syntax tree, c.f. here) of a formula.  We consider the Formula <code>A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)</code> and create its default representation.</p> <pre><code>FormulaFactory f = new FormulaFactory();\nFormula formula = f.parse(\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\");\nFormulaAstGraphicalGenerator generator =\n        FormulaAstGraphicalGenerator.builder().build();\nGraphicalRepresentation representation = generator.translate(formula);\n</code></pre> <p>Since the <code>generator</code> was constructed with no individual styling in the builder, the default style is applied.</p> <p>For DOT we write the output in a file, for Mermaid.js we just get the <code>String</code> of the representation.</p> Mermaid.jsDOT <pre><code>String mermaidString = representation.writeString(GraphicalMermaidWriter.get());\n</code></pre> <pre><code>representation.write(\"dot-file.dot\", GraphicalDotWriter.get());\n</code></pre> <p>This representation with Mermaid.js looks like this:</p> <pre><code>graph TD\n  id0([\"\u21d4\"])\n  id1([\"\u2227\"])\n  id2([\"A\"])\n  id3([\"B\"])\n  id4([\"\u2228\"])\n  id5([\"A\"])\n  id6([\"B\"])\n  id7([\"\u2227\"])\n  id8([\"C\"])\n  id9([\"\u2228\"])\n  id10([\"A\"])\n  id11([\"B\"])\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre>"},{"location":"documentation/io/#customizing-the-node-label","title":"Customizing the Node Label","text":"<p>The generators can have their own mapping functions for the node label.  Therefore the user has to implement the <code>LabelMapper</code> interface which only has one method which decides which label to use for each node.  Alternatively you can just pass a lambda function as label mapper.</p> <p>Consider an example where you want to write the whole sub-formula as the node label, then you could just use the <code>toString()</code> method as label mapper:</p> <pre><code>FormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .build();\n</code></pre> <p>Now the representation looks like this:</p> <pre><code>graph TD\n  id0([\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"])\n  id1([\"A &amp; B &amp; (A | B)\"])\n  id2([\"A\"])\n  id3([\"B\"])\n  id4([\"A | B\"])\n  id5([\"A\"])\n  id6([\"B\"])\n  id7([\"C &amp; (A | B)\"])\n  id8([\"C\"])\n  id9([\"A | B\"])\n  id10([\"A\"])\n  id11([\"B\"])\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre>"},{"location":"documentation/io/#styling-nodes-and-edges-with-a-fixed-style","title":"Styling Nodes and Edges with a Fixed Style","text":"<p>You can configure the generator with a default style for nodes in edges.  If no dynamic style mapper is given, this style will be applied to all nodes and edges.  The default style can be configured with the <code>defaultEdgeStyle</code> and <code>defaultNodeStyle</code> methods of the builder.</p> <pre><code>FormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .defaultEdgeStyle(GraphicalEdgeStyle.dotted(null)) // (1)!\n        .defaultNodeStyle(GraphicalNodeStyle.rectangle(\n            GraphicalColor.BLUE, GraphicalColor.WHITE, GraphicalColor.BLUE)) // (2)!\n        .build();\n</code></pre> <ol> <li>If you pass <code>null</code> as the color, the default value of the framework will be taken.  In this case, Mermaid.js decides depending on light/dark mode how to color the edge.  Try it: if you switch to dark mode, the edges are white, in light mode, they are black.</li> <li>You can use some predefined color in the class <code>GraphicalColor</code> or define your own in RGB or HEX.</li> </ol> <p>This leads to the following graphics:</p> <pre><code>graph TD\n  id0[\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"]\n    style id0 stroke:#004f93,color:#ffffff,fill:#004f93\n  id1[\"A &amp; B &amp; (A | B)\"]\n    style id1 stroke:#004f93,color:#ffffff,fill:#004f93\n  id2[\"A\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3[\"B\"]\n    style id3 stroke:#004f93,color:#ffffff,fill:#004f93\n  id4[\"A | B\"]\n    style id4 stroke:#004f93,color:#ffffff,fill:#004f93\n  id5[\"A\"]\n    style id5 stroke:#004f93,color:#ffffff,fill:#004f93\n  id6[\"B\"]\n    style id6 stroke:#004f93,color:#ffffff,fill:#004f93\n  id7[\"C &amp; (A | B)\"]\n    style id7 stroke:#004f93,color:#ffffff,fill:#004f93\n  id8[\"C\"]\n    style id8 stroke:#004f93,color:#ffffff,fill:#004f93\n  id9[\"A | B\"]\n    style id9 stroke:#004f93,color:#ffffff,fill:#004f93\n  id10[\"A\"]\n    style id10 stroke:#004f93,color:#ffffff,fill:#004f93\n  id11[\"B\"]\n    style id11 stroke:#004f93,color:#ffffff,fill:#004f93\n\n  id1 --&gt; id2\n    linkStyle 0 stroke-width:2,stroke-dasharray:3\n  id1 --&gt; id3\n    linkStyle 1 stroke-width:2,stroke-dasharray:3\n  id4 --&gt; id5\n    linkStyle 2 stroke-width:2,stroke-dasharray:3\n  id4 --&gt; id6\n    linkStyle 3 stroke-width:2,stroke-dasharray:3\n  id1 --&gt; id4\n    linkStyle 4 stroke-width:2,stroke-dasharray:3\n  id7 --&gt; id8\n    linkStyle 5 stroke-width:2,stroke-dasharray:3\n  id9 --&gt; id10\n    linkStyle 6 stroke-width:2,stroke-dasharray:3\n  id9 --&gt; id11\n    linkStyle 7 stroke-width:2,stroke-dasharray:3\n  id7 --&gt; id9\n    linkStyle 8 stroke-width:2,stroke-dasharray:3\n  id0 --&gt; id1\n    linkStyle 9 stroke-width:2,stroke-dasharray:3\n  id0 --&gt; id7\n    linkStyle 10 stroke-width:2,stroke-dasharray:3</code></pre>"},{"location":"documentation/io/#styling-nodes-and-edges-dynamically","title":"Styling Nodes and Edges Dynamically","text":"<p>You can also style nodes and edges dynamically by passing node style or edge style mappers to the builder.  In the following example we want to distinguish between nodes with literals (terminals) and nodes with sub-formulas (inner nodes).  This can be done by configuring the generator with its own <code>NodeStyleMapper</code>.  As above: you can either implement a sub-class or just pass a lambda function.</p> <pre><code>GraphicalNodeStyle terminalNodeStyle =\n        GraphicalNodeStyle.rectangle(BLUE, WHITE, BLUE);\nGraphicalNodeStyle innerNodeStyle =\n        GraphicalNodeStyle.ellipse(YELLOW, BLACK, YELLOW);\n\nFormulaAstGraphicalGenerator generator = FormulaAstGraphicalGenerator.builder()\n        .labelMapper(Formula::toString)\n        .nodeStyleMapper((phi) -&gt;\n            phi.type() == FType.LITERAL ? terminalNodeStyle : innerNodeStyle)\n        .build();\n</code></pre> <p>This leades exactly to the representation of our documentation:</p> <pre><code>graph TD\n  id0([\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"])\n    style id0 stroke:#ffc612,color:#000000,fill:#ffc612\n  id1([\"A &amp; B &amp; (A | B)\"])\n    style id1 stroke:#ffc612,color:#000000,fill:#ffc612\n  id2[\"A\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3[\"B\"]\n    style id3 stroke:#004f93,color:#ffffff,fill:#004f93\n  id4([\"A | B\"])\n    style id4 stroke:#ffc612,color:#000000,fill:#ffc612\n  id5[\"A\"]\n    style id5 stroke:#004f93,color:#ffffff,fill:#004f93\n  id6[\"B\"]\n    style id6 stroke:#004f93,color:#ffffff,fill:#004f93\n  id7([\"C &amp; (A | B)\"])\n    style id7 stroke:#ffc612,color:#000000,fill:#ffc612\n  id8[\"C\"]\n    style id8 stroke:#004f93,color:#ffffff,fill:#004f93\n  id9([\"A | B\"])\n    style id9 stroke:#ffc612,color:#000000,fill:#ffc612\n  id10[\"A\"]\n    style id10 stroke:#004f93,color:#ffffff,fill:#004f93\n  id11[\"B\"]\n    style id11 stroke:#004f93,color:#ffffff,fill:#004f93\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre> <p>And here the corresponding dot file output:</p> <p></p>"},{"location":"documentation/model-counting-enumeration/","title":"Model Counting and Enumeration","text":"<p>When you determined the satisfiability of a formula with a SAT Solver and the formula is satisfiable, the solver yields one satisfying assignment (also called model) of the formula.  But you might wonder how many such models there are or list them all explicitly.  The first question concerns model counting, and the second concerns model enumeration.</p>"},{"location":"documentation/model-counting-enumeration/#model-enumeration","title":"Model enumeration","text":"<p>In LogicNG, you can either determine all models for a given formula (Model Enumeration, ME), or all models for a given subset of the formula's variables (Projected Model Enumeration, PME).</p> <p>Consider the following example:</p> <pre><code>Formula f1 = p.parse(\"A | (~B &amp; C)\");\nSATSolver solver = MiniSat.miniSat(f);\nsolver.add(f1);\n</code></pre> <p>Then <code>solver.enumerateAllModels()</code> returns all valid assignments of the solver:</p> <ul> <li><code>~A, ~B, C</code></li> <li><code>A, B, C</code></li> <li><code>A, ~B, C</code></li> <li><code>A, ~B, ~C</code></li> <li><code>A, B, ~C</code></li> </ul> <p>In case you are not interested in the model for every variable, you can give over the variables you're interested in as a parameter to the method and perform projected model enumeration. For example, <code>solver.enumerateAllModels(f.variable(\"A\"), f.variable(\"B\"))</code> returns the possible models for the variables <code>A</code> and <code>B</code>:</p> <ul> <li><code>~A, ~B</code></li> <li><code>A, B</code></li> <li><code>A, ~B</code></li> </ul> <p>Similarly, <code>solver.enumerateAllModels(f.variable(\"A\"))</code> returns the models for <code>A</code>:</p> <ul> <li><code>A</code></li> <li><code>~A</code></li> </ul> <p>The method <code>enumerateAllModels()</code> internally calls the solver function ModelEnumerationFunction. That is, you get the same result (here for example for the projection on <code>A</code>) using</p> <pre><code>List&lt;Assignment&gt; models = solver.execute(\n        ModelEnumerationFunction.builder().variables(f.variable(\"A\")).build());\n</code></pre>"},{"location":"documentation/model-counting-enumeration/#additional-variables","title":"Additional variables","text":"<p>When using the solver function directly, you can perform the projected model enumeration with so-called \"additional variables\". Those are variables which are not relevant for the actual enumeration, but we are interested in their assignment for any found model.</p> <p>Consider the following example:</p> <p><pre><code>SATSolver solver = MiniSat.miniSat(this.f);\nFormula formula1 = p.parse(\"A &amp; (B | C)\");\nFormula formula2 = p.parse(\"B | D\");\nsolver.add(formula1);\nsolver.add(formula2);\n\nSortedSet&lt;Variable&gt; pmeVars =\n        new TreeSet&lt;&gt;(Arrays.asList(f.variable(\"A\"), f.variable(\"B\")));\n\nList&lt;Assignment&gt; models1 = solver.execute(ModelEnumerationFunction.builder()\n        .variables(pmeVars)\n        .build()\n);\nList&lt;Assignment&gt; models2 = solver.execute(ModelEnumerationFunction.builder()\n        .variables(pmeVars)\n        .additionalVariables(f.variable(\"C\"))\n        .build()\n);\n</code></pre> The projected model enumeration over <code>A</code> and <code>B</code> (<code>models1</code>) returns the models:</p> <ul> <li><code>A, B</code></li> <li><code>A, ~B</code></li> </ul> <p>The projected model enumeration over <code>A</code> and <code>B</code> with additional variable <code>C</code> (<code>models2</code>) returns the models:</p> <ul> <li><code>A, B, ~C</code></li> <li><code>A, ~B, C</code></li> </ul> <p>That is, the projected model enumeration with additional variables finds for those assignments computed by the projected model enumeration one possible assignment for the variable <code>C</code>. This is really just one possible assignment: Note that not only <code>A, B, ~C</code>, but also  <code>A, B, C</code> is a valid model.</p> <p>Application Insight</p> <p>You may find <code>additionalVariables()</code> useful if you want to perform projected model enumeration over <code>variables()</code>, but are also interested in what truth value some \"additional variables\" can have in those assignments.</p> <p>Note that it does not make sense to add <code>additionalVariables()</code> without <code>variables()</code> to the builder, and it also does not make sense that the variables in <code>additionalVariables()</code> and the variables in <code>variables()</code> are overlapping.</p>"},{"location":"documentation/model-counting-enumeration/#configuring-the-assignment-type","title":"Configuring the Assignment Type","text":"<p> 2.3.0</p> <p>The builder method <code>fastEvaluable()</code> configures whether the models of the model enumeration are generated as fast evaluable Assignments or not.  For details about fast evaluable assignment see the info box here.</p>"},{"location":"documentation/model-counting-enumeration/#model-counting","title":"Model counting","text":"<p>Model counting is #P-complete, which in practice is much harder than NP. It is the task to compute the number of satisfiable models of a formula.</p> <p>If you already have an algorithm for model enumeration (as you have seen above), you can trivially count the number of models: <code>solver.enumerateAllModels().size()</code>.</p> <p>However, this approach isn't feasible for large model counts, since every model explicitly has to be enumerated. Instead of this trivial approach, knowledge compilers can be used to compute the model count more effectively.  Both, BDDs, and DNNFs are suitable for this task. The ModelCounter in LogicNG is based on the d-DNNF of a formula.</p> <p>An example is:</p> <pre><code>Formula f1 = p.parse(\"A &amp; (B | C)\");\nFormula f2 = p.parse(\"B | D\");\nFormula f3 = p.parse(\"~A | B &amp; E\");\nList&lt;Formula&gt; formulas = Arrays.asList(f1, f2, f3);\n\nSortedSet&lt;Variable&gt; variables = new TreeSet&lt;&gt;(Arrays.asList(f.variable(\"A\"),\n        f.variable(\"B\"), f.variable(\"C\"), f.variable(\"D\"), f.variable(\"E\")));\n\nBigInteger modelcount = ModelCounter.count(formulas, variables);\n</code></pre> <p>The result is 4, which can (in this simple case) be verified using model enumeration:</p> <ul> <li><code>A, B, ~C, ~D, E</code></li> <li><code>A, B, ~C, D, E</code></li> <li><code>A, B, C, ~D, E</code></li> <li><code>A, B, C, D, E</code></li> </ul> <p>The second parameter of the <code>count</code> function is an important one: Because of the automatic simplifications of formulas in LogicNG, it can happen that \"irrelevant\" variables (which don't have any influence on whether the formula is satisfiable or not) are removed from the formula. However, these variables still do affect the model count, since they can be set to both <code>false</code> and <code>true</code> s.t. each of those variables increases the model count by a factor of 2. So usually it makes sense to collect the set of variables passed to the model counter not from the formula at hand, but from the source where the formula came from.</p> <p>On the other hand, the set of variables must never be a strict subset of the variables of the formula.</p> <p>Projected model counting is currently not implemented in LogicNG (but there are plans...).</p> <p>Note</p> <p>It does not make sense to (1) compute a model, (2) perform (projected) model enumeration or (3) perform a model count when the conjunction of clauses which have been added to the solver is unsatisfiable. Depending on what you're trying to do, the result is <code>null</code> (1), <code>[]</code> (2) or <code>0</code> (3).</p> <p>If the solver is <code>UNSAT</code>, then there are two things you can do to understand why:</p> <ol> <li>Check the MUS of the SAT solver</li> <li>Check the resolution proof of the SAT solver using <code>unsatCore()</code>. Careful: this method only works if you have configured your SAT solver with <code>proofGeneration = true</code></li> </ol> <p>More about this in the chapter on explanations.</p>"},{"location":"documentation/propositions/","title":"Propositions","text":"<p>A Proposition is a formula with additional information like a textual description or a user-provided object.</p> <p>Application Insight</p> <p>Storing this extra information with the formulas can be useful in various application contexts. For example, we use propositions when we know that we will not only be interested in the result of an algorithm, but also the explanation of its result. For more information see the chapter on explanations.  The big advantage here is that the original formula context is maintained.  When adding a formula to the SAT solver, internally the formula is transformed to CNF and single clauses are added to the solver.  When you now extract an explanation for an unsatisfiable formula from the solver, the result will contain these single clauses which often are hard to map to the original input formulas.  By using propositions, the result will be in terms of the original prospotision which makes understanding the explanation much easier in practise.</p> <p>The abstract class <code>Proposition</code> has the single abstract method <code>formula()</code> which returns the formula of the proposition. LogicNG provides two implementations of a <code>Proposition</code>:</p>"},{"location":"documentation/propositions/#standard-proposition","title":"Standard Proposition","text":"<p>The StandardProposition holds a formula and a textual description. You can configure a proposition with and without a description:</p> <ol> <li> <p>With a description:</p> <pre><code>Proposition props1 =\n        new StandardProposition(\"my formula\", p.parse(\"A | ~B &amp; C\"));\n</code></pre> <p>generates the proposition <code>StandardProposition{formula=A | ~B &amp; C, description=my formula}</code></p> </li> <li> <p>Without a description:</p> <pre><code>Proposition props2 = new StandardProposition(p.parse(\"A | ~B &amp; C\"));\n</code></pre> <p>generates the proposition <code>StandardProposition{formula=A | ~B &amp; C, description=}</code></p> </li> </ol>"},{"location":"documentation/propositions/#extended-proposition","title":"Extended Proposition","text":"<p>The idea from extended propositions is to store additional domain-specific information with a formula. This information is not used for any algorithms in LogicNG - however, it can be useful to \"drag it along\" during your application.</p> <p>An ExtendedProposition is a formula with additional information provided in a user-defined object which implements the empty (marker-) interface PropositionBackpack.</p> <p>In your implementation of the <code>PropositionBackpack</code> you can store all sorts of information which you want to keep to your formula. Some examples are: An ID from the respective rule system the formula is from, the person who is responsible for the formula, the origin or the type of the formula.</p> <p>You can think of this information as literally the \"backpack\" of the formula. No algorithm in LogicNG looks \"inside\" this backpack, but the backpack is always kept. For example, if LogicNG performs algorithms on the formula, the result still holds the backpack, and maybe this helps you to understand the result better.</p> <p>Let us consider an example of using the extended proposition with an own backpack <code>MyBackpack</code>. Our backpack stores an ID, a person responsible for this formula and the rule type:</p> <pre><code>class MyBackpack implements PropositionBackpack {\n    private final long id;\n    private final String responsiblePerson;\n    private final RuleType ruleType;\n\n    MyBackpack(final long id, final String responsiblePerson,\n            final RuleType ruleType) {\n        this.id = id;\n        this.responsiblePerson = responsiblePerson;\n        this.ruleType = ruleType;\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        final MyBackpack that = (MyBackpack) o;\n        return id == that.id &amp;&amp;\n                Objects.equals(responsiblePerson, that.responsiblePerson) &amp;&amp;\n                ruleType == that.ruleType;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id, responsiblePerson, ruleType);\n    }\n\n    @Override\n    public String toString() {\n        return \"MyBackpack{\" +\n                \"id=\" + id +\n                \", responsiblePerson='\" + responsiblePerson + '\\'' +\n                \", ruleType=\" + ruleType +\n                '}';\n    }\n}\n\nenum RuleType {\n    IMPL,\n    EQUIV,\n    PBC,\n    CC\n}\n</code></pre> <p>Let's generate some propositions:</p> <pre><code>new ExtendedProposition&lt;&gt;(new MyBackpack(1, \"Rouven\", RuleType.EQUIV),\n        f.equivalence(p.parse(\"A &amp; B\"), p.parse(\"C\")));\nnew ExtendedProposition&lt;&gt;(new MyBackpack(2, \"Verena\", RuleType.IMPL),\n        f.implication(p.parse(\"A\"), p.parse(\"C | D\")));\nnew ExtendedProposition&lt;&gt;(new MyBackpack(3, \"Martin\", RuleType.CC),\n        f.amo(f.variable(\"A\"), f.variable(\"C\")));\n</code></pre> <p>The resulting propositions are:</p> <pre><code>ExtendedProposition{formula=A &amp; B &lt;=&gt; C, backpack=MyBackpack{id=1, responsiblePerson='Rouven', ruleType=EQUIV}}\nExtendedProposition{formula=A =&gt; C | D, backpack=MyBackpack{id=2, responsiblePerson='Verena', ruleType=IMPL}}\nExtendedProposition{formula=A + C &lt;= 1, backpack=MyBackpack{id=3, responsiblePerson='Martin', ruleType=CC}}\n</code></pre>"},{"location":"documentation/explanations/","title":"Explanations","text":"<p>Sometimes you might want to understand why a SAT problem is unsatisfiable and therefore does not have a solution.  Given a set of formulas for which the <code>sat()</code> call returns <code>UNSAT</code>, there is at least one contradiction in this set of formulas.</p> <p>Finding this contradiction is the goal of the explanation algorithms in LogicNG.  The approach of all of them is to find a subset of formulas which are involved in this conflict.  In LogicNG, three types of those subsets are implemented:</p> <ol> <li>Unsatisfiable core (Unsat Core)</li> <li>Minimal unsatisfiable subset (MUS)</li> <li>Smallest minimal unsatisfiable subset (SMUS)</li> </ol> <p>To explain the three different types of explanation, we consider the following example of a set of unsatisfiable formulas:</p> <pre><code>A &amp; B &amp; C\nA =&gt; D\nD =&gt; E\nE =&gt; ~C\nA =&gt; ~B\n</code></pre> <p>Analyzing this conflict by hand we can see that there are two problems in this formula set:</p> <ol> <li><code>A &amp; B &amp; C</code> must be true, but <code>A =&gt; ~B</code> contradicts this</li> <li><code>A &amp; B &amp; C</code> must be true, but the chain <code>A =&gt; D</code>, <code>D =&gt; E</code>, <code>E =&gt; ~C</code> contradicts this</li> </ol> <p>An unsatisfiable core is a subset of the original formulas which contains a conflict.  In this case this could be e.g.</p> <pre><code>A &amp; B &amp; C\nA =&gt; D\nA =&gt; ~B\n</code></pre> <p>We see this formula set still contains a conflict (the first from above) but also another formula which is not relevant for the conflict.  The unsat core may be (and usually is) smaller than the original set of formulas, as long as it still contains a conflict.  The advantage of an unsatisfiable core is that it can be efficiently computed on a SAT solver.</p> <p>A minimal unsatisfiable subset (MUS) is an unsat core with a certain condition: No formula can be removed from it without dissolving the conflict.  So in this example, the formula set</p> <pre><code>A &amp; B &amp; C\nA =&gt; D\nD =&gt; E\nE =&gt; ~C\n</code></pre> <p>would be a MUS.  No formula in this set can be removed without resolving the conflict.  A MUS is locally minimal, meaning you cannot remove formulas from the MUS but there may be smaller MUSes in the original formula set.</p> <p>That is where the smallest minimal unsatisfiable subset (SMUS) comes into play.  This a globally minimal MUS, meaning there may be other MUSes but none with lesser formulas.  In this case the subset</p> <pre><code>A &amp; B &amp; C\nA =&gt; ~B\n</code></pre> <p>is the only SMUS.</p> <p>Depending on your application, you may need one of these variants.  Note that an unsatisfiable core can be produced by the SAT solver directly (if proof tracing is activated) and often it is already a MUS, but that is not guaranteed.  If you need a MUS and already work with a SAT solver, it is a good idea to first extract an unsatisfiable core and then compute the MUS only on the core which usually has far fewer formulas than the original formula set.</p> <p>A SMUS is very hard to compute (since there can be exponentially many MUSes in a conflict).  Therefore, this really should only be used when required.</p> <p>Application Insight</p> <p>When working with explanations, we usually propose working with propositions instead of formulas, as they can store additional information and the explanations are returned in terms of propositions: When working with the SAT solver and using formulas, your explanation will contain clauses of the generated CNFs which often bare not much resemblance with the original input formulas.</p>"},{"location":"documentation/explanations/mus/","title":"MUS","text":"<p>A MUS is a minimal unsatisfiable subset for a given set of formulas.  It contains only those formulas which lead to the given set of formulas being unsatisfiable.  In other words: If you remove at least one of the formulas in the MUS from the given set of formulas, your set of formulas is satisfiable.  This means a MUS is locally minimal.  Thus, given a set of formulas which is unsatisfiable, you can compute its MUS and have one locally minimal conflict description why it is unsatisfiable.</p>"},{"location":"documentation/explanations/mus/#mus-algorithms","title":"MUS Algorithms","text":"<p>In LogicNG, two algorithms are implemented to compute the MUS: A deletion-based algorithm DeletionBasedMUS and an insertion-based algorithm PlainInsertionBasedMUS.</p> <p>The main idea of the deletion-based algorithm is to start with all given formulas and iteratively test each formula for relevance. A formula is relevant for the conflict, if its removal yields in a satisfiable set of formulas. Only the relevant formulas are kept. The main idea of the insertion-based algorithm is to start with an empty set and incrementally add propositions to the MUS which have been identified to be relevant.</p> <p>The default MUS generation MUSGeneration uses the deletion-based algorithm.</p>"},{"location":"documentation/explanations/mus/#computing-the-mus","title":"Computing the MUS","text":"<p>Consider the following propositions:</p> <pre><code>List&lt;Proposition&gt; props = new ArrayList&lt;&gt;();\nprops.add(new StandardProposition(p.parse(\"A &amp; B\")));\nprops.add(new StandardProposition(p.parse(\"B =&gt; ~C\")));\nprops.add(new StandardProposition(p.parse(\"A | C &amp; D\")));\nprops.add(new StandardProposition(p.parse(\"D &amp; (E | F)\")));\nprops.add(new StandardProposition(p.parse(\"C\")));\n</code></pre> <p>You can compute the MUS on a set of propositions in the following way:</p> <pre><code>UNSATCore&lt;Proposition&gt; core = new MUSGeneration().computeMUS(props, f);\n</code></pre> <p>The result is:</p> <pre><code>UNSATCore{\n  isMUS=true,\n  propositions=[\n    StandardProposition{formula=B =&gt; ~C, description=},\n    StandardProposition{formula=C, description=},\n    StandardProposition{formula=A &amp; B, description=}\n  ]\n}\n</code></pre> <p>indicating that the conflict arises from the following subset of formulas:</p> <pre><code>{A &amp; B, B =&gt; ~C, C}\n</code></pre> <p>As you can see, no proposition in this set can be removed without turning the set satisfiable, so in fact it is locally minimal.</p> <p>Note that it only makes sense to compute a MUS for an unsatisfiable formula set. If you call the MUS for a satisfiable formula set, an exception will be thrown.</p>"},{"location":"documentation/explanations/mus/#mus-configuration","title":"MUS Configuration","text":"<p>You can configure the MUS generation using the MUSConfig in order to</p> <ol> <li>specify the algorithm for the computation, and</li> <li>control the computation using a SATHandler which is passed to the SAT solver computing the MUS under the hood.</li> </ol> <p>For example, the following code snippet defines a MUS configuration with the plain insertion algorithm (see above) and a TimeoutSATHandler which stops the computation after 100 ms.</p> <pre><code>MUSConfig config = MUSConfig.builder()\n        .algorithm(MUSConfig.Algorithm.PLAIN_INSERTION)\n        .handler(new TimeoutSATHandler(100))\n        .build();\nUNSATCore&lt;Proposition&gt; core = musGeneration.computeMUS(props, f, config);\n</code></pre> <p>In this case, the result is the same for both algorithms. In general, this is not always the case.</p> <p>MUSes Are Not Unique</p> <p>A set of formulas can have multiple MUSes. Consider the following example:</p> <pre><code>List&lt;Proposition&gt; props = new ArrayList&lt;&gt;();\nprops.add(new StandardProposition(p.parse(\"~A\")));\nprops.add(new StandardProposition(p.parse(\"A | ~B\")));\nprops.add(new StandardProposition(p.parse(\"B\")));\nprops.add(new StandardProposition(p.parse(\"~B | C\")));\nprops.add(new StandardProposition(p.parse(\"~C | D\")));\nprops.add(new StandardProposition(p.parse(\"~D\")));\nprops.add(new StandardProposition(p.parse(\"~C | E\")));\nprops.add(new StandardProposition(p.parse(\"~E\")));\n</code></pre> <p>The two different algorithms return different MUSes. The default deletion-based algorithm returns the MUS:</p> <pre><code>{B, A | ~B, ~A}\n</code></pre> <p>and the plain insertion algorithm returns the MUS:</p> <pre><code>{B, ~D, ~B | C, ~C | D}\n</code></pre>"},{"location":"documentation/explanations/smus/","title":"Smallest MUS","text":"<p>We established in the last section on MUS, that a set of formulas can have more than one minimal unsatisfiable set (MUS).  One often computes a MUS in order to find out why a set of formulas is unsatisfiable.  But when there are multiple MUS, which is best to consider? Intuitively, one is interested in a particularly small MUS, as this means it describes the conflict very compactly.</p> <p>A smallest minimal unsatisfiable set (SMUS) is a smallest MUS based on the number of formulas it contains.  So in contrast to a regular MUS it is not only locally minimal, but globally minimal.</p> <p>The SMUS implementation in LogicNG is based on the paper Smallest MUS Extraction with Minimal Hitting Set Dualization by Ignatiev, Previti, Liffiton, and Marques-Silva from 2015.</p>"},{"location":"documentation/explanations/smus/#computing-the-smus","title":"Computing the SMUS","text":"<p>The class SmusComputation holds static methods for computing the SMUS: <code>computeSmus()</code> computes the SMUS over a set of propositions, <code>computeSmusForFormulas()</code> is a helper method and computes the SMUS over a set of formulas.</p> <p>The second parameter in both methods holds an optional list of additional constraints. If this list is non-empty, the SMUS is computed under these additional conditions.  The third parameter is a formula factory. The fourth parameter, which is optional (as both methods are overloaded), is an OptimizationHandler to control the computation execution and abort it if necessary.</p> <p>Let's consider the following list of propositions:</p> <pre><code>List&lt;Proposition&gt; props = new ArrayList&lt;&gt;();\nprops.add(new StandardProposition(p.parse(\"~A\")));\nprops.add(new StandardProposition(p.parse(\"A | ~B\")));\nprops.add(new StandardProposition(p.parse(\"B\")));\nprops.add(new StandardProposition(p.parse(\"~B | C\")));\nprops.add(new StandardProposition(p.parse(\"~C | D\")));\nprops.add(new StandardProposition(p.parse(\"~D | E\")));\nprops.add(new StandardProposition(p.parse(\"~C | E\")));\nprops.add(new StandardProposition(p.parse(\"~E\")));\n</code></pre> <p>We show three examples on how to compute the SMUS for these propositions.</p>"},{"location":"documentation/explanations/smus/#compute-without-additional-constraints","title":"Compute Without Additional Constraints","text":"<p>When computing the SMUS without additional constraints:</p> <pre><code>List&lt;Proposition&gt; result = SmusComputation.computeSmus(props, null, f);\n</code></pre> <p>the result is</p> <pre><code>{~A, A | ~B, B}\n</code></pre> <p>Thus, the smallest existing MUS consists of only three propositions. In this case this is the only smallest MUS. In general, however, there could be another MUS with the same smallest number of propositions.</p>"},{"location":"documentation/explanations/smus/#compute-with-additional-constraints","title":"Compute With Additional Constraints","text":"<p>Computing a SMUS using additional constraints means that a SMUS is computed from the given propositions under the assumption that the additional constraints hold. Note, the additional constraints are not part of the SMUS.</p> <p>For example, the additional constraint <code>D</code> leads to a smaller MUS than the previously found one:</p> <pre><code>List&lt;Proposition&gt; result = SmusComputation.computeSmus(props,\n        Collections.singletonList(p.parse(\"D\")), f);\n</code></pre> <p>The result contains only two propositions:</p> <pre><code>{~D | E, ~E}\n</code></pre> <p>The result can be read as: Under the constraint that <code>D</code> holds, the smallest MUS consists of the propositions <code>~D | E</code> and <code>~E</code>.</p> <p>Application Insight</p> <p>A use case for additional constraints can be constraints which hold universally and do not need to occur in the explanation in a certain context. For example, a set of wheels <code>{r1, r2, r3}</code> which mutually exclude each other. If our propositions are <code>r1</code>, <code>r2</code> and <code>r1 + r2 + r3 &lt;= 1</code>, then we get these three propositions back as SMUS. However, if instead the constraint <code>r1 + r2 + r3 &lt;= 1</code> is given as an additional constraint, the resulting SMUS is <code>{r1, r2}</code>: Assuming the exclusion of different wheels is a known constraint, the SMUS <code>{r1, r2}</code> is sufficient to explain the conflict.</p>"},{"location":"documentation/explanations/smus/#compute-with-a-handler","title":"Compute With a Handler","text":"<p>Suppose we perform the same operation as above, but we want to control the computation. The <code>TimeoutOptimizationHandler</code> below stops the computation after 100 ms.</p> <pre><code>List&lt;Proposition&gt; result = SmusComputation.computeSmus(\n        props,\n        Collections.singletonList(p.parse(\"D\")),\n        f,\n        new TimeoutOptimizationHandler(100));\n</code></pre> <p>Using a handler for the SMUS computation is often advisable, since the involved computations are very hard and can take a long time for complex cases.  Therefore, executing the SMUS computation without handler may result in very long computation times, if possible at all.</p>"},{"location":"documentation/explanations/unsat-cores/","title":"Unsat Cores","text":"<p>For an unsatisfiable set of formulas, the UNSATCore is a set of propositions which the SAT Solver found to be unsatisfiable during its search.  As described in the introduction chapter, this set does not need to be minimal.</p>"},{"location":"documentation/explanations/unsat-cores/#computing-the-unsat-core","title":"Computing the Unsat Core","text":"<p>Internally, the unsat core is being computed by the UNSATCoreFunction directly on the solver.  This only works for MiniSat and Glucose solvers and only if the parameter <code>proofTracing</code> is explicitly set to <code>true</code>.  Additionally, when using a Glucose solver, the <code>incremental</code> mode has to be deactivated.  As default, proof tracing is disabled since it requires slightly more time and memory.</p> <p>As an example, consider the following list of propositions:</p> <pre><code>List&lt;Proposition&gt; props = new ArrayList&lt;&gt;();\nprops.add(new StandardProposition(p.parse(\"~A\")));\nprops.add(new StandardProposition(p.parse(\"A | ~B\")));\nprops.add(new StandardProposition(p.parse(\"B\")));\nprops.add(new StandardProposition(p.parse(\"~B | C\")));\nprops.add(new StandardProposition(p.parse(\"~C | D\")));\nprops.add(new StandardProposition(p.parse(\"~D | E\")));\nprops.add(new StandardProposition(p.parse(\"~C | E\")));\nprops.add(new StandardProposition(p.parse(\"~E\")));\n</code></pre> <p>When adding these formulas to a solver and solving them, the result is <code>FALSE</code>.  Now we can extract the unsatisfiable core with</p> <pre><code>Tristate sat = solver.sat(); // (1)!\nUNSATCore&lt;Proposition&gt; unsatCore = solver.unsatCore();\n</code></pre> <ol> <li><code>sat()</code> call is required and the result has to be <code>FALSE</code> before calling <code>unsatCore()</code></li> </ol> <p>The result is:</p> <pre><code>UNSATCore{\n  isMUS=false,\n  propositions=[\n    StandardProposition{formula=~A, description=},\n    StandardProposition{formula=A | ~B, description=},\n    StandardProposition{formula=B, description=}\n  ]\n}\n</code></pre> <p>The first flag <code>isMUS</code> indicates whether the computed unsat core is known to be a MUS. To make sense of this, recall that a <code>MUS</code> is always an unsat core. Thus, also the <code>MUS</code> algorithms return an UNSATCore. In the case of computing a <code>MUS</code> with a <code>MUS</code> algorithm, the flag <code>isMUS</code> is <code>true</code>. When an unsat core has been extracted from the solver, at this point there is no guarantee that it is a <code>MUS</code>. Hence, in this use case the flag is always <code>false</code>.</p> <p>The set of propositions in this core is:</p> <pre><code>~A\nA | B\n~B\n</code></pre> <p>In fact, we can see that this set of formulas contains a contradiction.  And it only has 3 formulas compared to the original 8 formulas.  In this case, it is even a MUS and a SMUS but this is a coincidence.</p> <p>Practical Observation</p> <p>Normally, the unsatisfiable core of a SAT solver does not have many redundant terms and usually reduces the original formulas/propositions significantly.</p>"},{"location":"documentation/formulas/","title":"Formulas","text":"<p>As described in the previous chapter, there are different ways to create formulas, which all involve a formula factory.</p> <p>Here is an overview of the formula hierarchy in LogicNG:</p> <pre><code>classDiagram\n  class Constant\n  &lt;&lt;abstract&gt;&gt; Constant\n  class Formula\n  &lt;&lt;abstract&gt;&gt; Formula\n  class BinaryOperator\n  &lt;&lt;abstract&gt;&gt; BinaryOperator\n  class NAryOperator\n  &lt;&lt;abstract&gt;&gt; NAryOperator\n\n  Formula &lt;|-- Constant\n    Constant &lt;|-- CTrue\n    Constant &lt;|-- CFalse\n  Formula &lt;|-- Literal\n    Literal &lt;|-- Variable\n  Formula &lt;|-- Not\n  Formula &lt;|-- BinaryOperator\n    BinaryOperator &lt;|-- Implication\n    BinaryOperator &lt;|-- Equivalence\n  Formula &lt;|-- NAryOperator\n    NAryOperator &lt;|-- And\n    NAryOperator &lt;|-- Or\n  Formula &lt;|-- PBConstraint\n    PBConstraint &lt;|-- CardinalityConstraint</code></pre> <p>In this chapter we discuss the properties of formulas.  There are dedicated chapters on predicates, functions, and transformations on formulas.</p>"},{"location":"documentation/formulas/#properties-of-formulas","title":"Properties of Formulas","text":"<p>The most used properties of a formula are:</p> <ul> <li>The type of a formula indicates whether the formula is an implication, a conjunction, etc. The type can be retrieved by <code>formula.type()</code> (see <code>FType</code>)</li> <li>The set of variables contains all variables occurring (positively and/or negatively) in the formula, can be retrieved by <code>formula.variables()</code></li> <li>Similarly, <code>formula.literals()</code> returns the set of all literals occurring in the formula</li> </ul> <p>Further, one can check for every formula the following numbers:</p>"},{"location":"documentation/formulas/#the-number-of-atoms","title":"The Number of Atoms","text":"<p>The atoms of a formula are variables or constants, counting multiple occurrences. For example, formula <code>A &amp; B | A &amp; C</code> has 3 variables, but 4 atoms. You can check the number of atoms with <code>f1.numberOfAtoms()</code>.</p>"},{"location":"documentation/formulas/#the-number-of-nodes-and-internal-nodes","title":"The Number of Nodes and Internal Nodes","text":"<p>Any formula can be visualised (and thought of) as a directed acyclic graph (DAG). We consider the following example formula</p> <pre><code>Formula f1 = p.parse(\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\");\n</code></pre> <pre><code>graph TD\n  id0[\"A\"]\n    style id0 stroke:#004f93,color:#ffffff,fill:#004f93\n  id1[\"B\"]\n    style id1 stroke:#004f93,color:#ffffff,fill:#004f93\n  id2[\"C\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3((\"\u21d4\"))\n    style id3 stroke:#ffc612,color:#000000,fill:#ffc612\n  id4((\"\u2227\"))\n    style id4 stroke:#ffc612,color:#000000,fill:#ffc612\n  id5((\"\u2228\"))\n    style id5 stroke:#ffc612,color:#000000,fill:#ffc612\n  id6((\"\u2227\"))\n    style id6 stroke:#ffc612,color:#000000,fill:#ffc612\n\n  id4 --&gt; id0\n  id4 --&gt; id1\n  id5 --&gt; id0\n  id5 --&gt; id1\n  id4 --&gt; id5\n  id6 --&gt; id2\n  id6 --&gt; id5\n  id3 --&gt; id4\n  id3 --&gt; id6</code></pre> <p>The graph is also the internal representation of the formula. If you are interested in the size of the formula in memory, use <code>f1.numberOfInternalNodes()</code>. In this example this is 7, as the internal nodes are:</p> <ul> <li><code>A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)</code></li> <li><code>A &amp; B &amp; (A | B)</code></li> <li><code>C &amp; (A | B)</code></li> <li><code>A | B</code></li> <li><code>A</code></li> <li><code>B</code></li> <li><code>C</code></li> </ul> <p>On the other hand, one can also think of a formula as a tree like in the abstract syntax tree (AST) of the parsed formula. For <code>f1</code> the corresponding AST is:</p> <pre><code>graph TD\n  id0([\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\"])\n    style id0 stroke:#ffc612,color:#000000,fill:#ffc612\n  id1([\"A &amp; B &amp; (A | B)\"])\n    style id1 stroke:#ffc612,color:#000000,fill:#ffc612\n  id2[\"A\"]\n    style id2 stroke:#004f93,color:#ffffff,fill:#004f93\n  id3[\"B\"]\n    style id3 stroke:#004f93,color:#ffffff,fill:#004f93\n  id4([\"A | B\"])\n    style id4 stroke:#ffc612,color:#000000,fill:#ffc612\n  id5[\"A\"]\n    style id5 stroke:#004f93,color:#ffffff,fill:#004f93\n  id6[\"B\"]\n    style id6 stroke:#004f93,color:#ffffff,fill:#004f93\n  id7([\"C &amp; (A | B)\"])\n    style id7 stroke:#ffc612,color:#000000,fill:#ffc612\n  id8[\"C\"]\n    style id8 stroke:#004f93,color:#ffffff,fill:#004f93\n  id9([\"A | B\"])\n    style id9 stroke:#ffc612,color:#000000,fill:#ffc612\n  id10[\"A\"]\n    style id10 stroke:#004f93,color:#ffffff,fill:#004f93\n  id11[\"B\"]\n    style id11 stroke:#004f93,color:#ffffff,fill:#004f93\n\n  id1 --&gt; id2\n  id1 --&gt; id3\n  id4 --&gt; id5\n  id4 --&gt; id6\n  id1 --&gt; id4\n  id7 --&gt; id8\n  id9 --&gt; id10\n  id9 --&gt; id11\n  id7 --&gt; id9\n  id0 --&gt; id1\n  id0 --&gt; id7</code></pre> <p><code>f1.numberOfNodes()</code> returns the number of nodes of a formula tree. For <code>f1</code> the result is 12, consisting of the following nodes:</p> <ul> <li><code>A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)</code></li> <li><code>A &amp; B &amp; (A | B)</code></li> <li><code>C &amp; (A | B)</code></li> <li><code>(A | B)</code> (2x)</li> <li><code>A</code> (3x)</li> <li><code>B</code> (3x)</li> <li><code>C</code></li> </ul> <p>It is important to note however, that LogicNG always only stores the DAG in memory, therefore reducing heap size.</p>"},{"location":"documentation/formulas/#the-number-of-operands","title":"The Number of Operands","text":"<p>This number is 0 for constants and variables, 1 for a negation, 2 for binary operators, and \u2265 2 for n-ary operators. For formula <code>A &amp; B | C</code> the operands of the top-level disjunction are <code>A &amp; B</code> and <code>C</code>, thus the number of operands is two.</p>"},{"location":"documentation/formulas/#normal-form-predicates","title":"Normal Form Predicates","text":"<p> 2.3.0</p> <p>The following three predicates determine if a formula is in a given normal form:</p> <ul> <li><code>isNnf()</code>: whether the formula is in negation normal form (NNF)</li> <li><code>isCnf()</code>: whether the formula is in conjunctive normal form (CNF)</li> <li><code>isDnf()</code>: whether the formula is in disjunctive normal form (DNF)</li> </ul>"},{"location":"documentation/formulas/#useful-methods-for-formulas","title":"Useful Methods for Formulas","text":"<p>There are a couple of useful methods for working with formulas.</p>"},{"location":"documentation/formulas/#evaluating-formulas","title":"Evaluating Formulas","text":"<p>A formula can be evaluated with an assignment.  That is all variables in the formula will be set to the truth value given in the assignment.  If a variable is not contained in the assignment, it is set to false.  Consider the assignment <code>{~A, C}</code> for the formula <code>A &amp; B | C</code>.  We want to check whether the formula is satisfiable under this assignment. This can be done in the following way:</p> <pre><code>Assignment assignment = new Assignment();\nassignment.addLiteral(f.literal(\"A\", false));\nassignment.addLiteral(f.literal(\"C\", true));\nboolean result = formula.evaluate(assignment);\n</code></pre> <p>The result is <code>true</code>, since the right-hand side of the disjunction evaluates to true and therefore the whole disjunctions evaluates to true.</p> <p>Fast Evaluable Assignments</p> <p>An <code>Assignment</code> can be created with an optional boolean parameter <code>fastEvaluable</code> which is by default false.  This parameter decides how the assignment internally stores its literals.</p> <p>If set to <code>false</code>, the literals are stored in a list.  This allows for a faster generation of the assignment and slightly smaller memory footprint, but evaluation is slow since finding a literal in the internal data structure takes linear time. If set to <code>true</code>, the literals are storen in a set.  Thus the generation of the assignment takes a little bit longer and the footprint is slighlty larger but searching a literal in the map takes constant time.</p> <p>Often (e.g. in model enumeration) you don't use the generated assignment to evaluate or restrict formulas, so you don't neet fast evaluable assignments and can therefore save some time and memory creating them.  However, if you plan to use the assignments to evaluate or restrict formulas, always set the <code>fastEvaluable</code> flag to <code>true</code>.</p>"},{"location":"documentation/formulas/#restricting-formulas","title":"Restricting Formulas","text":"<p>A formula can be restricted with an assignment.  In contrast to an evaluation, variables not contained in the assignment are not set to false, but left untouched.  Therefore, the result of a restriction is usually not a simple truth value, but another formula.  Consider the assignment <code>{~A}</code> for the formula <code>A &amp; B | C</code>.  We want to restrict the formula with this assignment.  This can be done in the following way:</p> <pre><code>Assignment assignment = new Assignment();\nassignment.addLiteral(f.literal(\"A\", false));\nFormula result = formula.restrict(assignment);\n</code></pre> <p>The result is <code>C</code>, since the left-hand side of the disjunction restricts to false and therefore the right-hand side must be true.  Note that since the formula factory automatically removes constants from formulas, also restricted formulas never contain constants.</p>"},{"location":"documentation/formulas/#substituting-variables","title":"Substituting Variables","text":"<p>Variables in a formula can be substituted with other formulas. For example, within the formula <code>A &amp; B | C</code>, we want to substitute <code>A</code> by <code>D &amp; E</code> and <code>C</code> by <code>F</code>:</p> <pre><code>Substitution substitution = new Substitution();\nsubstitution.addMapping(f.variable(\"A\"), p.parse(\"D &amp; E\"));\nsubstitution.addMapping(f.variable(\"C\"), p.parse(\"F\"));\nFormula result = formula.substitute(substitution);\n</code></pre> <p>The result is <code>D &amp; E &amp; B | F</code>.</p>"},{"location":"documentation/formulas/#negation-normal-form","title":"Negation Normal Form","text":"<p>A formula is in negation normal form (NNF) if it consists only of literals and the operands <code>&amp;</code> and <code>|</code>. For example, the formula <code>A | ~(B | C)</code> is not in NNF but formula <code>A | (~B &amp; ~C)</code> is in NNF. The formulas <code>A &amp; B | C</code> and <code>A &amp; B | A &amp; C</code> are in NNF. A NNF of a formula can be computed with <code>formula.nnf()</code>.</p>"},{"location":"documentation/formulas/#satisfiability-of-formulas","title":"Satisfiability of Formulas","text":"<p> 2.4.0</p> <p>If you want to know, if a formula is a tautology (always true), a contradiction (always false) or satisfiable, there are convenience functions on formulas to directly compute these predicates:</p> <ul> <li><code>isSatisfiable()</code> is the formula satisfiable, i.e. is there at least one assignment which evaluates the formula to true.</li> <li><code>isTautology()</code> is the formula a tautology, i.e. it evaluates to true under all assignments</li> <li><code>isContradiction()</code> is the formula a contradiction, i.e. it evaluates to false under all assignments</li> </ul> <p>Furthermore there are three methods to check whether the formula has a relation with another formula:</p> <ul> <li><code>implies(Formula other)</code> whether the formula implies the formula <code>other</code> mathematically, meaning each assignment which fulfills the formula also fulfills the <code>other</code> formula, e.g. <code>A =&gt; (A/B)</code>.</li> <li><code>isImpliedBy(Formula other)</code> whether the formula is implied by the <code>other</code> formula.</li> <li><code>isEquivalent(Formula other)</code> whether the formula is mathematically equivalent to the <code>other</code> formula, meaning they evaluate to true under exactly the same assignments.</li> </ul>"},{"location":"documentation/formulas/#executing-operations-on-formulas-and-implementing-own-operations","title":"Executing Operations on Formulas and Implementing Own Operations","text":"<p>There are three generalized types of operations which can be executed on formulas:</p> <ol> <li>Functions:  A function takes a formula as input and computes some value on that formula.  This value can be a simple integer e.g. the depth of a formula, or a more complex result type, like the list of sub-formulas.  Functions are applied on a formula with the <code>.apply()</code> method.  Functions will be discussed in detail in the chapter Formula Functions.</li> <li>Predicates: A predicate takes a formula as input and computes a truth value on that formula, e.g. whether a formula is in a certain normal form like NNF, CNF, or DNF, or if it is satisfiable?  Predicates are evaluated on a formula with the <code>.holds()</code> method.  Predicates will be discussed in detail in the chapter Formula Predicates.</li> <li>Transformations: A transformation takes a formula as input and returns another formula, thus transforming the input formula.  Examples for transformations are normal form conversions like NNF, CNF, DNF, or formula simplification.  Transformations are executed on a formula with the <code>.transform()</code> method.  Transformations will be discussed in detail in chapter Formula Transformations.</li> </ol> <p>The result of those operations can be stored in the cache of a formula. If the result of an operation is cached, then, whenever the same operation is called again on this formula, the operation is not re-computed, but rather the preceding result is reused.  This of course only is possible because formulas are immutable.</p> <p>There are many functions, predicates, and transformation already implemented in LogicNG, but the user can also implement her own by implementing the respective interfaces.  The user can also define her own cache types and therefore decide if the results of her own operation should be cached or not.</p> <p>Here is an example of a custom formula function which computes how often variable \"a\" occurs in a formula which result is cached.  First we have to introduce a new cache object for our function:</p> <pre><code>class MyImportantFunctionCacheEntry implements CacheEntry {\n\n    @Override\n    public String description() {\n        return \"My very important function computing the number of a's\";\n    }\n}\n</code></pre> <p>Next we implement our function:</p> <pre><code>class MyImportantFunction implements FormulaFunction&lt;Integer&gt; {\n\n    private static final CacheEntry CACHE_ENTRY = new\n            MyImportantFunctionCacheEntry();\n\n    @Override\n    public Integer apply(Formula formula, boolean cache) {\n        Object cached = formula.functionCacheEntry(CACHE_ENTRY);\n        if (cached != null) {\n            return (Integer) cached;\n        }\n        Integer countA = formula\n                .apply(new VariableProfileFunction())\n                .getOrDefault(formula.factory().variable(\"a\"), 0);\n        if (cache) {\n            formula.setFunctionCacheEntry(CACHE_ENTRY, countA);\n        }\n        return countA;\n    }\n}\n</code></pre> <p>So first, we construct a new singleton for the cache entry for our new formula function.  In the <code>apply</code> method, we first check, if we already have a cached entry for our function - if so, we return otherwise, we compute the number of occurrences of the variable \"a\" in the formula (by means of the variable profile function, which will be discussed later) and cache the result, if the user wants to cache.  Then the result is returned.</p> <p>The function can then be used with or without caching:</p> <pre><code>Formula formula = p.parse(\"a &amp; (b | c) =&gt; ~a &amp; d | a &lt;=&gt; f\");\nInteger applyWithCache = formula.apply(new MyImportantFunction());\nInteger applyWithoutCache = formula.apply(new MyImportantFunction(), false);\n</code></pre> <p>By default, the <code>apply</code> function sets the <code>cache</code> parameter to <code>true</code>, so if you do not want to cache the result, you have to manually set the parameter to <code>false</code>.  In both cases, the result will be 3.</p>"},{"location":"documentation/formulas/#some-remarks-on-caching","title":"Some Remarks on Caching","text":"<p>Whether the result of an operation should be cached or not is always a trade-off between computation time and heap space.  Usually, it is beneficial to cache results, if their computation time is significant and there is a large likelihood that they are computed more than once during a use case.  This can also be the case, when a single computation on a large formula would benefit from cached results on sub-formulas of this large formula.</p> <p>While many LogicNG functions/predicates/transformations will by their nature cache the results not only for the computed formula, but also for all sub-formulas, this is not an absolute requirement and must not hold for all operations.  It is possible, that an operation caches the result only for the formula it was computed on, but not for sub-formulas of this formula.</p> <p>Cached Operations Should be Stateless and Path-Independent</p> <p>Note that functions, predicates, and transformations should be stateless, especially if you want to cache the result. For example, if you would add a field <code>String variableName</code> to <code>MyImportantFunction</code> which is initialized by a constructor parameter and which defines the variable name to be counted, caching would lead to incorrect results if you use different instances of <code>MyImportantFunction</code> with different variable names.  Also if an operation is path-dependent, meaning the result of operations depends on the path the operations take through the formula, the results must not be cached for sub formulas.</p>"},{"location":"documentation/formulas/cardinality-constraints/","title":"Cardinality Constraints","text":"<p>Cardinality constraints CardinalityConstraint are a special type of formulas which enforce that a certain number of variables is assigned to true.  They can be of type at least k, exactly k or at most k, for some integer <code>k</code>.  Each <code>CardinalityConstraint</code> is a subtype of <code>Formula</code> and offers the same methods as all other formulas.  For example, a cardinality constraint of type \"at most 1\" is:</p> <pre><code>A + B + C &lt;= 1\n</code></pre> <p>And expresses the fact that from the variables <code>A</code>, <code>B</code>, <code>C</code> at most one variable is assigned to true. Meaning the formula is satisfied by exactly 4 assignments</p> <ul> <li><code>A, ~B, ~C</code></li> <li><code>~A, B, ~C</code></li> <li><code>~A, ~B, C</code></li> <li><code>~A, ~B, ~C</code></li> </ul> <p>At-most-one (AMO) and exactly-one (EXO) constraints play a special role since they are very often used in real world problems.  For example if you think of a car configuration, a valid vehicle must have exactly one steering wheel and can have at most one trailer hitch.</p>"},{"location":"documentation/formulas/cardinality-constraints/#creating-cardinality-constraints","title":"Creating Cardinality Constraints","text":"<p>Cardinality constraints can be created using the relevant methods from the formula factory. The methods are:</p> <ul> <li><code>f.cc()</code> for creating a cardinality constraint of any type. The parameters are: Cardinality constraint type, integer for the right-hand side and relevant variables.  The possible types are equal <code>EQ</code>, greater than <code>GT</code>, greater than or equal <code>GE</code>, less than <code>LT</code>, or less than or equal <code>LE</code>.</li> <li><code>f.amo()</code> for creating a cardinality constraints of type \"at most one\". The parameters are the relevant variables.</li> <li><code>f.exo()</code> for creating a cardinality constraints of type \"exactly one\". The parameters are the relevant variables.</li> </ul> <p>The syntax is:</p> <pre><code>Variable a = f.variable(\"A\");\nVariable b = f.variable(\"B\");\nVariable c = f.variable(\"C\");\n\nFormula cc = f.cc(CType.GE, 2, Arrays.asList(a, b, c)); // (1)!\nFormula amo = f.amo(Arrays.asList(a, b, c)); // (2)!\nFormula exo = f.exo(Arrays.asList(a, b, c)); // (3)!\n</code></pre> <ol> <li>creates cardinality constraint: A + B + C &gt;= 2</li> <li>creates amo constraint: A + B + C &lt;= 1</li> <li>creates exo constraint: A + B + C = 1</li> </ol> <p>Of course an AMO constraint can be generated by <code>f.cc(CType.LE, 1, ...)</code> and an EXO constraint by <code>f.cc(CType.EQ, 1, ...)</code> but since they are so common, the formula factory has convenience methods for generating them.</p> <p>Simplification of Cardinality Constraint on the Formula Factory</p> <p>Note, that the formula factory methods for <code>amo</code>, <code>exo</code>, and <code>cc</code> return <code>Formula</code> objects and not a <code>CardinalityConstraint</code>.  This is due to the fact, that the formula factory simplifies trivial cases like <code>a &gt; 2</code> to <code>$false</code> or <code>a = 1</code> to <code>a</code>.  Therefore, the result can be a constant or a variable or another formula and does not have to be always a <code>CardinalityConstraint</code>.</p>"},{"location":"documentation/formulas/cardinality-constraints/#encoding-cardinality-constraints","title":"Encoding Cardinality Constraints","text":"<p>Some applications, such as SAT solvers, cannot deal with cardinality constraints in their \"natural form\" (the exception being LogicNG's MiniCard implementation which can handle some type of constraints) since a cardinality constraint is not a purely Boolean construct.  Thus, the cardinality constraints have to be encoded to CNF before added to the solver.  An encoded cardinality constraint does not contain any signs like <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code> and <code>=</code> anymore but is a proper Boolean formula in CNF.  There exist many algorithms for encoding cardinality constraints, depending on their type.</p> <p>LogicNG implements many of these algorithms as described below.  If you want to change the encoding of a cardinality constraint using any of these algorithms, you can do this via the cardinality constraint configuration CCConfig, see below.  If you don't specify an encoding, then the default encoder is used.  The default encoder for a certain cardinality constraint was chosen based on theoretical and practical observations.  Most of the encoder algorithms are taken from the MaxSAT solver Open-WBO.</p>"},{"location":"documentation/formulas/cardinality-constraints/#at-most-one-encoder","title":"At-most-one Encoder","text":"<p>Encoders of this type encode an at-most-one constraint, so ensure that at most one variable is assigned to <code>true</code>. The implemented algorithms are:</p> <ul> <li>Pure: This algorithm uses the 'naive' encoding with no introduction of new variables but quadratic size.  I.e. introducing pair-wise constraints that each variable set to true forces all other variables to false.  E.g. the constraint <code>A + B + C &lt;= 1</code> is translated to <code>(A =&gt; ~B) &amp; (A =&gt; ~C) &amp; (B =&gt; ~A) &amp; (B =&gt; ~C) &amp; (C =&gt; ~A) &amp; (C =&gt; ~B)</code> simplified to the CNF <code>(~A | ~B) &amp; (~A | ~C) &amp; (~B | ~C)</code></li> <li>Ladder: This algorithm uses the Ladder/Regular Encoding due to Gent &amp; Nightingale.</li> <li>Product: This algorithm uses the 2-Product Method due to Chen.</li> <li>Nested: This algorithm uses the nested encoding.</li> <li>Commander: This algorithm uses the Commander Encoding due to Klieber &amp; Kwon</li> <li>Binary: This algorithm uses the Binary Encoding due to Doggett, Frisch, Peugniez, and Nightingale.</li> <li>Bimander. Uses the Bimander Encoding due to H\u00f6lldobler and Nguyen. When choosing this algorithm, one can also describe the group size: Half, square-root, fixed.</li> </ul> <p>The question which encoding should be used for a specific case heavily depends on the specific use case at hand.  It depends on the number of variables in the constraint, the application of the constraint (should it be used on a SAT solver later, in a BDD or a DNNF?), and other considerations like number of newly introduced variables or number of clauses and clause size.  The default at-most-one encoder in LogicNG uses the pure encoding without introduction of new variables for up to 10 variables, otherwise it uses the product encoding.</p>"},{"location":"documentation/formulas/cardinality-constraints/#at-most-k-and-at-least-k-encoder","title":"At-most-k and At-least-k Encoder","text":"<p>Encoders of this type encode the generalized version of the AMO constraint: at-most and at-least k constraints.  So at most or at least 'rhs' variables can or must be assigned to <code>true</code>. The implemented algorithms are:</p> <ul> <li>Cardinality Network for at most k, Cardinality Network for at least k: This algorithm uses the Cardinality Network Encoding due to As\u00edn, Nieuwenhuis, Oliveras, and Rodr\u00edguez-Carbonell</li> <li>Totalizer for at most k, Totalizer for at least k: This algorithm uses the Totalizer Encoding due to Bailleux and Boufkhad</li> <li>Modulo Totalizer for at most k, Modulo Totalizer for at least k: This algorithm uses the Module Totalizer due to Ogawa, Liu, Hasegawa, Koshimura &amp; Fujita</li> </ul> <p>Currently, the modular totalizer is the default encoder for at-most-k and at-least-k constraints.</p> <p>That is, for</p> <pre><code>Formula amk = f.cc(CType.LE, 2, a, b, c); // A + B + C &lt;= 2\nFormula cnf = amk.cnf();\n</code></pre> <p>the result is</p> <pre><code>(~C | x1 | x4) &amp; (~x3 | x1 | x4) &amp; (~x3 | ~C | x4) &amp; (~x4 | x0) &amp; (~x2 | x0) &amp;\n(~x4 | ~x2) &amp; (~x4 | ~x2) &amp; (~B | x3 | x5) &amp; (~A | x3 | x5) &amp; (~A | ~B | x5) &amp;\n(~x5 | x2) &amp; (~x0 | ~x1)\n</code></pre> <p>and for</p> <pre><code>Formula alk = f.cc(CType.GE, 2, a, b, c); // A + B + C &gt;= 2\nFormula cnf = alk.cnf();\n</code></pre> <pre><code>(C | x1 | x4) &amp; (~x3 | x1 | x4) &amp; (~x3 | C | x4) &amp; (~x4 | x0) &amp; (~x2 | x0) &amp;\n(~x4 | ~x2) &amp; (B | x3 | x5) &amp; (A | x3 | x5) &amp; (A | B | x5) &amp; (~x5 | x2) &amp; (~x0)\n</code></pre> <p>Variable Naming</p> <p>Note that the real formulas' auxiliary variables are named <code>@RESERVED_CC_1</code> and so on.  For the sake of readability we replaced them with <code>x1</code> in this documentation. The formula factory ensures that the introduced auxiliary variables do not interfere with previously introduced auxiliary variables of other cardinality constraints.</p>"},{"location":"documentation/formulas/cardinality-constraints/#exactly-k-encoder","title":"Exactly-k Encoder","text":"<p>Encoders of this type encode the generalized version of the EXO constraint: exactly-k constraints.  So exactly 'rhs' variables must be assigned to <code>true</code>. The implemented algorithms are:</p> <ul> <li>Totalizer: Uses the Totalizer Encoding due to Bailleux and Boufkhad for translating the cardinality constraint into CNF</li> <li>Cardinality Network:  Uses the cardinality network encoding due to Cardinality Network Encoding due to As\u00edn, Nieuwenhuis, Oliveras, and Rodr\u00edguez-Carbonell</li> </ul> <p>Currently, the totalizer encoding is used as default encoder for exactly-k constraints.</p>"},{"location":"documentation/formulas/cardinality-constraints/#using-the-encoder","title":"Using the Encoder","text":"<p>There are two ways to encode a cardinality constraint</p> <ol> <li>You can encode a constraint manually using the CCEncoder and get a list of clauses of the CNF.</li> <li>You can call the <code>cnf()</code> method on a cardinality constraint and get the resulting CNF directly.</li> </ol> <p>Consider the cardinality constraint</p> <pre><code>A + B + C &lt;= 1\n</code></pre> <p>You can configure the <code>CCEncoder</code> with a <code>CCConfig</code> object.  In this case we explicitly choose the <code>LADDER</code> encoding to generate the CNF for this cardinality constraint.  When using the <code>CCEncoder</code> the result ist a list of formulas, each representing a single clause of the encoding's CNF.</p> <pre><code>CCConfig config =\n       CCConfig.builder().amoEncoding(CCConfig.AMO_ENCODER.LADDER).build();\nCardinalityConstraint f1 = (CardinalityConstraint) f.amo(Arrays.asList(a, b, c));\nList&lt;Formula&gt; encoding = new CCEncoder(f, config).encode(f1);\n</code></pre> <p>The result it then the list of clauses (again with replaces auxiliary variables for readability):</p> <pre><code>[(~A | x1), (~B | x2), (~x1 | x2), (~B | ~x1), (~C | ~x1)]\n</code></pre> <p>When calling the <code>cnf()</code> method on the constraint, the default encoding configured in the formula factory is used.  So when you change this default for AMO constraint to <code>LADDER</code> beforehand, the result of calling <code>cnf()</code> yield the same result:</p> <pre><code>CCConfig config =\n        CCConfig.builder().amoEncoding(CCConfig.AMO_ENCODER.LADDER).build();\nf.putConfiguration(config);\nCardinalityConstraint f1 = (CardinalityConstraint) f.amo(Arrays.asList(a, b, c));\nFormula encoding = f1.cnf();\n</code></pre> <p>The result is the CNF equivalent to the clauses list above:</p> <pre><code>(~A | x1) &amp; (~B | x2) &amp; (~x1 | x2) &amp; (~B | ~x1) &amp; (~C | ~x1)\n</code></pre> <p>Different Cardinality Constraint Encodings</p> <p>Note that it is not necessary that all cardinality constraints are encoded the same way.  It is totally fine to encode different cardinality constraint on the same formula factory with different algorithms.</p>"},{"location":"documentation/formulas/cardinality-constraints/#incremental-cardinality-constraints","title":"Incremental Cardinality Constraints","text":"<p>The Cardinality Constraint Encoder in LogicNG has a special mode of operation in combination with a SAT Solver.  Often, you do not care for the cardinality constraint encoding in CNF but want to work with the constraint itself.  So there is no need to generate the CNF encoding on the formula factory and pollute the factory with all the generated clauses.  In this case the encoding can be generated directly on the SAT solver using internal solver variable data structures and never actually generating the formulas on the formula factory.  This speeds up computation and saves heap space.  Also, there is special version of incremental cardinality constraints where you can tighten the bound of cardinality constraints without generating a new constraint.  This is especially useful for optimization problems.  We will look at this concept closer in the SAT solving chapter.</p>"},{"location":"documentation/formulas/pb-constraints/","title":"Pseudo-Boolean Constraints","text":"<p>A pseudo-Boolean constraint PBConstraint is a generalization of a Cardinality Constraint.  In a cardinality constraint, every variable has the same weight (i.e. 1); In a pseudo-Boolean constraint, each variable can have a different weight.  Further, pseudo-Boolean constraints admit negated variables (literals), whereas cardinality constraints only admit variables.</p> <p>Pseudo-Boolean constraints have the form</p> \\[ c_1 \\cdot lit_1 + c_2 \\cdot lit_2 + ... + c_n \\cdot lit_n \\quad \\mathtt{?} \\quad k \\] <p>where:</p> <ul> <li>\\(lit_i\\) are Boolean literals, evaluating to <code>true</code> and <code>false</code>, for \\(1 \\leq i \\leq n\\)</li> <li>\\(c_i\\) are integer coefficients, the \"weights\" of the literals, for \\(1 \\leq i \\leq n\\)</li> <li>\\(\\mathtt{?}\\) is a comparison operator <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code> or <code>=</code></li> </ul> <p>A solution of a PB-constraint is an assignment of variables which satisfies the constraint (c.f. the next section).</p> <p>Some examples for pseudo-Boolean constraints are:</p> <ul> <li>Clauses: <code>A | ~B | C</code> is equivalent to <code>A + ~B + C &gt;= 1</code>,</li> <li>Cardinality constraints: <code>A + B + C &gt;= 3</code>. Cardinality constraints are a special case of PB-constraints, where every coefficient is 1.</li> <li>General constraints: <code>A + 2*~B - 3*C = 2</code></li> </ul>"},{"location":"documentation/formulas/pb-constraints/#evaluating-pseudo-boolean-constraints","title":"Evaluating Pseudo-Boolean Constraints","text":"<p>If a literal in the pseudo-Boolean constraint evaluates to <code>true</code> for a given assignment, it is treated as <code>1</code>; if it evaluates to <code>false</code>, it is treated as <code>0</code>. When evaluating the pseudo-Boolean constraint, the left-hand side is evaluated first with standard rules of linear arithmetic and then compared to the right-hand side.</p> <p>As an example, consider the pseudo-Boolean constraint:</p> <pre><code>A + 2*~B + -3*C = 2\n</code></pre> <p>Consider the following assignments:</p> <ol> <li><code>{A = true, B = true, C = true}</code>. The left-hand side evaluates to <code>1 + 2*0 - 3*1 = -2</code>, thus this is not a model for the formula.</li> <li><code>{A = true, B = false, C = false}</code>. The left-hand side evaluates to <code>1 + 2*1 - 3*0 = 3</code>, thus this is not a model for the formula.</li> <li><code>{A = false, B = false, C = false}</code>. The left-hand side evaluates to <code>0 + 2*1 - 3*0 = 2</code>, thus this is a model for the formula.</li> </ol> <p>Negation vs. Minus</p> <p>Note that the negation of a literal is different to the minus in front of a coefficient, therefore e.g. <code>-2 * B</code> is not equal to <code>2 * ~B</code>: For the model <code>{B = true}</code>, <code>-2 * B = -2</code>, but <code>2 * ~B = 0</code>.</p>"},{"location":"documentation/formulas/pb-constraints/#encoding-pseudo-boolean-constraints","title":"Encoding Pseudo-Boolean Constraints","text":"<p>Some applications, such as SAT solvers, cannot deal with pseudo-Boolean constraints in their \"natural form\" since a pseudo-Boolean constraint is not a purely Boolean construct.  Thus, the constraints have to be encoded to CNF before added to the solver. An encoded pseudo-Boolean constraint does not contain any signs like <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code> and <code>=</code> or any coefficients anymore but is a proper Boolean formula in CNF.  There exist many algorithms for encoding pseudo-Boolean constraints, depending on their type.</p> <p>LogicNG implements some of these algorithms as described below.  If you want to change the encoding of a pseudo-Boolean constraint using any of these algorithms, you can do this via the pseudo-Boolean constraint configuration PBConfig, see below.  If you don't specify an encoding, then the default encoder is used.  The default encoder for a certain pseudo-Boolean constraint was chosen based on theoretical and practical observations.</p> <p>You can find a general overview over those algorithms here.</p> <ul> <li>PBAdderNetworks:  The adder networks encoding for pseudo-Boolean constraints to CNF.</li> <li>PBSWC: A sequential weight counter for the encoding of pseudo-Boolean constraints in CNF. You can find information about this here.</li> <li>PBBinaryMerge: This algorithm encodes for pseudo-Boolean constraints to CNF due to Manthey, Philipp, and Steinke. There are three parameters:</li> <li><code>binaryMergeUseGAC</code>: Sets whether general arc consistency should be used in the binary merge encoding. The default value is true.</li> <li><code>binaryMergeNoSupportForSingleBit</code>: Sets the support for single bits in the binary merge encoding. The default value is false</li> <li><code>binaryMergeUseWatchDog</code>: Sets whether the watchdog encoding should be used in the binary merge encoding. The default value is true.</li> </ul> <p>The default encoding is the sequential weight counter <code>PBSWC</code>.</p>"},{"location":"documentation/formulas/pb-constraints/#using-the-encoder","title":"Using the Encoder","text":"<p>There are two ways to encode a pseudo-Boolean constraint:</p> <ol> <li>You can encode a constraint manually using the PBEncoder and get a list of clauses of the CNF.</li> <li>You can call the <code>cnf()</code> method on a pseudo-Boolean constraint and get the resulting CNF directly.</li> </ol> <p>Consider the pseudo-Boolean constraint</p> <pre><code>A + 2*~B - 3*C = 2\n</code></pre> <p>which can be created in the following way:</p> <pre><code>List&lt;Literal&gt; lits =\n        Arrays.asList(f.variable(\"A\"), f.literal(\"B\", false), f.variable(\"C\"));\nList&lt;Integer&gt; coeffs = Arrays.asList(1, 2, -3);\nFormula f1 = f.pbc(CType.EQ, 2, lits, coeffs);\n</code></pre> <p>You can configure the <code>PBEncoder</code> with a PBConfig object. In this case we explicitly choose the <code>PBBinaryMerge</code> encoding with the parameter <code>binaryMergeUseWatchDog</code> set to false, to generate the CNF for this pseudo-Boolean constraint. When using the <code>PBEncoder</code> the result is a list of formulas, each representing a single clause of the encoding's CNF.</p> <pre><code>PBConfig config = PBConfig.builder()\n        .pbEncoding(PBConfig.PB_ENCODER.BINARY_MERGE)\n        .binaryMergeUseGAC(false)\n        .build();\nList&lt;Formula&gt; encoding = new PBEncoder(f, config).encode((PBConstraint) f1);\n</code></pre> <p>The result is then the list of clauses (again with replaces auxiliary variables for readability):</p> <pre><code>[\n (x1), (~A | C | x5), (C | x4) (~A | x4), (B | C | x9), (C | x8), (B | x8),\n (~x8 | ~x5 | x11), (~x9 | ~x5 | x12), (~x5 | x10), (~x8 | x10), (~x9 | x11),\n ~x12, ~B, ~C\n]\n</code></pre> <p>When calling the <code>cnf()</code> method on the constraint, the default encoding configured in the formula factory is used. So when you change this default for pseudo-Boolean constraints to <code>PBBinaryMerge</code> with parameter <code>binaryMergeUseWatchDog</code> set to false beforehand, the result of calling <code>cnf()</code> yield the same result:</p> <pre><code>PBConfig config = PBConfig.builder()\n        .pbEncoding(PBConfig.PB_ENCODER.BINARY_MERGE)\n        .binaryMergeUseGAC(false).build();\nf.putConfiguration(config);\nFormula encoding = f1.cnf();\n</code></pre> <p>The result is the CNF equivalent to the clauses list above:</p> <pre><code>(x1) &amp; (~A | C | x5) &amp; (C | x4) &amp; (~A | x4) &amp; (B | C | x9) &amp; (C | x8) &amp;\n(B | x8) &amp; (~x8 | ~x5 | x11) &amp; (~x9 | ~x5 | x12) &amp; (~x5 | x10) &amp;\n(~x8 | x10) &amp; (~x9 | x11) &amp; ~x12 &amp; ~B &amp; ~C\n</code></pre>"},{"location":"documentation/formulas/operations/","title":"Formula Operations","text":"<p>As mentioned in the Formulas chapter, there are three different kinds of operations on formulas which we will explain in detail in the following three chapter:</p> <ol> <li>Functions:  A function takes a formula as input and computes some value on that formula.  This value can be a simple integer e.g. the depth of a formula, or a more complex result type, like the list of sub-formulas.  Functions are applied on a formula with the <code>.apply()</code> method.</li> <li>Predicates: A predicate takes a formula as input and computes a truth value on that formula, e.g. whether a formula is in a certain normal form like NNF, CNF, or DNF, or if it is satisfiable?  Predicates are evaluated on a formula with the <code>.holds()</code> method.</li> <li>Transformations: A transformation takes a formula as input and returns another formula, thus transforming the input formula.  Examples for transformations are normal form conversions like NNF, CNF, DNF, or formula simplification.  Transformations are executed on a formula with the <code>.transform()</code> method.</li> </ol>"},{"location":"documentation/formulas/operations/formula-functions/","title":"Formula Functions","text":"<p>A formula function takes a formula as input and computes some value on that formula. The result of the computation can be saved in the formulas cache.  There are some functions implemented in LogicNG or the user can implement her own functions, as shown in the basic chapter on Formulas.</p> <p>Formula functions can be executed on formulas with the <code>.apply()</code> method.  In the following example the LiteralProfileFunction is executed on the formula <code>f1</code> with activated caching:</p> <pre><code>Map&lt;Literal, Integer&gt; result = f1.apply(new LiteralProfileFunction());\n</code></pre> <p>or, if one wants to control the cache-strategy manually:</p> <pre><code>Map&lt;Literal, Integer&gt; result = f1.apply(new LiteralProfileFunction(), false);\n</code></pre> <p>The last parameter of the <code>apply</code> method indicates whether the result of the function should be cached in the formula. If you have an expensive computation which is likely to be executed more than once on formulas, it is a good idea to cache the result.</p> <p>In LogicNG there are some useful helper functions.</p>"},{"location":"documentation/formulas/operations/formula-functions/#compute-the-variables-and-literals-of-a-formula","title":"Compute the Variables and Literals of a Formula","text":"<p>The VariablesFunction and LiteralsFunction compute all variables, respectively literals, occurring in a given formula and returns them in a sorted set.  Since these functions are used very frequently, there are two shortcuts implemented directly on the <code>Formula</code> class: <code>.variables()</code> and <code>.literals</code>.</p> <p>The sorting order for variables is the default Java sorting order on the variable's name as <code>String</code>.  The sorting order on literals is by name first and positive literals before negative literals.</p> <p>Here is a small example for the usage of the functions:</p> <pre><code>Formula f1 = p.parse(\"A &amp; ~B =&gt; A | B | C\");\n\n// computes the set [A, B, C]\nSortedSet&lt;Variable&gt; variables1 = f1.variables();\nSortedSet&lt;Variable&gt; variables2 = f1.apply(VariablesFunction.get());\n\n// computes the set [A, B, ~B, C]\nSortedSet&lt;Literal&gt; literals1 = f1.literals();\nSortedSet&lt;Literal&gt; literals2 = f1.apply(LiteralsFunction.get());\n</code></pre>"},{"location":"documentation/formulas/operations/formula-functions/#compute-the-number-of-occurrences-of-variables-and-literals-in-formulas","title":"Compute the Number of Occurrences of Variables and Literals in Formulas","text":"<p>The VariableProfileFunction and LiteralProfileFunction count the number of occurrences for each variable (respectively, literal) and return it in a map.  The map contains the variable or literal as key and the number of occurrences as value.  E.g.</p> <pre><code>Formula f1 = p.parse(\"A &amp; ~B =&gt; A | B | C &amp; (A =&gt; (B | C))\");\n\n// computes the map {A=3, C=2, B=3}\nMap&lt;Variable, Integer&gt; variableMap = f1.apply(new VariableProfileFunction());\n\n// computes the map {A=3, C=2, ~B=1, B=2}\nMap&lt;Literal, Integer&gt; literalMap = f1.apply(new LiteralProfileFunction());\n</code></pre>"},{"location":"documentation/formulas/operations/formula-functions/#compute-the-number-of-nodes-and-atoms-of-a-formula","title":"Compute the Number of Nodes and Atoms of a Formula","text":"<p>The NumberOfAtomsFunction and NumberOfNodesFunction compute the number of atoms, respectively nodes of a formula.  An atom is a Boolean constant or variable.  Again, there are shortcuts in the <code>Formula</code> class <code>.numberOfAtoms()</code> and <code>.numberOfNodes()</code>, respectively. Also see the number of atoms and the number of nodes in the chapter on formulas.</p> <p>Let's consider</p> <pre><code>Formula f1 = p.parse(\"A &amp; B &amp; (A | B) &lt;=&gt; C &amp; (A | B)\");\n</code></pre> <p>Using <code>f1.numberOfAtoms()</code> we find that the number of atoms is 7, as the atoms are</p> <ul> <li><code>A</code> (3x)</li> <li><code>B</code> (3x)</li> <li><code>C</code></li> </ul> <p>Using <code>f1.numberOfNodes()</code> we find that the number of nodes is 12. A detailed example can be found in the relevant section in the chapter on formulas.</p>"},{"location":"documentation/formulas/operations/formula-functions/#compute-the-depth-of-a-formulas-ast","title":"Compute the Depth of a Formula's AST","text":"<p>The FormulaDepthFunction returns the depth of a function's abstract syntax tree. The depth of a function indicates how many levels of nested sub-formulas a formula has. For example,</p> <ul> <li><code>A</code> has depth zero,</li> <li><code>A &amp; B</code> has depth one,</li> <li><code>(A &amp; B) | C</code> has depth two, and</li> <li><code>(A &amp; B) | C &amp; (E | F)</code> has depth three.</li> </ul> <p>Intuitively speaking, if you think of the tree of <code>f1</code> in the preceding chapter, the formula depth is the maximal depth of the formula's abstract syntax tree.</p>"},{"location":"documentation/formulas/operations/formula-functions/#compute-all-sub-formulas-of-a-formula","title":"Compute all Sub-Formulas of a Formula","text":"<p>The SubNodeFunction computes the set of all sub-formulas of a given formula.  For example, applied on the function <code>A &amp; B | C</code> the sub-formulas are</p> <ul> <li><code>A</code></li> <li><code>B</code></li> <li><code>C</code></li> <li><code>A &amp; B</code></li> <li><code>A &amp; B | C</code></li> </ul> <p>Since the result is a set of sub-formulas each sub-formula occurs only once in the result. The sub-formula function is implemented in such a way, that the order of the sub-formulas in the result is bottom-up, i.e. a sub-formula only appears in the result when all of its sub-formulas are already listed.  The formula itself is always the last element in the result.</p> <pre><code>Formula f1 = p.parse(\"A &amp; ~B =&gt; A | B | C\");\n\n// Computes the sub-formulas\n// A\n// ~B\n// A &amp; ~B\n// B\n// C\n// A | B | C\n// A &amp; ~B =&gt; A | B | C]\nLinkedHashSet&lt;Formula&gt; subFormulas = f1.apply(new SubNodeFunction());\n</code></pre>"},{"location":"documentation/formulas/operations/formula-functions/#compute-the-minimum-prime-implicant-of-a-formula","title":"Compute the Minimum Prime Implicant of a Formula","text":"<p>The MinimumPrimeImplicantFunction computes a minimum-size prime implicant for a given formula.  In order to understand what a minimum-size prime implicant is, let's understand what an implicant of a formula is first.</p> <p>Consider the formula <code>f1 = A &amp; B | B &amp; C | D</code>. An implicant <code>f2</code> of <code>f1</code> is any min-term \u2013 a conjunction of literals \u2013 such that <code>f2</code> logically implies <code>f1</code>.</p> <p>Some example implicants of <code>f1</code> are:</p> <ul> <li><code>A &amp; B</code></li> <li><code>A &amp; B &amp; C</code></li> <li><code>B &amp; C &amp; D</code></li> <li><code>B &amp; C</code></li> <li><code>D</code></li> </ul> <p>A prime implicant is an implicant which cannot be further reduced (i.e. literals being removed) such that the reduced term yields an implicant. In this example that is:</p> <ul> <li>The implicants <code>A &amp; B</code>, <code>B &amp; C</code> and <code>D</code> cannot be reduced without violating the implicant property: Thus, they are prime implicants</li> <li>However, implicant <code>A &amp; B &amp; C</code> can be reduced: Removing <code>C</code> yields <code>A &amp; B</code>, which is still an implicant. The same holds for <code>B &amp; C &amp; D</code>. These are not prime implicants</li> </ul> <p>Prime Implicants</p> <p>Note that a formula can have prime implicants of different sizes.  A prime implicant is not globally minimal in the number of literals.</p> <p>Another way to think about prime implicants is that a prime implicant is an implicant for which none of its proper subsets is itself an implicant. For more information about (prime) implicants check out Wikipedia.</p> <p>A minimum-size prime implicant is a prime implicant with minimum size, in terms of the number of literals, among all prime implicants of a formula.  The <code>MinimumPrimeImplicantFunction</code> computes a prime implicant with minimum size.  A minimum-size prime implicant in our example is <code>D</code>.  Beware, in general there are more than one minimum-size prime implicants.  In this case, the formula returns the one found first.</p> <p>Prime implicants of a formula play a key role in the Quine-McCluskey algorithm, which is implemented in two different ways in LogicNG.</p> <p>An example for applying the function is:</p> <pre><code>Formula f1 = p.parse(\"(A | B) &amp; (A | C ) &amp; (C | D) &amp; (B | ~D)\");\n\n// Computes [B, C]\nSortedSet&lt;Literal&gt; minimumPrimeImplicant =\n        f1.apply(MinimumPrimeImplicantFunction.get());\n</code></pre>"},{"location":"documentation/formulas/operations/formula-predicates/","title":"Pseudo-Boolean Constraints","text":"<p>A formula predicate takes a formula as input and computes a truth value on that formula, e.g. whether a formula is in a certain normal form like NNF, CNF, or DNF or if it is satisfiable.</p> <p>It can be evaluated whether a formula predicate holds (evaulates to true) for a formula <code>f1</code> with the <code>.holds()</code> method:</p> <pre><code>boolean isCNF = f1.holds(CNFPredicate.get());\n</code></pre> <p>In this case the result of the predicate is cached in the formula.  If you do not want to cache the result, you can manually deactivate caching:</p> <pre><code>boolean isCNF = f1.holds(CNFPredicate.get(), false);\n</code></pre> <p>Most predicates implemented in LogicNG fall into one of two categories: (1) predicates which check if a given formula has a certain form, e.g. NNF, CNF, ..., and (2) predicates which check certain properties of a formula, e.g. if it is satisfiable.  One can also think of these to types of (1) checking syntactical properties, and (2) checking semantical properties of a formula.</p>"},{"location":"documentation/formulas/operations/formula-predicates/#syntactical-predicates","title":"Syntactical Predicates","text":"<p>The first type is those predicates, which check whether the formula is of a certain syntactical form.  There are three predicates in LogicNG for common normal forms:</p> <ul> <li>negation normal form (NNF) - only conjunctions and disjunctions, and negations only occur before variables: NNFPredicate</li> <li>conjunctive normal form (CNF) - a conjunction of disjunctions of literals: CNFPredicate</li> <li>disjunctive normal form (DNF) - a disjunction of conjunctions of literals: DNFPredicate</li> </ul> <p>Each CNF and DNF is also in NNF.  CNF play a very important role in LogicNG, since they are used as input format for SAT solvers.</p> <p>Further, one can check whether the given formula is an \"And-inverter graph\" (AIG) with the AIGPredicate.</p> <p>Excursion: And-Inverter Graphs</p> <p>An And-inverter graph is an efficient representation of a formula. AIGs have recently gained increasing interest because of its coupling opportunities with efficient SAT solvers.  The conversion from Boolean formulas to an AIG is fast and scalable. It only requires that every gate can be expressed in terms of ANDs and NOTs. This makes them, in comparison with BDD and DNF, an efficient representation.  More information about And-inverter graphs (AIG) can be found here.</p> <p>An example for checking these properties on a formula can be seen in the following code snippet:</p> <pre><code>Formula f1 = p.parse(\"(A | B) &amp; (A | C ) &amp; (C | D) &amp; (B | ~D)\");\n\nboolean isAIG = f1.holds(AIGPredicate.get()); // false\nboolean isNNF = f1.holds(NNFPredicate.get()); // true\nboolean isCNF = f1.holds(CNFPredicate.get()); // true\nboolean isDNF = f1.holds(DNFPredicate.get()); // false\n</code></pre> <p> 2.3.0 For NNF/CNF/DNF there are three helper methods directly on the formula which execute the predicates as in the example above: <code>isNnf()</code>, <code>isCnf()</code>, <code>isDnf()</code>.</p>"},{"location":"documentation/formulas/operations/formula-predicates/#semantic-predicates","title":"Semantic Predicates","text":"<p>The second type of predicates checks whether formulas satisfy certain semantical properties related to their satisfiability:</p> <pre><code>graph TD\n  A[Satisfiable?] --&gt;|Yes| B([SATPredicate holds]);\n  A --&gt;|No| C([ContradictionPredicate holds]);\n  B --&gt; D[Tautology?];\n  D --&gt;|Yes| E([TautologyPredicate holds]);\n  D --&gt;|No| F([ContingencyPredicate holds]);</code></pre> <p>Let's have a closer look to each of these predicates:</p>"},{"location":"documentation/formulas/operations/formula-predicates/#sat-predicate","title":"SAT Predicate","text":"<p>The SATPredicate tests whether a formula is satisfiable. A formula is satisfiable if there exists at least one assignment such that the formula evaluates to <code>true</code> with this assignment. Such an assignment is called satisfying assignment or model. For example <code>A &amp; B | C</code> is satisfiable for the assignment <code>{A, B, ~C}</code>. In order to check for satisfiability, the <code>SATPredicate</code> internally calls a SAT Solver.</p> <pre><code>Formula f1 = p.parse(\"A &amp; B | C\");\n\nboolean isSatisfiable = f1.holds(new SATPredicate(f)); // true\n</code></pre>"},{"location":"documentation/formulas/operations/formula-predicates/#contradiction-predicate","title":"Contradiction Predicate","text":"<p>In contrast to the <code>SATPredicate</code> the ContradictionPredicate can be used to test if a formula is unsatisfiable, i.e. the formula is a contradiction. That is, this predicate holds if and only if the <code>SATPredicate</code> does not hold and vice versa. An example for a contradiction is <code>A &amp; (A =&gt; B) &amp; (B =&gt; ~A)</code>.</p> <pre><code>Formula f1 = p.parse(\"A &amp; (A =&gt; B) &amp; (B =&gt; ~A)\");\n\nboolean isSatisfiable = f1.holds(new SATPredicate(f)); // false\nboolean isContradiction = f1.holds(new ContradictionPredicate(f)); // true\n</code></pre>"},{"location":"documentation/formulas/operations/formula-predicates/#tautology-predicate","title":"Tautology Predicate","text":"<p>The TautologyPredicate indicates whether a given formula is a tautology, that is, always holds, regardless of the assignment.  An example for an tautology is <code>(A &amp; B) | (~A &amp; B) | (A &amp; ~B) | (~A &amp; ~B)</code>.</p> <pre><code>Formula f1 = p.parse(\"(A &amp; B) | (~A &amp; B) | (A &amp; ~B) | (~A &amp; ~B)\");\n\nboolean isSatisfiable = f1.holds(new SATPredicate(f)); // true\nboolean isContradiction = f1.holds(new ContradictionPredicate(f)); // false\nboolean isTautology = f1.holds(new TautologyPredicate(f)); // true\n</code></pre> <p>A very useful usage of the tautology predicate is to check whether two formulas are semantically equivalent.  To do this, create an equivalence consisting of the two formulas to check.  Then check whether this equivalence is a tautology:</p> <pre><code>Formula f1 = p.parse(\"(A | B) &amp; (A | C ) &amp; (C | D) &amp; (B | ~D)\");\nFormula f2 = p.parse(\"D &amp; A &amp; B | ~D &amp; C &amp; A | C &amp; B\");\n\nFormula equivalence = f.equivalence(f1, f2);\nboolean formulasAreEquivalent =\n    equivalence.holds(new TautologyPredicate(f)); // true\n</code></pre> <p>Also, testing if one formula is a logical implication of another formula can be tested the same way by creating an implication <code>f.implication(f1, f2)</code> instead.</p>"},{"location":"documentation/formulas/operations/formula-predicates/#contingency-predicate","title":"Contingency Predicate","text":"<p>If a formula is satisfiable, but not a tautology, then the ContingencyPredicate holds. In other words, the formula is satisfiable and falsifiable. For example, for the formula <code>A &amp; B | C</code> the contingency predicate holds: The formula is satisfiable (e.g. a model is <code>{A, B, C}</code>) and the formula is falsifiable (e.g. a falsifying assignment is <code>{~A, ~B, ~C}</code>).</p> <pre><code>Formula f1 = p.parse(\"A &amp; B | C\");\n\nboolean isSatisfiable = f1.holds(new SATPredicate(f)); // true\nboolean isContradiction = f1.holds(new ContradictionPredicate(f)); // false\nboolean isTautology = f1.holds(new TautologyPredicate(f)); // false\nboolean isContingency = f1.holds(new ContingencyPredicate(f)); // true\n</code></pre>"},{"location":"documentation/formulas/operations/formula-predicates/#fast-evaluation-of-partial-assignments","title":"Fast Evaluation of Partial Assignments","text":"<p>A special predicate is the EvaluatesToConstantPredicate.  It was created for a very special use case in an application developed by us.  Usually the standard formula evaluation is very fast - but the evaluation requires either a complete assignment of all the formula's variables or it automatically assigns all variables not in the assignment to false.</p> <p>So if one wants to know, if a formula evaluates to true or false under a partial assignment, one has to use the formula restriction and check whether the resulting formula is the constant true or false.  But if all one is interested in is whether the formula restricts to true or false (and does not care for the restricted formula otherwise) this approach is not as fast as it could be because it generates restricted formulas on its way.</p> <p>Application Insight</p> <p>In one of our applications we had to check hundreds of thousands of formulas against the same assignments over and over again.  Therefore we wrote this special predicate, which only checks if a formula evaluates to true or false under a potentially partial assignment.  Usually you will not need such a specialized function, but in case you do - there it is </p> <pre><code>Formula f1 = p.parse(\"A &amp; B | C &amp; ~D\");\nFormula f2 = p.parse(\"A &amp; ~B | C &amp; ~D\");\n\nMap&lt;Variable, Boolean&gt; assignment = new HashMap&lt;&gt;();\nassignment.put(f.variable(\"A\"), true);\nassignment.put(f.variable(\"B\"), false);\n\nEvaluatesToConstantPredicate evaluatesToConstantPredicate =\n        new EvaluatesToConstantPredicate(true, assignment);\n\nboolean holdsForF1 = f1.holds(evaluatesToConstantPredicate); // false\nboolean holdsForF2 = f2.holds(evaluatesToConstantPredicate); // true\n</code></pre> <p>You can see that this predicate is generated for one specific assignment given as a mapping from variable to truth value.  The first parameter in the predicate indicates for which evaluation result you want to check.  In this we want to now if a formula evaluates to true under the given assignment.</p>"},{"location":"documentation/formulas/operations/transformations/","title":"Formula Transformations","text":"<p>A formula transformation takes a formula as input and returns another formula. A formula transformation is a special case of a Formula Function but always returns a formula. We distinguish the following kinds of formula transformations:</p> <ul> <li>Normal Form Transformations, e.g. conjunctive normal form (CNF) or disjunction normal form (DNF)</li> <li>Simplifier Transformations, which try to minimize or simplify the formula</li> <li>Other Transformations for other useful transformations such as anonymizing a formula</li> </ul> <p>Analogously to the formula functions and the formula predicates, formula transformations can be executed on formulas with the <code>.transform()</code> method. In the following example the <code>DistributiveSimplifier</code> is executed on the formula <code>f1</code> with activated caching:</p> <pre><code>Formula result = f1.transform(new DistributiveSimplifier());\n</code></pre> <p>Caching can also be deactivated by calling the overloaded method with flag <code>false</code>:</p> <pre><code>Formula result = f1.transform(new DistributiveSimplifier(), false);\n</code></pre> <p>The last parameter of the <code>.transfom()</code> method indicates whether the result of the transformation should be cached in the formula. If you have an expensive computation which is likely to be executed more than once on formulas, it is a good idea to cache the result.</p> <p>The result of any transformation in this chapter is another formula. Depending on the transformation the resulting formula will be equisatisfiable, equivalent or neither of both compared to the input formula.</p> <p>Equivalence vs Equisatisfiability</p> <p>Two formulas <code>f1</code> and <code>f2</code> are (logically) equivalent if both formulas evaluate to the same truth value for all assignments. With <code>eval(f1, a)</code> we denote the truth value of the formula <code>f1</code> when evaluated under assignment <code>a</code>. Formulas <code>f1</code> and <code>f2</code> are equivalent, if for every assignment <code>a</code> holds:</p> <pre><code>eval(f1, a) = eval(f2, a)\n</code></pre> <p>In contrast, two formulas <code>f1</code> and <code>f2</code> are equisatisfiable if either both are satisfiable or both are unsatisfiable, i.e. if the following holds:</p> <pre><code>(f1 is satisfiable) &lt;=&gt; (f2 is satisfiable)\n</code></pre> <p>Note that equisatisfiability is implied by equivalence but not the other way round.</p> <pre><code>(f1 and f2 are equivalent) =&gt; (f1 and f2 are equisatisfiable)\n</code></pre> <p>Consider the example:</p> <pre><code>Formula f1 = p.parse(\"A | B\");\nFormula f2 = p.parse(\"A | C) &amp; (B | ~C\");\n</code></pre> <p>The formulas are both satisfiable, i.e. they are equisatisfiable. But they are not equivalent. For example, the assignment <code>a = {~A, B, ~C}</code> yields <code>eval(f1, a) = true</code>, but <code>eval(f2, a) = false</code>.</p> <p>For more information check out Equisatisfiability in Wikipedia.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/","title":"Normal Form Transformations","text":"<p>The two most important normal forms are the Conjunctive Normal Form (CNF) and the Disjunctive Normal Form (DNF).  In particular, the CNF is of special importance, since it is the input form required for SAT Solving and many other operations or algorithms.  There are many ways to obtain a CNF or DNF from a formula.  We will describe the methods LogicNG offers in this chapter.</p> <p>Another important normal form is the Negation Normal Form (NNF) where only the operators <code>~</code>, <code>&amp;</code>, and <code>|</code> are allowed and negations must only appear before variables.  In LogicNG this means that the formula consists only of literals Ands, and Ors.  The NNF is often used as pre-processing step before transforming the formula into another normal form.  Also, some algorithms require a formula to be in NNF to work.</p> <p>For theoretical insights on this section, particularly the Tseitin and Plaisted-Greenbaum transformation, check out chapter 2.1. in this dissertation.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#nnf-transformation","title":"NNF Transformation","text":"<p>The NNF of a formula can be obtained by executing the NNFTransformation on it.  There is also a shortcut method directly on the <code>Formula</code> class: <code>.nnf()</code>.</p> <pre><code>Formula f1 = p.parse(\"A | ~(B &amp; C)\");\nFormula nnf = f1.nnf(); // yields A | ~B | ~C\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#cnf-transformations","title":"CNF Transformations","text":"<p>As mentioned in the introduction, the CNF is of special interest since SAT solvers require this normal form as input (c.f. SAT Solving).  A CNF is a conjunction of disjunctions of literals.  The disjunction of literals is called a \"clause\".  So the formula</p> <pre><code>(a | b | ~c) &amp; (~a | c) &amp; (d | f) &amp; (e | ~c)\n</code></pre> <p>is a CNF with four clauses, the first contains three literals, the other two literals.</p> <p>The naive approach for transforming a formula into CNF is to use equivalence transformations such as DeMorgan's Law and the distributive law. This approach is also called \"Factorization\" of the CNF.  However, the application of the distributivity law can lead to an exponential increase of the formula's size.  For example, consider the DNF <code>X_11 &amp; X_12 | .... | X_n1 &amp; X_n2</code> which contains <code>2*n</code> variables.  Transforming this with the distributive law to a CNF results into <code>2^n</code> clauses with <code>n</code> variables each.  Fortunately, there are more efficient ways to transform formulas to CNF.</p> <p>CNF transformations can be categorized into equivalent transformations and equisatisfiable transformations (c.f. here).  Equivalent transformation do not introduce auxiliary variables.  LogicNG offers the following equivalent CNF transformations:</p> <ul> <li>CNF Factorization using the DeMorgan's Laws and the distributive laws: CNFFactorization</li> <li>CNF Transformation using a BDD of the formula and extracting the paths leading to <code>false</code>: BDDCNFTransformation</li> </ul> <p>In contrast to the equivalent transformations, equisatisfiable CNF transformations introduce auxiliary variables.  The core idea is to introduce a new auxiliary variable for each sub-formula of the formula's parse tree.  By doing so, the exponential blow up of the size of the resulting formula can be avoided.  LogicNG offers the two most prominent equisatisfiable CNF transformations:</p> <ul> <li>Tseitin Transformation TseitinTranformation</li> <li>Plaisted-Greenbaum Transformation PlaistedGreenbaumTransformation</li> </ul> <p>For the CNF transformations in this section, consider the formula <code>f1</code>:</p> <pre><code>Formula f1 = p.parse(\"A | ~(B &amp; C)\");\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#cnf-factorization","title":"CNF Factorization","text":"<p>The CNF factorization CNFFactorization is the naive approach to obtain a CNF from a given formula.  Since the CNF factorization easily blows up, it should only be used for small formulas.</p> <p>In order to have control over the computation, one can use the CNF factorization with a FactorizationHandler.  With such a handler one can specify when the computation shall be aborted. During the CNF factorization, the handler receives the following information:</p> <ul> <li>That the computation was <code>started()</code> (here you can for example do some initialization work)</li> <li>That a distribution was performed (<code>performedDistribution()</code>). You can ignore this information or, as in the example below, increase a counter and you have to return a boolean indicating whether the computation should succeed or not (thus be aborted).</li> <li>That a new clause was created in the result.  Similarly to <code>performedDistribution()</code> you can store some information and you have to return a boolean to succeed or abort the computation.</li> </ul> <p>If <code>performedDistribution()</code> or <code>createdClause()</code> return <code>false</code>, the computation is aborted and will return <code>null</code>.  There is also the method <code>aborted()</code> with which you can ask the handler whether the computation was aborted or not. In the following example this method is also used internally to define the abortion criterion.</p> <p>As an example, one can implement a factorization handler which aborts the computation as soon as either 4 distributions were performed or 3 clauses were created:</p> <pre><code>FactorizationHandler handler = new FactorizationHandler() {\n   private int dists = 0;\n   private int clauses = 0;\n\n   @Override\n   public void started() {\n       this.dists = 0;\n       this.clauses = 0;\n   }\n\n   @Override\n   public boolean performedDistribution() {\n       this.dists++;\n       return !aborted();\n   }\n\n   @Override\n   public boolean createdClause(Formula clause) {\n       this.clauses++; // (1)!\n       return !aborted();\n   }\n\n   @Override\n   public boolean aborted() {\n       return this.dists &gt;= 4 || this.clauses &gt;= 3; // (2)!\n   }\n};\nCNFFactorization factorization = new CNFFactorization(handler);\nFormula result = factorization.apply(f1, true);\n</code></pre> <ol> <li>You can also store more complex information based on the clause, if you wish</li> <li>Define any abortion constraint here which you think is suitable for you application</li> </ol> <p>The result is <code>(~B | A) &amp; (~C | A)</code>.</p> <p>Impact of Handlers</p> <p>Note that with this handler, the variation <code>f2 = A | ~(B | C | D)</code> could not be factorized. The factorization we expect from this formula is <code>(~B | A) &amp; (~C | A) &amp; (~D | A)</code>, but this has 3 clauses and performs 4 distributions and thus exceeds both distribution and created clause boundary. A handler with distribution boundary 4 and created clause boundary 3 would solve it.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#bdd-cnf-transformation","title":"BDD CNF Transformation","text":"<p>The BDDCNFTransformation transforms a formula to a CNF by converting it to a Binary Decision Diagram (BDD) first.  The conversion of a BDD to a CNF is fast.  However, the generated BDD may have an exponential size compared to the input formula.  We recommend using this transformation if you're interested in a CNF without auxiliary variables and your formula is too big for the <code>CNFFactorization</code>.  For more information on BDDs check out the chapter on knowledge compilation and the chapter on BDDs.</p> <p>The transformation has three constructors:</p> <ol> <li>The simplest constructor has no parameters:</li> </ol> <pre><code>BDDCNFTransformation transformation = new BDDCNFTransformation();\n</code></pre> <ol> <li>There is a constructor with a BDD kernel (for details check out the BDD chapter mentioned above):    For example, for some formula <code>f1</code>, that is:</li> </ol> <pre><code>BDDKernel bddKernel = new BDDKernel(f1.factory(), f1.variables().size(), 10, 15);\nBDDCNFTransformation transformation = new BDDCNFTransformation(bddKernel);\n</code></pre> <ol> <li>There is a constructor with a formula factory and a number of variables:</li> </ol> <pre><code>BDDCNFTransformation transformation = new BDDCNFTransformation(f, 15);\n</code></pre> <p>Consider the formula</p> <pre><code>Formula f1 = p.parse(\"(x1 &lt;=&gt; x2) | x3\");\n</code></pre> <p>When <code>transformation</code> is being created in one of the ways above, and we call</p> <pre><code>Formula result = f1.transform(transformation);\n</code></pre> <p>then we find that the result of the transformation is <code>(x1 | ~x2 | x3) &amp; (~x1 | x2 | x3)</code>.</p> <p>When creating the transformation as in case 2. and 3., keep the following in mind: You can create arbitrarily many transformations with the object. However, the number of different variables in all applied formulas must not exceed the number of variables in the kernel (in the example that is <code>15</code>), respectively the number of variables (in the example that is <code>f1.variables().size()</code>).</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#tseitin-transformation","title":"Tseitin Transformation","text":"<p>The Tseitin Transformation TseitinTransformation works on the NNF of a given formula. Each sub-formula of the formula's parse tree is replaced by a new auxiliary variable and an equivalence between the new variable and the sub-formula is added. Equal sub-formulas are replaced by the same auxiliary variable for efficiency.</p> <p>Let's start with the NNF of <code>f1</code>:</p> <pre><code>f1.nnf() = A | ~B &amp; ~C\n</code></pre> <p>For this NNF the equivalences are:</p> <ul> <li><code>x1 &lt;=&gt; ~B &amp; ~C</code></li> <li><code>x2 &lt;=&gt; A | x1</code></li> </ul> <p>Then the conjunction of the variable at the root node and those equivalences yields the Tseitin CNF:</p> <pre><code>tseitin = x2 &amp; (x2 &lt;=&gt; A | x1) &amp; (x1 &lt;=&gt; ~B &amp; ~C)\n</code></pre> <p>Next, the equivalences are each transformed into CNF.  So for this example, this yields</p> <pre><code>tseitinCNF = x2 &amp; (~x1 | ~B) &amp; (~x1 | ~C) &amp; (B | C | x1) &amp; (~x2 | A | x1) &amp;\n             (~A | x2) &amp; (~x1 | x2).\n</code></pre> <p>Tseitin Transformation and NNF</p> <p>Note that it is not necessary to transform the formula to NNF before calling the Tseitin Transformation.  The transformation will perform the NNF transformation on its own if the formula is not already in NNF.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#plaisted-greenbaum-transformation","title":"Plaisted-Greenbaum Transformation","text":"<p>The Plaisted-Greenbaum (PG) Transformation PlaistedGreenbaumTransformation tries to improve the size of the resulting CNF compared to the Tseitin transformation by only introducing implications instead of equivalences.</p> <p>The PG transformation transforms the given formula into NNF before the sub-formulas are replaced.  This simplifies the algorithm since only a few cases have to be considered for the structure of the formula.  However, there is a special version of PG in LogicNG which also works for formulas in general by introducing an implication according to the polarity of the sub-formula.  The polarity of a node is the number of negations on the path from the root to this node.  If the number of negations is even, then the node has positive polarity, else it has negative polarity.  This version is a special implementation used for adding formulas to the SAT solver and there should be no need to ever use it manually.</p> <p>If a subtree <code>s</code> has a positive polarity, then the implication <code>x =&gt; s</code>, <code>x</code> being a newly introduced variable, is added to the conjunction of clauses which yields the PG transformation. Otherwise, if the polarity is negative, the implication <code>s =&gt; x</code> is added.</p> <p>Let's consider our example <code>A | ~(B &amp; C)</code>:</p> <ul> <li><code>B &amp; C</code> has negative polarity (the relevant number of negations is <code>1</code>), thus add <code>B &amp; C =&gt; x1</code> to the conjunction</li> <li><code>A | ~x1</code> has positive polarity (the relevant number of negations is <code>0</code>), thus add <code>x2 =&gt; A | ~x1</code> to the conjunction</li> </ul> <p>Note that nodes whose operator is <code>NOT</code> (as in <code>~(B &amp; C)</code>) are condensed with the parent node.</p> <p>Analogously to the Tseitin transformation, the conjunction of the variable at the root node and those equivalences yields the PG CNF:</p> <pre><code>pg = x2 &amp; (x2 =&gt; A | ~x1) &amp; (B &amp; C =&gt; x1)\n</code></pre> <p>The resulting CNF is</p> <pre><code>pgCNF = x2 &amp; (~x2 | A | ~x1) &amp; (~B | x1) &amp; (~C | x1)\n</code></pre> <p>Clearly, the CNF resulting from applying the Plaisted-Greenbaum transformation is smaller than the formula resulting from the Tseitin transformation. However, in contrast to the Tseitin transformation, the PG transformation does not preserve the number of satisfying assignments of the original formula (c.f. Model Counting).  That is: When applying the Tseitin transformation, the model count of the original formula is preserved, but when applying PG transformation, it is not.  Therefore, when one wants to count models with methods which require a formula in CNF as the input, one should not use PG to transform the formula.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#dnf-transformations","title":"DNF transformations","text":"<p>A DNF is a disjunction of conjunctions of literals.  The conjunction of literals is called a \"min-term\" or just \"term\".  So the formula</p> <pre><code>(a &amp; b &amp; ~c) | (~a &amp; c) | (d &amp; f) | (e &amp; ~c)\n</code></pre> <p>is a DNF with four terms, the first contains three literals, the other two literals.</p> <p>For the following examples consider</p> <pre><code>Formula f2 = p.parse(\"(A | B) &amp; C\");\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#dnf-factorization","title":"DNF Factorization","text":"<p>Similar to the <code>CNFFactorization</code>, the DNFFactorization is the naive implementation of a DNF conversion using mainly the distributive law.  For example, the DNF of <code>f2</code> is <code>A &amp; C | B &amp; C</code>.</p> <p>Exponential Blow-Up</p> <p>Note that analogously to the CNF factorization this can lead to an exponential blow-up and is thus not recommended for big formulas.  DNF factorizations can, just as CNF factorizations, be controlled with a <code>FactorizationHandler</code>.</p>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#canonical-cnf-and-dnf-enumeration","title":"Canonical CNF and DNF Enumeration","text":"<p>The canonical DNF enumeration CanonicalDNFEnumeration creates a DNF, in which every term contains every variable of the initial formula.  Therefore, every possible assignment of the DNF occurs as a term in the DNF. Thus, this DNF canonically describes a Boolean formula.</p> <p>For example, for <code>f2 = (A | B) &amp; C</code>, the canonical DNF is</p> <pre><code>~A &amp; B &amp; C | A &amp; B &amp; C | A &amp; ~B &amp; C\n</code></pre> <p>It is also possible to create a DNF via BDDs, see the BDD chapter.</p> <p>Note that all DNF transformations can lead to an exponential increase in the size of the formula.</p> <p> 2.3.0  There is also a canonical CNF tranformation CanonicalCNFEnumeration which conversely generates a canonical CNF where each clause contains all literals of the given formula.  The canonical CNF of <code>f2</code> e.g. is</p> <pre><code>(A | B | C) &amp; (A | ~B | C) &amp; (~A | ~B | C) &amp; (~A | B | C) &amp; (A | B | ~C)\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/normal-form-transformations/#aig-transformation","title":"AIG Transformation","text":"<p>Using the AIG transformation AIGTransformation one can transform any formula to an And-inverter graph.  An AIG consists only of conjunctions and negations.  For information about AIG graphs check out the excursion on And-Inverter Graphs. For an example look at the following transformation:</p> <pre><code>Formula f3 = p.parse(\"A =&gt; ~(B | ~C)\");\nFormula aig = f3.transform(new AIGTransformation());\n</code></pre> <p>The result of this transformation is the formula</p> <pre><code>~(A &amp; ~(~B &amp; C))\n</code></pre> <p>so a formula with only conjunctions and negations.</p>"},{"location":"documentation/formulas/operations/transformations/other-transformations/","title":"Other Transformations","text":""},{"location":"documentation/formulas/operations/transformations/other-transformations/#literal-substitution","title":"Literal Substitution","text":"<p>The transformation LiteralSubstitution substitutes literals in a given formula. For example, given the formula <code>A &amp; ~B | B &amp; ~D</code>, and the substitutions</p> <ul> <li><code>~B -&gt; C</code></li> <li><code>B -&gt; E</code></li> <li><code>D -&gt; ~A</code></li> </ul> <p>then the substituted formula is <code>A &amp; C | E &amp; A</code>.</p> <p>The difference to the <code>substitute</code> operation on formulas is, that such a substitution can only be applied from variables to arbitrary formulas, whereas the <code>LiteralSubstitution</code> operates on literals and therefore can replace positive and negative literals differently.</p> <p>Parallel Substitution</p> <p>Note that both substitutions perform a parallel substitution:</p> <p>That is, the formula <code>(X | A) &amp; (Y | B) &amp; (Z | C)</code> with the substitutions - <code>A -&gt; B</code> - <code>B -&gt; C</code></p> <p>results in <code>(X | B) &amp; (Y | C) &amp; (Z | C)</code>, and not <code>(X | C) &amp; (Y | C) &amp; (Z | C)</code>.</p> <p>The mapping that should be applied can either be given to the transformation as a parameter by using the parameterised constructor, or, if one wants to add mappings in hindsight, by adding substitutions with <code>addSubstitution()</code>.</p>"},{"location":"documentation/formulas/operations/transformations/other-transformations/#anonymizer","title":"Anonymizer","text":"<p>The Anonymizer transforms the given formula into one where all names of the formulas' variables are replaced by new ones.  This is usually used when the original variable names contain domain-specific knowledge and one wants to anonymize the formula.  One can define how the new variables are named: A prefix with which the variable shall begin and a number where to start.  The default values are <code>v</code> and <code>0</code>, meaning the anonymized variables will be <code>v0, v1, v2, ...</code> .</p> <p>Variable Ordering</p> <p>Note that the order of the new variables is based on the alphabetical order of the original variables (not in the order in which the variables occur in the formula). For example, when anonymizing the formula <code>A &amp; C | B</code>, the transformed formula is <code>v0 &amp; v2 | v1</code> (and not <code>v0 &amp; v1 | v2</code>, as one might expect).</p> <p> 2.3.0 The method <code>getSubstitution()</code> returns the current substitution map from the anonymizer.  This can be helpful if you want e.g. translate an anonymized formula back to its original one.</p>"},{"location":"documentation/formulas/operations/transformations/other-transformations/#qe-transformations","title":"QE Transformations","text":"<p>Using quantifier elimination transformations, one can eliminate quantified variables from a formula. There is the existential quantifier elimination ExistentialQuantifierElimination, which eliminates the existential quantifier <code>\u2203</code> in a given formula, and the universal quantifier elimination UniversalQuantifierElimination, which respectively eliminates the universal quantifier <code>\u2200</code>.</p> <p>Both transformations use the Shannon expansion for eliminating the quantifier, see (Boolean quantification in a first-order context by Seidl and Sturm).  In short: the formula is expanded once with the variable to eliminate substitued by false, once by true.  For an existential quantifier elimination the two formulas are then disjoined, for an universal quantifier elimination they have to be conjoined.</p> <p>Firstly, consider the <code>ExistentialQuantifierElimination</code> with the formula <code>\u2203C: A &amp; B &amp; (C | D)</code>.</p> <p>The transformation propagates the statement \"there exists the variable <code>C</code>\" through the formula, which yields <code>A &amp; B | A &amp; B &amp; D</code> and can be simplified to <code>A &amp; B</code>, meaning <code>A &amp; B</code> is a necessary and sufficient condition in order that there exists an assignment for <code>C</code> in order to evaluate the whole formula to true.</p> <p>Secondly, consider the <code>UniversalQuantifierElimination</code> with the formula <code>\u2200C: A &amp; B &amp; (C | D)</code>. Let <code>f3 = A &amp; B &amp; (C | D)</code>. Then the statement is: \"<code>f3</code> holds for all <code>C</code>\", regardless whether <code>C</code> is assigned to <code>true</code> or <code>false</code>. Simplified by the <code>UniversalQuantifierElimination</code>, this yields<code>A &amp; B &amp; D</code>, meaning <code>A &amp; B &amp; D</code> is a necessary and sufficient condition in order that for all assignments of <code>C</code> the formula can evaluate to true.  The <code>UniversalQuantifierElimination</code> can also evaluate to <code>false</code>: For example, <code>\u2200C, D: A &amp; B &amp; (C | D)</code>, that is \"<code>f3</code> holds for all <code>C</code> and all <code>D</code>\", is unsatisfiable.</p> <p>Both quantifier elimination transformations cannot be cached since they are dependent on the set of literals to eliminate.</p> <p>Here is a code snippet for this example for the existential quantifier elimination (analogous for the universal quantifier elimination):</p> <pre><code>ExistentialQuantifierElimination elimination =\n        new ExistentialQuantifierElimination(f.variable(\"C\"));\nFormula result = elimination.apply(f3, true);\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/other-transformations/#formula-factory-importer","title":"Formula Factory Importer","text":"<p>The FormulaFactoryImporter imports a formula from another formula factory into the current formula factory.  For example, the following code snippet imports the formula <code>f1</code> from the formula factory <code>f</code> to the new formula factory <code>g</code>:</p> <pre><code>FormulaFactory g = new FormulaFactory();\nFormulaFactoryImporter factoryImporter = new FormulaFactoryImporter(g);\nFormula result = f1.transform(formulaImporter, true);\n</code></pre> <p>The formula <code>result</code> is equivalent to <code>f1</code> but belongs to the formula factory <code>g</code>.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/","title":"Simplifier Transformations","text":"<p>First we discuss simplifiers which can be applied to all formulas, second we discuss simplifiers for special formula types (CNF, DNF, and pseudo-Boolean constraints) and we close with those transformations which perform proper algorithms for simplification.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#simplicity-of-formulas-and-the-rating-function","title":"Simplicity of Formulas and the Rating Function","text":"<p>The idea of the simplifiers in this chapter is to simplify a given formula.  But what is \"simple\" in terms of a formula?  Since \"simple\" is no mathematically defined term and can alter from application to application, some simplifiers let the user provide their own definiton of \"simple\".  This is done via a rating function.</p> <p>A rating function is an interface which can be implemented by the user and computes a simplicity rating for a given formula.  This could be for example the length of its string representation or the number of atoms.  This rating function is then used to compare two formulas during the simplification process and thus deciding which of the formulas is the \"simpler\" one.  There is a default rating function which is a rating function which compares formulas based on the length of their string representation (using the default string representation).</p> <p>The use of rating functions in the formula simplifiers works the following way: After a formula has been simplified with the relevant simplification (e.g. for the <code>FactorOutSimplifier</code> it is \"after the formula has been factored out\"), it is checked with the rating function whether the transformed formula is actually a simplification with respect to the specified criterion or not. Only if the transformed formula is simpler in terms of the rating function, the transformed formula is being returned, otherwise the initial formula is being returned.</p> <p>Therefore, formula transformations which use a rating function are quite flexible: One can implement application-specific rating functions and use these for the simplifier. Both the <code>FactorOutSimplifier</code> and the <code>AdvancedSimplifier</code> (see below) use rating functions.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#simplifiers-for-arbitrary-formulas","title":"Simplifiers for Arbitrary Formulas","text":""},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#factor-out-simplifier","title":"Factor Out Simplifier","text":"<p>The FactorOutSimplifier transforms the given formula to one where variables are factored out. That is, if multiple terms in the formula share a common factor, this factor is being taken out of the terms and the terms are summarized. The simplifier works by applying the Distributive Law heuristically for a smaller formula.</p> <p>For example, given the formula <code>A &amp; B &amp; C | A &amp; D</code>, both conjunction terms have the common factor <code>A</code>. Thus, the simplification that the <code>FactorOutSimplifier</code> yields is <code>A &amp; (B &amp; C | D)</code>.</p> <p>The <code>FactorOutSimplifier</code> can be used with and without a rating function. If the rating function is not specified, the <code>DefaultRatingFunction</code> is chosen. Thus, the following constructor creates a <code>FactorOutSimplifier</code> with the <code>DefaultRatingFunction</code>:</p> <pre><code>FactorOutSimplifier simplifier = new FactorOutSimplifier();\n</code></pre>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#basic-version-of-the-factor-out-simplifier-the-distributive-simplifier","title":"Basic Version of the Factor Out Simplifier: The Distributive Simplifier","text":"<p>The DistributiveSimplifier is an old and simpler version of the <code>FactorOutSimplifier</code>.</p> <p>The differences are the following:</p> <ul> <li><code>FactorOutSimplifier</code> factors out repetitively, <code>DistributiveSimplifier</code> does not.  For example, consider</li> </ul> <pre><code>(A | B) &amp; (A | C &amp; E) | B &amp; C &amp; D\n</code></pre> <p><code>A</code> can be factored out, leading to <code>A | B &amp; C &amp; E | B &amp; C &amp; D</code>, which is the result of the <code>DistributiveSimplifier</code>.   The <code>FactorOutSimplifier</code> however, goes a step further: It also factors <code>B &amp; C</code> out from the simplified formula, leading to <code>A | C &amp; B &amp; (E | D)</code>.</p> <ul> <li>The <code>DistributiveSimplifier</code> does not factor out if that would lead to losing an operand. Consider the two examples:</li> <li><code>A | A &amp; B</code>, <code>DistributiveSimplifier</code>: <code>A | A &amp; B</code>, <code>FactorOutSimplifier</code>: <code>A</code></li> <li> <p><code>A | A &amp; B | A &amp; C</code>, <code>DistributiveSimplifier</code>: <code>A | A &amp; (B | C)</code>, <code>FactorOutSimplifier</code>: <code>A</code></p> </li> <li> <p>The <code>FactorOutSimplifier</code> has a <code>RatingFunction</code> which enables the user to specify after which criteria the formula should be simplified</p> </li> </ul> <p>So, the <code>DistributiveSimpilifier</code> is inferior to the <code>FactorOutSimplifier</code>, is only kept for legacy reasons, and will likely be removed in upcoming versions of LogicNG.  Therefore, for all intents and purposes, we recommend to use the <code>FactorOutSimplifier</code>.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#unit-propagation-simplification","title":"Unit Propagation Simplification","text":"<p>The transformation UnitPropagation performs unit propagation on a given formula. Unit propagation works the following way: If a formula is such that a literal is forced for the formula to be satisfied, then this literal is propagated through the formula and thus simplifies the formula. Unit propagation is a key concept in SAT Solving and the implementation actually uses a modified variant of the MiniSat Solver.</p> <p>For example, consider the formula</p> <p><code>(A | C) &amp; ~C &amp; (B | C) &amp; (A | ~C)</code></p> <p>Then the literal <code>~C</code> is forced in the formula. Thus, the simplified formula (created by unit propagation) yields <code>~C &amp; A &amp; B</code>.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#backbone-simplifier","title":"Backbone Simplifier","text":"<p>The BackboneSimplifier computes the Backbone of a formula and propagates it through the formula, similarly to the Unit Propagation Transformation.</p> <p>The backbone of a formula is the set of variables which have to be assigned to <code>true</code> or to <code>false</code> for the formula to evaluate to <code>true</code>.</p> <p>For example, for a formula <code>A &amp; B &amp; (A | C) &amp; (D | E) &amp; ~F</code> the positive backbone is <code>A, B</code> - in any valid assignment, these variables have to be assigned to <code>true</code>. The negative backbone is <code>F</code>, meaning that in any valid assignment, <code>F</code> has to be assigned to <code>false</code>. With the backbone assignment <code>{A, B, ~F}</code>, the formula reduces to <code>(D | E)</code> - therefore the simplified formula yields <code>A &amp; B &amp; ~F &amp; (D | E)</code>.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#unit-propagation-vs-backbone-simplifier","title":"Unit Propagation vs. Backbone Simplifier","text":"<p>At first sight the backbone simplifier and unit propagation simplifier seem to be doing the same thing: They propagate variables which can only be assigned to either <code>true</code> or <code>false</code> through the formula.  However, the backbone simplifier guarantees to compute the complete backbone, whereas the unit propagation only propagates single literals through the formula.</p> <p>Thus, transforming a formula using unit propagation is always faster, but the result may not be as much simplified as using the backbone simplifier (nerdy details: the Unit Propagation only collects literals which are propagated by a SAT Solver on level 0).</p> <p>Consider the formula <code>f1</code>: <code>A &amp; (~A | B | C) &amp; (~A | B | ~C)</code></p> <pre><code>Formula unitprop = f1.transform(new UnitPropagation());\nFormula bb = f1.transform(new BackboneSimplifier());\n</code></pre> <p>The <code>UnitPropagation</code> propagates <code>A</code> through the formula and comes up with <code>(B | C) &amp; (B | ~C) &amp; A</code>.</p> <p>The <code>BackboneSimplifier</code> goes a step further: It computes the complete backbone of the formula which also contains <code>B</code> and can thus simplify the formula further to <code>A &amp; B</code>.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#negation-simplifier","title":"Negation Simplifier","text":"<p>The NegationSimplifier minimizes the number of negations of a formula by applying De Morgan's Law heuristically for a smaller formula. The resulting formula is minimized for the length of its string representation (using the string representation which is defined in the formula's Formula Factory).</p> <p>For example, the formula <code>~A &amp; ~B &amp; ~C</code> stays this way (since <code>~(A | B | C)</code> is of same length as the initial formula), but the formula <code>~A &amp; ~B &amp; ~C &amp; ~D</code> is being transformed to <code>~(A | B | C | D)</code> since its length is 16 vs. 17 in the un-simplified version.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#simplifiers-for-special-formula-types","title":"Simplifiers for Special Formula Types","text":""},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#subsumption","title":"Subsumption","text":"<p>Consider a CNF with some clauses (disjunctions of literals), among them <code>c1</code> and <code>c2</code>.  Imagine that the set of literals of clause <code>c2</code> contains all literals of clause <code>c1</code>, but not the other way round.  In other words, the set of literals of <code>c1</code> is a proper subset of the set of literals of <code>c2</code>.  We then say that <code>c1</code> subsumes <code>c2</code>.  In this case, <code>c2</code> can be removed from the CNF without changing the semantics (meaning) of the formula, since every satisfying assignment for <code>c1</code> will also satisfy <code>c2</code>.</p> <p>Similarly, given a DNF with some minterms (conjunctions), among them <code>m1</code> and <code>m2</code>, we say that <code>m1</code> subsumes <code>m2</code> if the set of literals of <code>m1</code> is a proper subset of the set of literals of <code>m2</code>.  So <code>m2</code> can be removed from the DNF without changing the semantics of the formula.</p> <p>The subsumption simplifiers for CNF and DNF remove clauses/terms which are subsumed others clauses/terms, in order to yield a simpler formula.</p> <ul> <li>CNF subsumption CNFSubsumption: Consider the formula <code>(A | B) &amp; (D | E) &amp; (A | B | C)</code>: The clause <code>(A | B)</code> subsumes the clause <code>(A | B | C)</code>. The transformed formula is thus <code>(A | B) &amp; (D | E)</code>.</li> <li>DNF subsumption DNFSubsumption: Similarly, consider <code>(A &amp; B) | (D &amp; E) | (A &amp; B &amp; C)</code>. The term <code>(A &amp; B)</code> subsumes the term <code>(A &amp; B &amp; C)</code>. The transformed formula is <code>(A &amp; B) | (D &amp; E)</code>.</li> </ul>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#pure-expansion-transformation","title":"Pure Expansion Transformation","text":"<p>The pure expansion transformation PureExpansionTransformation expands \"at most one\" or \"exactly one\" cardinality constraints by pure encodings, i.e. encodings which do not introduce new variables.  This is a simplification which does surely not minimize the length of the formula, but simplifies it in terms of the used operators.  This simplification can be important when e.g. performing a model count on a formula with cardinality constraints.  Not each cardinality constraint encoding preserves the model count.  Therefore, the model counter in LogicNG uses this transformation on its input formulas before computing the count.</p> <p>For example, given the at-most-one constraint <code>A + B + C &lt;= 1</code>, the transformed formula is <code>(~A | ~B) &amp; (~A | ~C) &amp; (~B | ~C)</code>.</p> <p>Given the exactly-one constraint <code>A + B + C = 1</code>, the transformed formula is <code>(~A | ~B) &amp; (~A | ~C) &amp; (~B | ~C) &amp; (A | B | C)</code>.</p> <p>Pseudo-Boolean Constraints</p> <p>Note that the transformation throws an exception if the formula contains any pseudo-boolean constraint which is not a cardinality constraint of type AMO or EXO since there are currently no pure encodings for these types of cardinality constraints.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#putting-it-all-together-the-advanced-simplifier","title":"Putting it all Together: The Advanced Simplifier","text":"<p>The AdvancedSimplifier is the most advanced simplifier of LogicNG which performs a very performant variant of Quine-McCluskey and many of the above simplifications.  In industrial applications it outperformed all existing simplification algorithms by far.  It performs the following steps:</p> <ol> <li>Computation of all prime implicants</li> <li>Finding the minimal coverage over the found prime implicants (by finding one smallest MUS)</li> <li>Building a DNF from the minimal prime implicant coverage</li> <li>Factoring out common factors of the DNF using the <code>FactorOutSimplifier</code></li> <li>Minimizing negations of the factored-out DNF using the <code>NegationSimplifier</code></li> </ol> <p>In contrast to the <code>FactorOutSimplifier</code>, the <code>AdvancedSimplifier</code> currently always needs a rating function and can not be used without one.  In LogicNG 2.3., the <code>AdvancedSimplifier</code> will be able to be called without a rating function - it will then use the <code>DefaultRatingFunction</code>.</p> <p>As an optional parameter the function takes an OptimizationHandler.  This can be useful since both the computation of the prime implicants and the SMUS computation can take a long time.  With the handler these computations can be aborted if necessary.</p> <p>As an example, this creates an advanced simplifier with the <code>DefaultRatingFunction</code>, where each computation process is canceled after 100 ms (every example in this section can be computed in <code>&lt; 100 ms</code>):</p> <pre><code>AdvancedSimplifier simplifier = new AdvancedSimplifier(\n        new DefaultRatingFunction(), new TimeoutOptimizationHandler(100));\n</code></pre> <p>Note</p> <p>The algorithm performs very well on small to middle-size formulas but of course, there are limits.  Since step 1 and 2 are quite computation-intensive the advanced simplifier should be used with care.</p>"},{"location":"documentation/formulas/operations/transformations/simplifier-transformations/#quinemccluskey-algorithm","title":"Quine\u2013McCluskey Algorithm","text":"<p>LogicNG currently contains an implementation of the Quine-McCluskey algorithm, a very common algorithm for minimizing formulas.  But this implementation will be removed in upcoming versions of LogicNG since the first two steps of the advanced simplifier above are equivalent to the Quine-McCluskey algorithm, but they perform far better than the old implementation.</p> <p>With LogicNG 2.3 the advanced simplifier will be extended with the possibility to configure the single simplification steps and therefore can be configured to behave exactly like Quine-McCluskey (by deactivating steps 3-5).</p>"},{"location":"documentation/knowledge-compilation/","title":"Knowledge Compilation","text":"<p>In order to compute queries on a formula, such as \"is the formula satisfiable?\", \"how many models does the formula have?\", \"does the formula imply another formula\" etc., one can take essentially one of two approaches:</p> <ol> <li> <p>Use tools like a SAT solver, which compute the answers to such queries on-line on the original input formula (or normal forms which can be efficiently computed).  Usually this on-line computation step is the computation-intensive part, but the off-line part of filling the SAT solver with the formula is easy.</p> </li> <li> <p>Off-line compile the original format into a more distinct format, e.g. a DNF, a BDD, or a DNNF and then answer the queries on this compiled format.  In this case, the off-line compile step is the computation-intensive part, but answering the queries on-line is efficient.</p> </li> </ol> <p>The second approach is called knowledge compilation.</p> <p>As a very simple example consider that we want to know two properties of a formula: 1) is it satisfiable, and 2) if so, how many models does it have.</p> <p>In order to answer these two questions with approach 1 you could fill a SAT solver with the formula, compute its satisfiability and then enumerate all models. These computations are hard (in this case in NP and #P).  For approach 2 you could compile the formula in a very simple knowledge compilation format, e.g. a canonical DNF.  Computing this canonical DNF is the hard part, but if you could compute it, the two questions would be trivial to answer: The formula is satisfiable, if the canonical DNF has at least one model, and the number of models are exactly the number of min-terms in the DNF.</p> <p>But of course it is often not feasible to compute the canonical DNF of a formula, therefore more distinct knowledge compilation formats have been researched over the years.  There are many knowledge compilation forms. Check out A Knowledge Compilation Map by Darwiche and Marquis to get an overview of the different knowledge compilation forms and how they perform in the distinct properties.</p> <p>Generally, there are three aspects when considering different knowledge compilation forms:</p> <ul> <li>the succinctness of the compiled format</li> <li>the class of queries that can be answered in polynomial time on the compiled form</li> <li>the class of transformations that can be applied in polynomial time on the compiled form</li> </ul> <p>In LogicNG, two advanced knowledge compilation forms are implemented:</p> <ol> <li>Binary Decision Diagrams (BDD)</li> <li>Decomposable Negation Normal Forms (DNNF)</li> </ol> <p>BDDs are well-studied and have been presented by Randal E. Bryant in 1986. DNNFs, however, among other knowledge compilation formats, have been developed more recently by Darwiche. The next chapter in this documentary is on BDDs, the succeeding one on DNNFs.</p> <p>For more information about knowledge compilation forms, and BDDs and DNNFs, check out chapter 2.3. in New Formal Methods for Automotive Configuration by Zengler.</p>"},{"location":"documentation/knowledge-compilation/bdd/","title":"BDD","text":""},{"location":"documentation/knowledge-compilation/bdd/#introduction","title":"Introduction","text":"<p>A Binary Decision Diagram (BDD) is a directed acyclic graph of a given formula. It has a single root; Each inner node is labeled with a propositional variable and has one outgoing edge for a positive assignment, and one edge for a negative assignment of the respective variable. The leaves are labeled with <code>1</code> and <code>0</code> representing<code>true</code> and <code>false</code>. An assignment is represented by a path from the root node to a leaf and its evaluation is the respective value of the leaf. Therefore, all paths to a 1-leaf are valid (possibly partial) models for the formula.</p> <p>LogicNG's BDD implementation is a Java implementation of the BDD package BuDDy.  All classes in the package <code>jbuddy</code> are part of the implementation.  The data structures in this package are very low-level and only used for working with BDDs internally.  If you want a \"nicer\" data structure for working with BDDs you can use the LogicNG BDD data structures in the package <code>datastructures</code> which lean more on a graphical representation of BDDs.  One can create the LogicNG internal data structure of a BDD using the <code>LNGBDDFunction</code>, see below.</p> <p>Some content in this chapter, such as the description of BDDs above and the example below are taken from chapter 2.3.1 in New Formal Methods for Automotive Configuration.</p>"},{"location":"documentation/knowledge-compilation/bdd/#example","title":"Example","text":"<p>As an example for a BDD, consider the formula</p> <pre><code>f1 = (x1 &lt;=&gt; x2) | x3\n</code></pre> <p>The BDD of <code>f1</code> is:</p> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <p>The green lines represent positive assignments of the respective variable, the red dotted lines represent negative assignments of the respective variable. That is, for some given assignment:</p> <p>If, in this assignment, <code>x1 = 1</code> (meaning <code>x1</code> is assigned to <code>true</code>), then we follow the green path, else we follow the red path. Then, at <code>x2</code>, check if <code>x2 = 1</code> in the given assignment. If it is, follow the green path, else follow the red path, etc. The applied variable ordering is <code>x1 &gt; x2 &gt; x3</code>, meaning that on any path the variables appear in this order. As we will find out below, the variable ordering plays a key role for the size of the BDD.  In order to see that the BDD graph indeed represents <code>f1</code>, one can try out some data points. For example,</p> <ul> <li><code>f1(1,0,1) = 1</code></li> <li><code>f1(1,0,0) = 0</code></li> </ul>"},{"location":"documentation/knowledge-compilation/bdd/#creating-a-bdd-graph","title":"Creating a BDD graph","text":"<p>You can create your own BDD graph in the dot format using the BDDDotFileWriter. The syntax is, for a given formula <code>f1</code>:</p> <pre><code>BDDDotFileWriter.write(\"name your BDD\", f1.bdd());\n</code></pre>"},{"location":"documentation/knowledge-compilation/bdd/#variable-ordering","title":"Variable Ordering","text":"<p>The structure and the size (number of nodes) of a BDD strongly depends on the specified variable ordering. There are examples where a bad variable ordering produces an exponential size BDD and a good variable ordering can lead to a linear size BDD.</p> <p>Consider the formula</p> <pre><code>x1 &amp; x2 | x3 &amp; x4 | ... | x(2n-1) &amp; x2n\n</code></pre> <ol> <li> <p>Given the variable ordering     <pre><code>x1 &lt; x3 &lt; ... &lt; x(2n-1) &lt; x2 &lt; x4 &lt; ... &lt; x2n,\n</code></pre>    the resulting BDD has more than <code>2^n</code> nodes.</p> </li> <li> <p>Given the variable ordering     <pre><code>x1 &lt; x2 &lt; ... &lt; x2n,\n</code></pre>    the BDD consists of <code>2n + 2</code> nodes.</p> </li> </ol> <p>For more information see wikipedia.</p> <p>However, finding an optimal variable ordering is NP-complete.</p> <p>In LogicNG, some common heuristics for BDD variable orderings are implemented:</p>"},{"location":"documentation/knowledge-compilation/bdd/#sorting-based-on-variables-occurrences","title":"Sorting Based on Variables' Occurrences","text":"<p>The variable orderings MinToMaxOrdering and MaxToMinOrdering sort the variables from minimal to maximal (respectively, maximal to minimal) occurrence in the input formula. If two variables have the same number of occurrences, their ordering according to their DFS ordering (see below) will be considered.</p>"},{"location":"documentation/knowledge-compilation/bdd/#sorting-based-on-breath-first-search-and-depth-first-search","title":"Sorting Based on Breath-First-Search and Depth-First-Search","text":"<p>The DFSOrdering traverses the formula in a DFS manner and gathers all variables in the occurrence. Analogously, the BFSOrdering traverses the formula in a BFS manner and gathers all variables in the occurrence. Check out how to traverse a formula in DFS manner (and, respectively, BFS manner) here.</p>"},{"location":"documentation/knowledge-compilation/bdd/#force-ordering","title":"Force Ordering","text":"<p>The ForceOrdering is a simple implementation of the \"FORCE\" variable ordering heuristic based on hyper-graphs presented by Aloul, Markov, and Sakallah. This ordering only works for CNF formulas, thus the given formula has to be converted to CNF before this ordering is called.  One can transform a formula to CNF using one of the CNF transformations.</p> <p>The code snippet to create a variable ordering (here with the example of a <code>DFSOrdering</code>) for a formula <code>f1</code> is:</p> <pre><code>List&lt;Variable&gt; ordering = new DFSOrdering().getOrder(f1);\n</code></pre> <p>A practical example for the significance of the right variable ordering is the following:</p> <p>Consider the following formula <code>f1</code> which we want to transform into a BDD and compute the number of clauses of the CNF representation of the BDD.</p> <pre><code>final Formula f1 = p.parse(\"(~(v372 | v2095 | v2096 | v683 | v1629 | v1655 | v1487 | v141 | v1509 | v743 | v2137 | v1622 | v2276 | v811 | v2277 | v782 | v39 | \" +\n   \"v1900 | v1375 | v1376 | v2113 | v2114 | v17 | v18) &amp; v1604 | (v17 | v18) &amp; ~(v372 | v2095 | v2096 | v683 | v1455 | v1655 | v1487 | \" +\n   \"v1509 | v743 | v2137 | v1356 | v1622 | v2276 | v811 | v2277 | v782 | v39 | v1900 | v1375 | v1376 | v2113 | v2114) &amp; v1604) &amp; (v1421 \" +\n   \"&amp; v1455 &amp; v1457 &amp; v675 &amp; v676 &amp; v690 &amp; v504 &amp; v708 &amp; v405 &amp; v1669 &amp; v1467 &amp; v1466 &amp; v1570 &amp; v1472 &amp; v1493 &amp; v1454 &amp; v507 &amp; v695 &amp; \" +\n   \"v1469 &amp; v1481 &amp; ~(v17 | v18) &amp; v1604 | (v17 | v18) &amp; v1457 &amp; v675 &amp; v676 &amp; v690 &amp; (v707 | v708) &amp; v2254 &amp; v405 &amp; v1669 &amp; v1361 &amp; \" +\n   \"v1563 &amp; v1467 &amp; v1466 &amp; v1570 &amp; v1493 &amp; v695 &amp; v508 &amp; v1469 &amp; v1474 &amp; v1483 &amp; v1604) &amp; (v1539 &amp; v356 &amp; v772 &amp; v769 &amp; v987 &amp; v1607 &amp; \" +\n   \"(v1645 | v506) &amp; v790 &amp; v974 &amp; v1486 &amp; v512 &amp; (v865 | v866 | v876 | v886 | v891) &amp; v854 &amp; v696 &amp; (v801 | v836 | v832) &amp; (v316 | \" +\n   \"v344) &amp; v1604 | v1539 &amp; v357 &amp; v682 &amp; v1350 &amp; v684 &amp; v511 &amp; v1449 &amp; (v886 | v891 | v864 | v865 | v866) &amp; v1354 &amp; v1607 &amp; v2172 &amp; \" +\n   \"v2117 &amp; v862 &amp; (v836 | v827 | v832) &amp; v1604 | v1539 &amp; v358 &amp; v1640 &amp; v769 &amp; v1607 &amp; v682 &amp; v790 &amp; v684 &amp; v1486 &amp; v511 &amp; v1449 &amp; \" +\n   \"v1354 &amp; v1356 &amp; (v865 | v866 | v876 | v886 | v891) &amp; v854 &amp; v506 &amp; v862 &amp; (v836 | v827 | v832) &amp; (v316 | v344) &amp; v1604 | v17 &amp; v356 \" +\n   \"&amp; v770 &amp; v769 &amp; (v500 | v503) &amp; v512 &amp; v1486 &amp; (v865 | v886 | v891 | v898) &amp; v854 &amp; v1424 &amp; (v836 | v1209 | v837 | v828) &amp; (v316 | \" +\n   \"v344) &amp; v1604 | v17 &amp; v771 &amp; v770 &amp; v769 &amp; v1374 &amp; v1604 | v17 &amp; v505 &amp; v769 &amp; v682 &amp; v684 &amp; v1486 &amp; v511 &amp; v1449 &amp; v1354 &amp; (v865 | \" +\n   \"v886 | v891 | v898) &amp; v854 &amp; v503 &amp; v1424 &amp; v862 &amp; v1494 &amp; v361 &amp; (v836 | v837 | v827 | v828) &amp; (v316 | v344) &amp; v1604 | v17 &amp; v359 &amp;\" +\n   \" v682 &amp; v1625 &amp; v1350 &amp; v684 &amp; v511 &amp; v1449 &amp; (v865 | v886 | v891 | v898) &amp; v1354 &amp; v1607 &amp; v2172 &amp; v2117 &amp; v862 &amp; v1494 &amp; v361 &amp; \" +\n   \"(v836 | v837 | v827 | v828) &amp; v1604) &amp; (v1539 &amp; v357 &amp; v1604 | ~(v1401 | v781 | v684 | v1449 | v1354 | v2117 | v1494) &amp; v1604 | v17 \" +\n   \"&amp; v505) &amp; v391 &amp; v1604\");\n\nfinal BDD bdd = formula.bdd(VariableOrdering.BFS); // (1)!\nfinal BigInteger numberOfClauses = bdd.numberOfClausesCNF();\n</code></pre> <ol> <li>replace respectively by the other orderings</li> </ol> <p>Depending on the variable ordering, we find that the resulting BDD has a very different number of CNF clauses:</p> Variable Ordering Number of Clauses <code>MAX2MIN</code> 5.646.676.904 <code>FORCE</code> 22.429.167 <code>DFS</code> 8.963.730 <code>MIN2MAX</code> 3.685.413 <code>BFS</code> 1.182.347 <p>So the number of clauses in the CNF varies from 1.182 million to 5.646 billion, depending on the variable ordering. This is a factor of ~5.000!</p> <p>Warning</p> <p>This example does not mean, that in general the BFS heuristic performs better than any other heuristic.  One could easily find another example formula where the numbers are exactly opposite.</p>"},{"location":"documentation/knowledge-compilation/bdd/#bdd-reorderings","title":"BDD Reorderings","text":"<p>When you created a BDD with a given ordering and want to improve the ordering, you can reorder the given BDD. Reordering a BDD is usually more efficient than creating a new one with a different ordering. For example, consider the following formula and its respective BDD:</p> <pre><code>Formula phi = p.parse(\"(x1 &lt;=&gt; x2) | x3 | x4\");\nBDD bdd = phi.bdd();\n</code></pre> <p>We can perform a random reordering with a BDDReordering in the following way:</p> <pre><code>BDDReordering bddReordering = new BDDReordering(bdd.underlyingKernel()); // (1)!\nbddReordering.addVariableBlockAll(); // (2)!\nbddReordering.reorder(BDDReorderingMethod.BDD_REORDER_RANDOM); // (3)!\n</code></pre> <ol> <li>create a BDDReordering</li> <li>adds a single variable block for all variables known by the kernel</li> <li>reorders randomly</li> </ol> <p>The result is:</p> Original BDD BDD after Reordering <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id8([\"x4\"])\n  id16([\"x3\"])\n  id17([\"x2\"])\n  id18([\"x2\"])\n  id19([\"x1\"])\n\n  id8 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id8 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id16 --&gt; id8\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id16 --&gt; id1\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id17 --&gt; id1\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id17 --&gt; id16\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id18 --&gt; id16\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id18 --&gt; id1\n    linkStyle 7 stroke:#009432,stroke-width:2px\n  id19 --&gt; id17\n    linkStyle 8 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id19 --&gt; id18\n    linkStyle 9 stroke:#009432,stroke-width:2px</code></pre> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id4([\"x2\"])\n  id5([\"x2\"])\n  id16([\"x1\"])\n  id17([\"x3\"])\n  id18([\"x3\"])\n  id19([\"x4\"])\n\n  id4 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id4 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id5 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id5 --&gt; id0\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id16 --&gt; id17\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id16 --&gt; id18\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id17 --&gt; id5\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id17 --&gt; id1\n    linkStyle 7 stroke:#009432,stroke-width:2px\n  id18 --&gt; id4\n    linkStyle 8 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id18 --&gt; id1\n    linkStyle 9 stroke:#009432,stroke-width:2px\n  id19 --&gt; id16\n    linkStyle 10 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id19 --&gt; id1\n    linkStyle 11 stroke:#009432,stroke-width:2px</code></pre> <p>Note that the command <code>bddReordering.addVariableBlockAll()</code> is necessary: It means that the reordering should happen between all variables. Alternatively, you can define blocks of variables in which you want to reorder using the method <code>addVariableBlock()</code>.</p>"},{"location":"documentation/knowledge-compilation/bdd/#creating-bdds","title":"Creating BDDs","text":"<p>There are essentially two ways to create a BDD: The first one uses the BDDFactory directly, the second is a \"shortcut\" and uses the <code>bdd()</code>-function on the respective formula.</p> <p>In this chapter, consider the formula <code>f1</code> and the variable ordering <code>varOrder</code>.</p>"},{"location":"documentation/knowledge-compilation/bdd/#creating-bdds-using-a-bdd-factory","title":"Creating BDDs Using a BDD Factory","text":"<p>Firstly, we consider the option of using a <code>BDDFactory</code>. BDDs are created with a kernel and, optionally, with a handler. The kernel holds all internal data structures and the internal state for the BDD creation, the handler can control the creation process.</p>"},{"location":"documentation/knowledge-compilation/bdd/#bdd-kernel","title":"BDD Kernel","text":"<p>Let <code>n</code> be the number of variables of <code>f1</code>. The constructor parameters of the BDDKernel are the following. One of <code>numVars</code> and <code>ordering</code> must be present.</p> Parameter Forced Default Value Description <code>f</code> yes Formula factory of <code>f1</code> The formula factory to be used for the creation <code>numVars</code> no <code>n</code> The number of variables <code>ordering</code> no (none) The variable ordering <code>nodeSize</code> yes 30 * <code>n</code> The initial number of nodes in the node table <code>cacheSize</code> yes 20 * <code>n</code> The fixed size of the internal caches. <p>Initial <code>nodeSize</code></p> <p>The BDD kernel internally holds a table with all nodes in the BDD. This table can be extended dynamically, but this is an expensive operation. On the other hand, one wants to avoid reserving too much space for nodes, since this costs unnecessary memory. 30 * <code>x</code> proved to be efficient in practice for medium sized formulas.</p> <p>A kernel can be constructed without a variable order, or with an ordering:</p> <p>Without a variable ordering</p> <p>For example, with <code>numVars</code>, <code>nodeSize</code> and <code>cacheSize</code> all being <code>10</code>, then the constructor is:</p> <pre><code>BDDKernel kernel = new BDDKernel(f1.factory(), 10, 10, 10);\n</code></pre> <p>The variable ordering is then the ordering in which the variables occur in the formula. This is obviously not a very sensible ordering, therefore it is recommended to create a kernel with a variable ordering.</p> <p>With a variable ordering</p> <p>For example, with the variable ordering <code>MaxToMinOrdering</code> and <code>nodeSize</code> and <code>cacheSize</code> all being <code>10</code>, the constructor is:</p> <pre><code>List&lt;Variable&gt; ordering = new MaxToMinOrdering().getOrder(f1);\nBDDKernel kernel2 = new BDDKernel(f1.factory(), ordering, 10, 10);\n</code></pre> <p>When you don't define the BDD kernel for your applications, the standard kernel configuration with the default values from the table above will be used.</p>"},{"location":"documentation/knowledge-compilation/bdd/#bdd-handler","title":"BDD Handler","text":"<p>Using a BDDHandler, one can control the BDD compilation.  There are two BDD handler implemented in LogicNG:</p> <ol> <li>The TimeoutBDDHandler cancels the compilation of the BDD after the given timeout. There are different timeout types which are described in the class itself.</li> <li>The NumberOfNodesBDDHandler cancels the compilation of the BDD after a given number of added nodes.</li> </ol> <p>Of course you can always implement your own handler for specific purposes.  To initialize the BDD factory with a handler, see the following code snippet:</p> <pre><code>BDDKernel myKernel = new BDDKernel(f1.factory(), f1.variables().size(), 10, 15);\nBDDHandler myHandler = new TimeoutBDDHandler(100);\nBDD bdd = BDDFactory.build(f1, myKernel, myHandler);\n</code></pre>"},{"location":"documentation/knowledge-compilation/bdd/#create-a-bdd-without-a-bdd-factory","title":"Create a BDD without a BDD Factory","text":"<p>The class <code>Formula</code> has a method to create BDDs. With this method one cannot set a handler or settings via a kernel. Since without a BDD handler it is impossible to control the building process, these methods should only be called for small formulas. The kernel is the standard kernel (see above).</p> <ol> <li>Without a variable ordering: <code>f1.bdd()</code> returns the BDD of <code>f1</code> with the variable ordering like the variables occurr in the formula.</li> <li>With a variable ordering: <code>f1.bdd(varOrder)</code> returns the BDD of <code>f1</code> with the variable ordering <code>varOrder</code>.</li> </ol>"},{"location":"documentation/knowledge-compilation/bdd/#creating-bdds-by-executing-boolean-operations","title":"Creating BDDs by Executing Boolean Operations","text":"<p> 2.4.0</p> <p>If you already have a BDD, you can directly execute Boolean operations on it and e.g. negate it, or conjoin or disjoin it with another BDD.  The available operations on the <code>BDD</code> class are:</p> <ul> <li><code>negate()</code> build a negation of the current BDD</li> <li><code>implies(BDD other)</code> build an implication from the current to the <code>other</code> BDD</li> <li><code>isImpliedBy(BDD other)</code> build an implication from the <code>other</code> BDD to the current one</li> <li><code>equivalence(BDD other)</code> build an equivalence between the current and the <code>other</code> BDD</li> <li><code>and(BDD other)</code> build the conjunction of this and the <code>other</code> BDD</li> <li><code>or(BDD other)</code> build the disjunction of this and the <code>other</code> BDD</li> </ul>"},{"location":"documentation/knowledge-compilation/bdd/#functions-on-bdds","title":"Functions on BDDs","text":"<p>When given a formula in the BDD format, one can execute different functions on them. For this section, consider the BDD created above:</p> <p><pre><code>BDD bdd = f1.bdd();\n</code></pre> that is:</p> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <p>There are a couple of functions to query the internal properties of the BDD:</p> <ul> <li><code>underlyingKernel()</code> returns the kernel of the BDD</li> <li><code>bddNodeCount()</code> counts the number of distinct nodes for the BDD. For <code>bdd</code>, it is <code>4</code></li> <li><code>getVariableOrder()</code> returns the variable order of the BDD. For <code>bdd</code>, it is <code>[x1, x2, x3]</code></li> <li><code>pathCountZero()</code> and <code>pathCountOne()</code> return the number of paths leading to the terminal <code>0</code> (false), respectively, <code>1</code> (true) node</li> </ul>"},{"location":"documentation/knowledge-compilation/bdd/#tautology-and-contradiction-check","title":"Tautology and Contradiction Check","text":"<p>To check whether a BDD is a tautology or a contradiction, you can call the two methods <code>isTautology()</code> and <code>isContradiction()</code>.  This is one of the questions which can be answered very easily and in fact in constant time on a BDD: a tautology BDD has only one node <code>1</code> and a contradiction has only one node <code>0</code>.</p>"},{"location":"documentation/knowledge-compilation/bdd/#variable-profile","title":"Variable Profile","text":"<p>The method <code>variableProfile()</code> computes the how often each variable occurs in the BDD, i.e. how many nodes are there for each variable. The syntax is:</p> <pre><code>SortedMap&lt;Variable, Integer&gt; variableIntegerSortedMap = bdd.variableProfile();\n</code></pre> <p>The result is <code>{x1=1, x2=2, x3=1}</code>, meaning that <code>x1</code> occurs <code>once</code> in the BDD, <code>x2</code> occurs twice in the BDD and <code>x3</code> occurs also just once in the BDD.</p> <p>Different Variable Profiles</p> <p>Note that the result of the <code>variableProfile</code> of the BDD is usually different from the variable profile on the original formula:</p> <pre><code>Formula f1 = p.parse(\"(x1 &lt;=&gt; x2) | x3\"); // the initial formula of bdd\nMap&lt;Variable, Integer&gt; variableProfile = f1.apply(new VariableProfileFunction());\n</code></pre> <p>The result is <code>{x1=1, x3=1, x2=1}</code>, as <code>x2</code> occurs in the formula only once.</p>"},{"location":"documentation/knowledge-compilation/bdd/#variable-support","title":"Variable Support","text":"<p>The support of a BDD is the set of variables which the BDD depends on, meaning the opposite of don't-care variables. The support is not necessarily equivalent to the set of variables of the formula with which the BDD was created. In order to see this, consider the example of a tautology:</p> <pre><code>Formula f2 = p.parse(\"A | B | ~A &amp; ~B\");\n</code></pre> <p>Then the support of the formula can be computed via</p> <p><pre><code>SortedSet&lt;Variable&gt; support = f2.bdd().support();\n</code></pre> Thus, the support is empty, but the variables of <code>f2</code> are <code>A, B</code>. If we added a variable which is relevant to the BDD to the formula, say</p> <pre><code>Formula f2 = p.parse(\"(A | B | ~A &amp; ~B) &amp; C\");\n</code></pre> <p>then the support is <code>C</code>, as it is the only variable which the BDD depends on.</p>"},{"location":"documentation/knowledge-compilation/bdd/#swapping-variables-in-the-orderung","title":"Swapping Variables in the Orderung","text":"<p>You can change the initial variable ordering manually (in contrast to automatic variable reordering) using <code>swapVariables()</code>. For example, swapping the variables <code>x1</code> and <code>x2</code> can be achieved with:</p> <pre><code>bdd.swapVariables(f.variable(\"x1\"), f.variable(\"x2\"));\n</code></pre> <p>The result is:</p> Original BDD BDD after Swapping x1 and x2 <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id8([\"x1\"])\n  id9([\"x1\"])\n  id13([\"x2\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id8 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id8 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id9 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id9 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id8\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id9\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre>"},{"location":"documentation/knowledge-compilation/bdd/#cnf-and-dnf-generation","title":"CNF and DNF generation","text":"<p>CNF and DNF creation on a BDD is very easy: For a DNF just enumerate all paths to the 1-node, for a CNF enumerate all paths to the 0-node and negate them. The function <code>numberOfClausesCNF()</code> counts the number of clauses of the CNF without building the CNF.</p> <p>This is very helpful if you want to know if the resulting CNF is feasible to work with or not.  A seen in the examples above: harmless looking formulas can generate CNFs with more than 5.000 clauses.  But sometimes the CNF generated with the BDD can be a viable alternative for a factorization-based CNF without auxilliary variables.  Therefore there is a <code>FormulaTransformation</code> you can use directly on formulas to generate a BDD-based CNF: <code>BDDCNFTransformation</code>.</p> <p>An example for these functions is:</p> <pre><code>Formula cnf = bdd.cnf();\nBigInteger numberOfClauses = bdd.numberOfClausesCNF();\n</code></pre> <p>The number of clauses is <code>2</code> and the result is <code>(x1 | ~x2 | x3) &amp; (~x1 | x2 | x3)</code>.</p> <p> 2.3.0  The method <code>dnf()</code> on a <code>BDD</code> returns the DNF of the BDD in the same way as the above desribed CNF.  There is also a formula transformation <code>BDDDNFTransformation</code> to use a BDD-based DNF generation directly on a formula.</p>"},{"location":"documentation/knowledge-compilation/bdd/#model-counting-and-enumeration","title":"Model Counting and Enumeration","text":"<p>Counting and listing all possible models of a BDD is simple and fast since this simply requires following all paths which lead to \"true\".  This is another algorithmic approach for model counting and enumeration.  For the example of <code>f1</code>, the syntax is</p> <pre><code>BigInteger modelCount = bdd.modelCount();\nList&lt;Assignment&gt; models = bdd.enumerateAllModels();\n</code></pre> <p>The model count is <code>6</code> and the resulting models are:</p> <pre><code>- x1, x2, x3\n- ~x1, x2, x3\n- x1, ~x2, x3\n- x1, x2, ~x3\n- ~x1, ~x2, x3\n- ~x1, ~x2, ~x3\n</code></pre> <p><code>enumerateAllModels()</code> has an optional parameter if you want to specify the set of variables over which you enumerate (just like the <code>enumerateAllModels()</code> method on the solver) for projected model enumeration.  For more information, see the chapter on model enumeration.</p>"},{"location":"documentation/knowledge-compilation/bdd/#finding-one-model","title":"Finding One Model","text":"<p>If you are only interested in one model, there are three options to find one:</p> <p>Firstly, you can use <code>model()</code>, which returns the variables of one path which leads to \"true\". This assignment is not complete; it contains only those variables which were on the path to <code>true</code>, which can be a subset of all variables occurring in the BDD.  All variables not occuring are don't-care variables.</p> <p>For example:</p> <p><pre><code>Assignment model = bdd.model();\n</code></pre> returns <code>Assignment{pos=[], neg=[~x2, ~x1]}</code>.</p> <p>This is not a complete model, since <code>x3</code> is not assigned it is a don't-care varialbe, meaning that adding either <code>~x3</code> or <code>x3</code> to the partial assignment results in a valid model.</p> <p>Secondly, if you want to specify which value the don't-care variables in the resulting model should have, you can use the method <code>model()</code> with extra parameters. The first parameter specifies to which value the don't-care variables should be set in the model (true/false), and the second parameter specifies which variables should be contained in the model.</p> <p>For example,</p> <pre><code>Assignment model1 = bdd.model(true, f1.variables()); // (1)!\nAssignment model2 = bdd.model(false, f1.variables()); // (2)!\n</code></pre> <ol> <li>don't-care variables are set to <code>true</code></li> <li>don't-care variables are set to <code>false</code></li> </ol> <p>returns the following results:</p> <ul> <li><code>model1</code>: <code>Assignment{pos=[x3], neg=[~x2, ~x1]}</code></li> <li><code>model2</code>: <code>Assignment{pos=[], neg=[~x3, ~x2, ~x1]}</code></li> </ul> <p>Thirdly, if you don't-care what value the don't-care variables have, you can use the method <code>fullModel()</code>. This method returns a complete model with an arbitrary assignment of the don't care variables.</p> <p>The syntax is:</p> <pre><code>Assignment assignment = bdd.fullModel();\n</code></pre> <p>and the result is <code>Assignment{pos=[], neg=[~x3, ~x2, ~x1]}</code>.</p>"},{"location":"documentation/knowledge-compilation/bdd/#restriction","title":"Restriction","text":"<p>Using the function <code>restrict()</code> one can restrict the BDD with literals, i.e. setting the variables to a fixed value and simplifying the BDD - like restriction on formulas.  As an example, we restrict the given BDD by <code>x2</code>.</p> <pre><code>BDD bddRestricted = bdd.restrict(f.literal(\"x2\", true));\n</code></pre> <p>The result is:</p> Original BDD BDD after Restricting x2 <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id14([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id14 --&gt; id6\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id14 --&gt; id1\n    linkStyle 3 stroke:#009432,stroke-width:2px</code></pre>"},{"location":"documentation/knowledge-compilation/bdd/#quantifier-elimination","title":"Quantifier Elimination","text":"<p>You can perform existential and universal quantifier elimination for a given set of variables using the <code>exists()</code> and <code>forall()</code> methods.  An introduction to Boolean quantifier elimination can be found e.g. in Parametric Quantified SAT Solving by Sturm and Zengler.  For example, if we want to eliminate the universally quantified variable <code>x3</code> from the BDD, we could perform the following code:</p> <pre><code>BDD qe = bdd.forall(f.variable(\"x3\"));\n</code></pre> <p>The result is</p> Original BDD BDD after Universally Eliminating x3 <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id4([\"x2\"])\n  id5([\"x2\"])\n  id10([\"x1\"])\n\n  id4 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id4 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id5 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id5 --&gt; id0\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id10 --&gt; id5\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id10 --&gt; id4\n    linkStyle 5 stroke:#009432,stroke-width:2px</code></pre>"},{"location":"documentation/knowledge-compilation/bdd/#converting-to-a-formula","title":"Converting to a Formula","text":"<p> 2.4.0</p> <p>Additionally to a CNF and a DNF, also the Shannon expansion can be generated from a given BDD with the method <code>toFormula()</code></p> <pre><code>Formula formula = bdd.toFormula();\n</code></pre> <p>yielding the formula representation <code>~x1 &amp; (~x2 | x2 &amp; x3) | x1 &amp; (~x2 &amp; x3 | x2)</code>.</p>"},{"location":"documentation/knowledge-compilation/bdd/#creating-the-logicng-internal-bdd-data-structure","title":"Creating the LogicNG-internal BDD Data Structure","text":"<p>Sometimes it can be useful to create a data structure which leans on the graphical representation of BDDs. Consider the representation of <code>f1</code> from above:</p> <pre><code>graph TD\n  id0[\"false\"]\n    style id0 stroke:#ea2027,color:#ffffff,fill:#ea2027\n  id1[\"true\"]\n    style id1 stroke:#009432,color:#ffffff,fill:#009432\n  id6([\"x3\"])\n  id11([\"x2\"])\n  id12([\"x2\"])\n  id13([\"x1\"])\n\n  id6 --&gt; id0\n    linkStyle 0 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id6 --&gt; id1\n    linkStyle 1 stroke:#009432,stroke-width:2px\n  id11 --&gt; id1\n    linkStyle 2 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id11 --&gt; id6\n    linkStyle 3 stroke:#009432,stroke-width:2px\n  id12 --&gt; id6\n    linkStyle 4 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id12 --&gt; id1\n    linkStyle 5 stroke:#009432,stroke-width:2px\n  id13 --&gt; id11\n    linkStyle 6 stroke:#ea2027,stroke-width:2px,stroke-dasharray:3\n  id13 --&gt; id12\n    linkStyle 7 stroke:#009432,stroke-width:2px</code></pre> <p>The LogicNG internal BDD data structure has a super class for all nodes: BDDNode, a class for inner nodes representing variables BDDInnerNode, and a class for terminals of the BDD BDDConstant.  Any inner node holds the variable it represents, it's high-edge, meaning the variable is assigned to <code>true</code> (green line in graph), and it's low-edge (red dotted line in graph), meaning the variable is assigned to <code>false</code>.</p> <p>This LogicNG internal data structure of a given BDD can be created using the LNGBDDFunction or with the auxiliary method <code>toLngBdd()</code>.</p> <p>For example, given</p> <pre><code>BDDNode node = bdd.toLngBdd();\n</code></pre> <p>then the result of the function is the representation of <code>f1</code> with the LogicNG internal representation:</p> <pre><code>&lt;x1 |\n low=&lt; x2 |\n    low=&lt;$true&gt;\n    high=&lt;x3 |\n      low=&lt;$false&gt;\n      high=&lt;$true&gt;&gt;\n &gt;\n high=&lt; x2 |\n    low=&lt;x3 |\n      low=&lt;$false&gt;\n      high=&lt;$true&gt;\n    &gt;\n    high=&lt;$true&gt;\n &gt;\n&gt;\n</code></pre>"},{"location":"documentation/knowledge-compilation/dnnf/","title":"DNNF","text":"<p>Another knowledge compilation format is d-DNNF - deterministic, decomposable negation normal form. The d-DNNF of a formula has proven to be more succinct than it's BDD.  Further, it helps to alleviate the ubiquitous memory explosion problem of BDDs with large formulas.  Much of the content in this chapter, such as the definition and the example below are taken from chapter 2.3.2 in New Formal Methods for Automotive Configuration.</p> <p>We first explain what a DNNF and a d-DNNF is.  In LogicNG, d-DNNFs are referred to simply as DNNFs. Note that DNNFs which are not deterministic are not implemented in LogicNG.</p>"},{"location":"documentation/knowledge-compilation/dnnf/#dnnf","title":"DNNF","text":"<p>A formula <code>f1</code> in NNF is in decomposable negation normal form (DNNF) if the decompositional property holds, that is, the operands of a conjunction do not share variables.</p> <p>As an example, consider the formula:</p> <pre><code>f1 = (A &amp; B) | (A &amp; ((~B | E) &amp; F))\n</code></pre> <p>The formula is in DNNF, as can be seen by checking the conjunctions:</p> <ol> <li><code>(A &amp; B)</code> with <code>{A} \u2229 {B} = \u2205</code>,</li> <li><code>(~B | E) &amp; F)</code> with <code>{B, E} \u2229 {F} = \u2205</code></li> <li><code>A &amp; ((~B | E) &amp; F)</code> with <code>{A} \u2229 {B, E, F} = \u2205</code>.</li> </ol> <p>Each propositional formula can be transformed into a semantically equivalent DNNF. This is not obvious, but consider the canonical DNF of a formula where all unsatisfiable minterms are deleted. Such a formula is obviously a DNNF: the decompositional property has to hold for each minterm. Since all minterms are satisfiable, they cannot contain conflicting literals, and therefore do not share any variables. Since each formula can be transformed into such a canonical DNF by enumerating all models and listing them as minterms, each formula can be transformed into a DNNF.</p>"},{"location":"documentation/knowledge-compilation/dnnf/#d-dnnf","title":"d-DNNF","text":"<p>A DNNF <code>f1</code> is called deterministic (d-DNNF) if operands of a disjunction do not share models.</p> <p>The DNNF of the example above is not deterministic, since e.g. the two disjunction operands <code>(A &amp; B)</code> and <code>(A &amp; ((~B | E) &amp; F))</code> share the model <code>{A \u2192 true, B \u2192 true, E \u2192 true, F \u2192 true}</code>.</p> <p>An example for a d-DNNF is <code>((~A &amp; B) | (~B &amp; A)) &amp; ((C &amp; D) | (~C &amp; ~D))</code>.</p> <p>Obviously decompositionality holds: no conjunction operands share variables. There are two disjunctions in the formula:</p> <ol> <li><code>(~A &amp; B) | (~B &amp; A)</code>, where both operands do not share a model, and</li> <li><code>(C &amp; D) | (~C &amp; ~D)</code>, where both operands do not share a model too.</li> </ol> <p>Therefore, the formula is also deterministic.</p> <p>Again, each formula can be transformed into a d-DNNF. Reconsider the example above, on how any formula can be transformed into DNNF: Since the resulting DNNF is canonical, no two minterms share a model, therefore it is also deterministic.</p> <p>For example, consider the formula</p> <pre><code>Formula f2 = p.parse(\"(A | B) &amp; (D | E)\");\n</code></pre> <p>One can transform it to a d-DNNF using:</p> <pre><code>Dnnf dnnf = new DnnfFactory().compile(f2);\n</code></pre> <p>The result is <code>(A | ~A &amp; B) &amp; (D | ~D &amp; E)</code>.</p>"},{"location":"documentation/knowledge-compilation/dnnf/#model-counting-with-d-dnnfs","title":"Model counting with d-DNNFs","text":"<p>There are several queries which can be solved in polynomial time for d-DNNFs. One of these queries is implemented in LogicNG, namely counting the number of models of a formula.  Note that a non-deterministic DNNF does not support this operation in polynomial time, as has been shown by Pipatsrisawat &amp; Darwiche in 2008<sup>1</sup>.</p> <p>For the DNNF <code>dnnf</code> above, the model count can be computed via</p> <pre><code>BigInteger modelcount = dnnf.execute(DnnfModelCountFunction.get());\n</code></pre> <p>For this example, the model count is <code>9</code>.</p> <p>For information about the model count algorithm of a formula in d-DNNF, check out chapter 2.4 in New Formal Methods for Automotive Configuration.</p> <p>Application Insight</p> <p>Instead of compiling the DNNF of a formula manually and counting the models, there is an advanced algorithm implemented in LogicNG which performs some further optimizations and can simply be called by <code>ModelCounter.count()</code> for a list of formulas which is interpreted as conjunction.  This algorithm is used in production and counts models of large configuration spaces up to 10<sup>60</sup> possible solutions.</p> <ol> <li> <p>Pipatsrisawat, Knot, &amp; Darwiche, Adnan.2008. New compilation languages based on structured decomposability. Pages 517\u2013522 of: Proceedings of the 23rd national conference on artificial intelligence, AAAI\u201908. AAAI Press\u00a0\u21a9</p> </li> </ol>"},{"location":"documentation/solvers/","title":"Solvers","text":"<p>One of the core features offered by LogicNG are (SAT) Solvers.</p> <p>Right now, there are two types of solvers:</p> <ol> <li>SAT Solvers, which, in their basic form, can compute whether a formula is satisfiable or not and therefore solving a decision problem.  However, there are many algorithms which can compute more complex things by iteratively calling and modifying a SAT Solver and LogicNG provides many extensions and functions on SAT solvers.  In the next chapter we describe the different SAT Solvers implemented in LogicNG as well as the algorithms implemented around them.</li> <li>MaxSAT Solvers on the other hand can directly be used for optimization.  The question they answer is how many clauses in an unsatisfiable formula can be maximally satisfied.  In a partial MaxSAT problem one can also differentiate between \"hard\" and \"soft\" formulas.  Hard formulas are required to be satisfied while soft formulas are not, but the MaxSAT Solver tries to satisfy as many of them as possible.  Additionally soft formulas can also have a weight.  In this case the solver tries to satisfy the formulas with the maximum global weight.  MaxSAT solvers are presented in the chapter on MaxSAT.</li> </ol>"},{"location":"documentation/solvers/maxsat-solving/","title":"MaxSAT Solving","text":"<p>Given an unsatisfiable formula in CNF, the MaxSAT problem is the problem of finding an assignment which satisfies the maximum number of clauses and therefore solves an optimization problem rather than a decision problem.  There are two extensions to MaxSAT Solving: 1) the distinction of hard/soft clauses, and 2) additional weighted clauses, yielding four different flavours of MaxSAT solving:</p> <ol> <li>Pure MaxSAT</li> <li>Partial MaxSAT</li> <li>Weighted MaxSAT</li> <li>Weighted Partial MaxSAT</li> </ol> <p>In a Partial MaxSAT problem you can distinguish between hard and soft clauses.  A hard clause must be satisfied whereas a soft clause should be satisfied but can be left unsatisfied.  This means the solver only optimizes over the soft clauses.  If the hard clauses themselves are unsatisfiable, no solution can be found.</p> <p>In a Weighted MaxSAT problem clauses can have a positive weight.  The solver then does not optimize the number of satisfied clauses but the sum of the weights of the satisfied clauses.</p> <p>The Weighted Partial MaxSAT problem is the combination of Partial MaxSAT and weighted MaxSAT.  I.e. you can add hard clauses and weighted soft clauses to the MaxSAT solver.</p> <p>Note two important points:</p> <ol> <li>MaxSAT can be defined as weighted MaxSAT restricted to formulas whose clauses have weight 1, and as Partial MaxSAT in the case that all the clauses are declared to be soft.</li> <li>The above definitions talk about clauses on the solver, not arbitrary formulas.  In real-world use cases you often want to weight whole formulas and not just clauses.  LogicNG's MaxSAT solver API gives you this possibility and internally translates the formulas and their weights accordingly.  This is a huge quality-of-life improvement when working with the solvers.</li> </ol>"},{"location":"documentation/solvers/maxsat-solving/#maxsat-algorithms-in-logicng","title":"MaxSAT Algorithms in LogicNG","text":"<p>LogicNG's MaxSAT implementation is based on OpenWBO and its underlying encodings with PBLib.  Therefore, you can use different algorithms, depending on your MaxSAT flavour and your specific use case.  There are two orthogonal strategies to solve MaxSAT problems:</p> <ol> <li>Based on linear search</li> <li>Based on producing and iteratively relaxing unsatisfiable cores</li> </ol> <p>Details on this distinction can be found in the paper Algorithms for Weighted Boolean Optimization by Manquinho, Marques-Silva and Planes.</p> <p>Here is an overview of the algorithms in LogicNG and their capabilities:</p> Algorithm Description Strategy Unweighted Weighted <code>LinearSU</code> Linear Sat-Unsat Linear Search yes yes <code>LinearUS</code> Linear Unsat-Sat Linear Search yes no <code>MSU3</code> Seminal-core guided algorithm Unsat-Core yes no <code>WMSU3</code> Weighted MSU3 Unsat-Core no yes <code>WBO</code> Weighted Boolean Optimization Unsat-Core yes yes <code>IncWBO</code> Incremental WBO Unsat-Core yes yes <code>OLL</code> OLL (since  2.4.0) Unsat-Core yes yes <p>All algorithms in LogicNG support partial MaxSAT.  <code>LinearUS</code> and <code>MSU3</code> do not support weighted clauses/formulas, <code>WMSU3</code> does not support unweighted clauses/formulas.</p> <p>The <code>LinearSU</code> stands for Linear SAT-UNSAT and it means that all sat-calls on the SAT-Solver are SAT except for the last call. That means: We start with a version without soft formulas on the SAT solver (which is SAT as long as the conjunction of the hard formulas evaluate to <code>true</code>).  Then we add clauses as long as an UNSAT comes for the first time.  <code>LinearUS</code> stands for Linear UNSAT-SAT and works the other way around: All SAT-Solver calls are UNSAT and the last one is SAT.  So first we add all soft clauses, then remove clauses one by one until the SAT-call is SAT.</p> <p>The three <code>MSU3</code>, <code>WMSU3</code>, and <code>OLL</code> algorithms are based on unsatisfiable cores.  The two <code>WBO</code> and <code>IncWBO</code> algorithms are based on a CNF encoding of the pseudo-Boolean Optimization problem and therefore are strongly dependent on the size of the weights.</p> <p>Which algorithm to use depends strongly on the specific use case and must be evaluated.  In practice <code>OLL</code> should be the best choice for all weighted problems especially when dealing with large weights.</p>"},{"location":"documentation/solvers/maxsat-solving/#using-maxsat-solvers-in-logicng","title":"Using MaxSAT Solvers in LogicNG","text":"<p>A MaxSAT solver in LogicNG is created by using its corresponding factory method in the class MaxSATSolver.  E.g. the method <code>incWBO(f)</code> generates a MaxSAT solver with the <code>IncWBO</code> algorithm.  Each factory method can have an optional parameter for the solver's configuration.</p> <p>Hard formulas are added with the method <code>addHardFormula()</code>, soft clauses are added with <code>addSoftClause(formula, weight)</code> where the weight has to be positive.  For an unweighted clause, use the weight 1.  The method <code>solve()</code> solves the problem for the formulas on the solver and returns a <code>MaxSATResult</code> which has one of three states:</p> <ol> <li><code>UNSATISFIABLE</code>: The hard clauses on the solver are already unsatisfiable, optimization could not be performed</li> <li><code>OPTIMUM</code>: An optimal solution was found</li> <li><code>UNDEF</code>: The search was aborted by a handler and yielded no result</li> </ol> <p>As with SAT solvers, a MaxSAT solve process can be customized with a handler which can be implemented by the user and aborts the solve process in certain conditions.</p> <p>The method <code>model()</code> returns the model found by the solver when an optimal solution was found.  The method <code>result()</code>  returns the minimum weight (or number of clauses if unweighted) of clauses/formulas which have to be unsatisfied.  Therefore, if the minimum number of weights is 0, the formula is satisfiable.</p> <p>We look at some examples on how to use the MaxSAT solver with the following simple set of formulas which are unsatisfiable together:</p> <pre><code>A &amp; B &amp; (C | D)\nA =&gt; ~B\n~C\n~D\n</code></pre>"},{"location":"documentation/solvers/maxsat-solving/#pure-maxsat-solving","title":"Pure MaxSAT Solving","text":"<p>We generate a <code>MSU3</code> solver and add all formulas as soft clauses with weight 1.  Therefore, we have a pure MaxSAT problem without distinction between hard/soft clauses and without weights.</p> <pre><code>MaxSATSolver solver = MaxSATSolver.msu3(f);\nsolver.addSoftFormula(p.parse(\"A &amp; B &amp; (C | D)\"), 1);\nsolver.addSoftFormula(p.parse(\"A =&gt; ~B\"), 1);\nsolver.addSoftFormula(p.parse(\"~C\"), 1);\nsolver.addSoftFormula(p.parse(\"~D\"), 1);\n\nsolver.solve();  // OPTIMUM\nsolver.model();  // Assignment{pos=[], neg=[~A, ~B, ~C, ~D]}\nsolver.result(); // 1\n</code></pre> <p>In this case we can find an optimal solution: at least one formula remains unsatisfied.  In this case the model assigns all variables to <code>false</code>, thus the first formula is unsatisfied and all other formulas are satisfied.</p> <p>As we will see in the next section, this is the only way of unsatisfying only one formula.  If the first formula holds, we have to unsatisfy at least two other formulas.</p>"},{"location":"documentation/solvers/maxsat-solving/#partial-weighted-maxsat-solving","title":"Partial Weighted MaxSAT Solving","text":"<p>We generate a <code>WMSU3</code> solver and add once again the first formula as hard clause and all other formulas as soft clauses with different weights.  Therefore, we have a partial weighted MaxSAT problem.</p> <pre><code>MaxSATSolver solver = MaxSATSolver.wmsu3(f);\nsolver.addHardFormula(p.parse(\"A &amp; B &amp; (C | D)\"));\nsolver.addSoftFormula(p.parse(\"A =&gt; ~B\"), 2);\nsolver.addSoftFormula(p.parse(\"~C\"), 4);\nsolver.addSoftFormula(p.parse(\"~D\"), 8);\n\nsolver.solve();  // OPTIMUM\nsolver.model();  // Assignment{pos=[A, B, C], neg=[~D]}\nsolver.result(); // 6\n</code></pre> <p>In this case we can find an optimal solution once again.  Since the fourth formula now has a large weight, the incentive to satisfy it is larger than the incentive to satisfy the third formula.  So in contrast to the last section the model now includes <code>C</code> and not <code>D</code>, thus unsatisfying the third formula.</p> <p>The result in this case is 6 - the sum of weights of all unsatisfied formulas: the second formula with weight 2 and the third formula with weight 4.</p> <p>Multiple Optimal Solutions</p> <p>Note that this is the only optimal solution for this problem. In general, however, there can be multiple optimal solutions.</p>"},{"location":"documentation/solvers/maxsat-solving/#special-cases","title":"Special Cases","text":"<p>Last we consider two special cases.  First we try to solve a formula where the hard clauses are already unsatisfiable:</p> <pre><code>MaxSATSolver solver = MaxSATSolver.msu3(f);\nsolver.addHardFormula(p.parse(\"A &amp; B &amp; C\"));\nsolver.addHardFormula(p.parse(\"A =&gt; ~B\"));\nsolver.addHardFormula(p.parse(\"~C\"));\nsolver.addSoftFormula(p.parse(\"X | Y\"), 1);\n\nsolver.solve();  // UNSATISFIABLE\nsolver.model();  // null\nsolver.result(); // -1\n</code></pre> <p>In this case the <code>solve()</code> method returns the state <code>UNSATISFIABLE</code>.  There is no model and the result is -1.</p> <p>Now we try a formula which is satisfiable:</p> <pre><code>MaxSATSolver solver = MaxSATSolver.msu3(f);\nMaxSATSolver solver = MaxSATSolver.msu3(f);\nsolver.addHardFormula(p.parse(\"A &amp; B &amp; C\"));\nsolver.addSoftFormula(p.parse(\"~C | D\"), 1);\nsolver.addSoftFormula(p.parse(\"X | Y\"), 1);\n\nsolver.solve();  // OPTIMUM\nsolver.model();  // Assignment{pos=[A, B, C, D, X], neg=[~Y]}\nsolver.result(); // 0\n</code></pre> <p>The solver found an optimal solution in this case.  Further, the result is 0 - indicating that all formulas were satisfied and no formula had to be unsatisfied.</p>"},{"location":"documentation/solvers/maxsat-solving/#minimum-vs-maximum-solving-the-dual-problem","title":"Minimum vs. Maximum: Solving the Dual Problem","text":"<p>As seen above, the solver tries to maximize the number of satisfied clauses by minimizing the number of unsatisfied clauses. The returned result is the sum of weights of the unsatisfied clauses.</p> <p>But what when you want to know the minimal number of satisfied clauses?  Then you have to adjust your problem modelling accordingly.  Let us consider a small example:</p> <pre><code>MaxSATSolver solver = MaxSATSolver.wmsu3(f);\nsolver.addHardFormula(p.parse(\"(A &amp; B &amp; ~X &amp; ~D) | (B &amp; C &amp; ~A) | (C &amp; ~D &amp; X)\"));\nsolver.addSoftFormula(p.parse(\"A\"), 2);\nsolver.addSoftFormula(p.parse(\"B\"), 4);\nsolver.addSoftFormula(p.parse(\"C\"), 8);\nsolver.addSoftFormula(p.parse(\"D\"), 5);\nsolver.addSoftFormula(p.parse(\"X\"), 7);\n</code></pre> <p>We have one hard formula and each variable in it has a given weight.  Solving the problem yields the assignment <code>Assignment{pos=[B, C, D, X], neg=[~A]}</code> with result 2. This means when setting all variables except <code>A</code> to <code>true</code>, only one formula (in this case variable) is unsatisfied and has weight 2.</p> <p>If we give the variable weights a meaning, e.g. a price, then we have now computed the most expensive variable assignment.  <code>B</code>, <code>C</code>, <code>D</code>, <code>X</code> together have a price of 24.  In order to compute the cheapest variable assignment, we should not try to maximize the positive literals, but instead the negative literals: We want to set a maximal number of expensive variables to <code>false</code>.  We can do this by negating the variables in the soft formulas:</p> <pre><code>MaxSATSolver solver = MaxSATSolver.wmsu3(f);\nsolver.addHardFormula(p.parse(\"(A &amp; B &amp; ~X &amp; ~D) | (B &amp; C &amp; ~A) | (C &amp; ~D &amp; X)\"));\nsolver.addSoftFormula(p.parse(\"~A\"), 2);\nsolver.addSoftFormula(p.parse(\"~B\"), 4);\nsolver.addSoftFormula(p.parse(\"~C\"), 8);\nsolver.addSoftFormula(p.parse(\"~D\"), 5);\nsolver.addSoftFormula(p.parse(\"~X\"), 7);\n</code></pre> <p>Now the model is <code>Assignment{pos=[A, B], neg=[~C, ~D, ~X]}</code> with a result of 6.  This means the cheapest variable assignment consists of only <code>A</code> and <code>B</code> with a price of 6.</p> <p>Once you wrap your head around this concept of duality you have a very mighty tool to solve all kinds of optimization problems with MaxSAT solving.</p>"},{"location":"documentation/solvers/sat-solving/","title":"SAT Solving","text":"<p>The SAT problem is the problem of deciding whether a formula in Boolean logic is satisfiable or not. In other words, does there exist a variable assignment under which the formula evaluates to <code>true</code>?</p> <p>A SAT solver is a tool that, given a formula <code>f1</code>, returns <code>SAT</code> if <code>f1</code> is satisfiable, and <code>UNSAT</code> otherwise.</p> <p>In order to understand the theoretical background for this chapter more in-depth, we recommend reading section 2.2. in New Formal Methods for Automotive Configuration. The concepts of unit clauses and empty clauses are also explained in this chapter.</p> <p>A Short History on SAT Solving</p> <p>The satisfiability problem has been around for more than 60 years.  It was the first problem proved to be NP-complete by Stephen Cook in 1971.  The first algorithms to tackle it even date back to the 1960s.  Most modern SAT solvers work only on the CNF of a formula, that's why efficient CNF transformations are a very important topic in LogicNG.</p> <p>In 1962, the researchers Martin Davis, George Logemann and Donald W. Loveland developed the first algorithm that solved the SAT problem. It builds up on results of a previous collaboration from Davis and Hilary Putnam, and is thus called the DPLL algorithm.  The basic idea of DPLL is to have two phases: a decision phase where the algorithm takes a yet unassigned variable of the formula and assigns it to true or false and then a deduction phase in which the algorithm tries to infer new variable assignments from unit clauses (an unsatisfied clause where only one literal is unassigned and its assignment therefore is forced). These inferred assignments are also called \"(unit) propagations\". If, during this deduction phase, an empty clause (an unsatisfied clause where all literals are assigned) is detected, the last decision must have been wrong, so it is turned into a unit propagation with the opposite assignment. At the end, the algorithm either finds a satisfiable assignment of all variables or an empty clause at the \"beginning\" (where no decision can be undone). DPLL was improved over the years by finding better heuristics how to choose the next variable and what value to assign it to.</p> <p>About 15 years after the DPLL algorithm was developed, two research groups independently presented a new algorithm, the Conflict-Driven Clause Learning (CDCL) algorithm which was the largest break-through in SAT Solving to date. The idea is that whenever a conflict is reached in the search tree of DPLL, a new clause is learned from this conflict. This clause is added to the SAT solver's clause set, so the solver does not run in the same conflict again. Furthermore, the algorithm does not just jump back to the last decision, but rather detects the last decision which was actually relevant for the conflict. Together with clause learning, other important improvements on the technical side were discovered, like the 2-watched literals scheme, new activity-based search heuristics, search restarts and clause deletion. This all cumulated in the implementation of MiniSat in 2004. Its implementation counts less than 1,000 lines of code and was very clear and well documented. Many researchers based their work on MiniSat; also the solvers in LogicNG are all based on MiniSat.</p>"},{"location":"documentation/solvers/sat-solving/#the-sat-solvers-in-logicng","title":"The SAT Solvers in LogicNG","text":"<p>There are three SAT solvers implemented in LogicNG: MiniSat, Glucose and MiniCARD.  MiniSat has as its base the original MiniSat implementation translated and adjusted to Java.  Glucose is a more recent extension of MiniSat.  The cardinality solver MiniCARD deals more efficiently with cardinality constraints than normal SAT solver.</p> <p>In LogicNG, SATSolver is the super class, which is extended by MiniSat. It is possible to implement other types of SAT solvers (e.g. <code>CleaneLing</code>, which was present in early LogicNG versions), which would then also extend <code>SATSolver</code>.</p> <p>This chapter aims to provide detailed information about how to use the SAT solvers implemented in LogicNG. The structure of this chapter is the following:</p> <ol> <li>Solver Overview</li> <li>Generating SAT Solvers</li> <li>Incremental/Decremental Interface</li> <li>Methods on SAT Solvers</li> <li>Solver Configuration</li> <li>Functions on Solvers</li> </ol>"},{"location":"documentation/solvers/sat-solving/#solver-overview","title":"Solver Overview","text":"<p>Since all three solvers are based on MiniSat, there is a base class MiniSatStyleSolver where those methods common to all solvers are implemented.  Each solver then implements its own sub-class from this class.</p>"},{"location":"documentation/solvers/sat-solving/#minisat-solver","title":"MiniSat solver","text":"<p>The developer of MiniSAT say about their solver:</p> <p>MiniSat</p> <p>MiniSat is a minimalistic, open-source SAT solver, developed to help researchers and developers alike to get started on SAT.</p> <p>-- Niklas E\u00e9n, Niklas S\u00f6rensson</p> <p>Check out MiniSat's website.  The core implementation of MiniSat in LogicNG follows the original source code quite closely.  This is done on purpose and simplifies the implementation of tools based on MiniSat which there are many.  However, of course there had to be adjustments made for Java and there are many features already implemented in LogicNG's MiniSat version which are not present in the original code, among them:</p> <ul> <li>An incremental and decremental interface for saving and loading the solver state in order to add and remove formulas (more on that later)</li> <li>Optimized backbone computation directly on the solver</li> <li>Extraction of the literals propagated on level 0 and therefore direct consequences of the formula</li> <li>Integrated efficient incremental cardinality constraints</li> <li>Proof Tracing in the solver</li> <li>A generic function interface for executing self written functions directly on the solver</li> </ul>"},{"location":"documentation/solvers/sat-solving/#glucose-solver","title":"Glucose solver","text":"<p>The developers of the Glucose solver say about their solver:</p> <p>Glucose</p> <p>Glucose is based on a new scoring scheme (well, not so new now, it was introduced in 2009) for the clause learning mechanism of so-called \"Modern\" SAT solvers (it is based on our IJCAI'09 paper). ... The name of the Solver name is a contraction of the concept of \"glue clauses\", a particular kind of clauses that glucose detects and preserves during search.</p> <p>-- Gilles Audemard and Laurent Simon</p> <p>For more information about Glucose, check out their GitHub.  As with MiniSat, LogicNG's implementation of Glucose is heavily oriented on the original source code.  LogicNG's implementation has proof tracing like the original, but currently no incremental/decremental interface for Glucose.</p>"},{"location":"documentation/solvers/sat-solving/#minicard-solver","title":"MiniCARD solver","text":"<p>MiniCARD is a cardinality solver based on MiniSat. A cardinality solver is a SAT solver which deals more efficiently with cardinality constraints than normal SAT solvers.</p> <p>The inventor of MiniCARD says about his solver:</p> <p>MiniCard</p> <p>MiniCARD handles cardinality constraints natively, using the same efficient data structures and techniques MiniSat uses for clauses, giving it much better performance on cardinality constraints than CNF encodings of those constraints passed to a typical SAT solver.</p> <p>-- Mark Liffiton</p> <p>For more information, check out GitHub.  LogicNG's implementation of MiniCARD does implement the incremental/decremental interface, but it does currently not support proof tracing.</p>"},{"location":"documentation/solvers/sat-solving/#generating-sat-solvers-in-logicng","title":"Generating SAT Solvers in LogicNG","text":"<p>The SAT solvers can be generated with factory methods on the <code>MiniSat</code> class, i.e.</p> <pre><code>SATSolver miniSat = MiniSat.miniSat(f);   // Generate a new MiniSat solver\nSATSolver glucose = MiniSat.glucose(f);   // Generate a new Glucose solver\nSATSolver miniCard = MiniSat.miniCard(f); // Generate a new MiniCARD solver\n</code></pre> <p>Further, you may also create a SAT solver with your own configuration. In order to do so, specify the parameters in a MiniSatConfig or a GlucoseConfig and give it as a parameter to the solver. See below for information on those parameters.</p> <p>Example of creating a MiniSat solver with activated proof tracing:</p> <pre><code>MiniSatConfig config = MiniSatConfig.builder().proofGeneration(true).build();\nSATSolver solver = MiniSat.miniSat(f, config);\n</code></pre> <p>For the rest of this chapter, we consider the solver <code>SATSolver solver = MiniSat.miniSat(f)</code>.</p>"},{"location":"documentation/solvers/sat-solving/#incrementaldecremental-interface","title":"Incremental/Decremental Interface","text":"<p>There are applications where SAT solvers get large formulas for which the satisfiability is computed over hours.</p> <p>Application Insight</p> <p>However, there is a completely different use case, for which the incremental/decremental interface has been developed:  You have a large satisfiable formula and want to check for hundreds of thousands of small formulas, whether their conjunction with the large formula is still satisfiable.</p> <p>For this, it is useful to be able to not only add formulas to the solver (incremental interface), but also delete formulas from the solver (decremental interface) without resetting the whole solver state or using auxiliary variables for clause activation/deactivation.</p> <p>The incremental and decremental interface is one of the perks of LogicNG. You may use this interface by saving the state of your current solver at different times, and returning to it from later time points.  The state contains only the lengths of all internal data structures e.g. all stored variables, clauses, learnt clauses and so on. This makes the saving and loading state very efficient, since saving is essentially just storing the length of arrays and loading is shrinking those arrays to their stored length.</p> <p>Let's look at an example:</p> <pre><code>Formula f1 = p.parse(\"A &amp; B &amp; C\");\nsolver.add(f1);\nsolver.sat();   // TRUE\n\nSolverState initialState = miniSat.saveState(); // (1)!\nsolver.add(p.parse(\"~A\")); // (2)!\nsolver.sat();   // FALSE\n\nsolver.loadState(initialState); // (3)!\nsolver.add(p.parse(\"D\")); // (4)!\nsolver.sat();   // TRUE\n</code></pre> <ol> <li>we save this state of the solver</li> <li>we add a new formula to the solver, rendering it unsatisfiable</li> <li>now we load the last solver state (with only <code>A &amp; B &amp; C</code> on it)</li> <li>we add another formula to the solver</li> </ol> <p>So with the first <code>sat()</code> call we checked the formula <code>A &amp; B &amp; C</code> for satisfiability, in the second call we checked <code>A &amp; B &amp; C &amp; ~A</code> and in the last call we checked <code>A &amp; B &amp; C &amp; D</code>.  But the original formula <code>A &amp; B &amp; C</code> was added only once.  This has a few critical advantages: we do not need to reset and refill the solver, and especially: everything learned on the original formula before the <code>saveState()</code> is kept between different SAT calls.</p> <p>Since the save/load state operation only works on the length of data structures and not on their actual content (this would be far to inefficient), it is not possible to go to a future state once you loaded an earlier state.  This means that you can only load states older than the current one.  So you can think of the states of a SAT solver as a stack.  You can pop elements of the stack and go to older states, but you can never access an already popped element.</p> <p>Consider the following example:</p> <pre><code>Formula f1 = p.parse(\"A &amp; B &amp; C\");\nminiSat.add(f1);\nSolverState initialState = miniSat.saveState();\n\nminiSat.add(p.parse(\"~A\"));\nSolverState nextState = miniSat.saveState();\n\nminiSat.loadState(initialState); // (1)!\nminiSat.loadState(nextState); // (2)!\n</code></pre> <ol> <li>Loading the initial state is possible</li> <li>This is not possible, since you reverted \"nextState\" and can not go \"back forward\" to it</li> </ol> <p>On the other hand, you can go back to the same state repeatedly as long as you don't go back before it.</p> <pre><code>Formula f1 = p.parse(\"A &amp; B &amp; C\");\nminiSat.add(f1);\nSolverState initialState = miniSat.saveState();\n\nminiSat.add(p.parse(\"~A\"));\nminiSat.sat();\n\nsolver.loadState(initialState); // check another formula\nsolver.add(p.parse(\"~B\"));\nsolver.sat();\n\nsolver.loadState(initialState); // check another formula\nsolver.add(p.parse(\"~C\"));\nsolver.sat();\n</code></pre>"},{"location":"documentation/solvers/sat-solving/#methods-on-sat-solvers","title":"Methods on SAT Solvers","text":"<p>There is not only the possibility to solve the current formula and get SAT or UNSAT as result - that is one of the core functions of a SAT solver, but LogicNG's solvers implement far more methods that help users tackle different problems.</p>"},{"location":"documentation/solvers/sat-solving/#adding-formulas-and-propositions","title":"Adding Formulas and Propositions","text":"<p>Once the solver is created, you have to add formulas or propositions to it. The SAT solver then checks whether the conjunction of all added formulas is satisfiable.</p> <p>The standard way to add formulas or propositions to the solver is the method <code>add()</code>. The formula is then, depending on the parameter <code>cnfMethod</code> in the SAT solver configuration, transformed into an at least equisatisfiable CNF.  Note that equisatisfiability instead of equivalence is enough at this point.  If you have not specified this parameter, this is done using the Plaisted-Greenbaum transformation.  However, if the introduction of auxiliary variables is not wanted, you can use the CNF factorization or BDD CNF transformation, which both yield a semantically equivalent CNF without auxiliary variables.</p> <p>So in general you don't have to convert the formula to CNF before you add it to the solver - the solver does this on its own.  In fact: Unless you need the CNF at other points in you application, it is wise not to generate it manually, because then it is created on the formula factory.  If the solver creates the CNF, it generates it directly on the solver which is more performant and especially requires less heap and can be garbage collected when the solver is destroyed.  Therefore, in our use cases we almost never transform formulas to CNF before adding them to the solver unless there is a very specific reason for it.</p> <p>Example which adds the formula <code>f1</code> to the solver:</p> <pre><code>Formula f1 = p.parse(\"A &amp; (~B | C)\");\nsolver.add(f1);\n</code></pre> <p>Using <code>add()</code>, one can also add a list of formulas or a single proposition to the solver. Using <code>addPropositions()</code>, one can add a list of propositions to the solver (due to Java's type erasure these have to be two different methods).</p> <p>You can also add cardinality constraints directly to the solver.  As with CNFs, it is a good idea not to convert cardinality constraints to CNF before adding them to the solver.  When using MiniSat or Glucose, they are also only converted on the solver directly, so they are not polluting the formula factory.  When using MiniCARD, they are added to the solver as special clauses and can thus be processed more efficiently.  If you have many cardinality constraints in your problem, it is worth considering using MiniCARD. Depending on your specific use case, MiniCARD can yield performance advantages but does not provide all functionality which MiniSat does provide</p>"},{"location":"documentation/solvers/sat-solving/#solving","title":"Solving","text":"<p>The method <code>sat()</code> without further arguments solves the conjunction of all formulas which currently lie on the solver.  There are two optional parameters for the <code>sat()</code> call:</p> <ul> <li>a set of literals(s): the formula on the solver will be solved, and these literals act as so-called \"assumptions\" (c.f. Solving with Assumptions)</li> <li>a handler: allows you to control the solving process by providing own handlers</li> </ul> <p>Every combination with/without literals and with/without handler leads to a valid <code>sat()</code> call.  We call solving without parameters a \"standard solve\".  One can also solve with a fixed variable ordering <code>satWithSelectionOrder()</code> (see below).   The result of the <code>sat()</code> and <code>satWithSelectionOrder()</code> call is an instance of the class <code>Tristate</code>: <code>TRUE</code>, <code>FALSE</code> or <code>UNDEF</code>.  When the formula on the solver is satisfiable, the <code>sat()</code> call yields <code>TRUE</code>, when it is unsatisfiable, it yields <code>FALSE</code>.  The result is <code>UNDEF</code> if the solving process did not finish, and this happens only if a handler aborted the computation.</p> <p>If no arguments are provided, the formula on the solver is solved without assumptions and with no handler and always yields a <code>TRUE</code> or <code>FALSE</code> result.</p> <p>Example for the \"standard solve\":</p> <pre><code>Formula f1 = p.parse(\"A &amp; (~B | C)\");\nsolver.add(f1);\nTristate sat = solver.sat();\n</code></pre>"},{"location":"documentation/solvers/sat-solving/#solving-with-assumptions","title":"Solving with Assumptions","text":"<p>When the <code>sat()</code> method is called with a list of literals, the result of this call indicates whether the formula on the solver in conjunction with these literals is satisfiable or not.  This is called assumption solving or solving with assumptions.  Of course one would reach the same result with the incremental/decremental interface: Save the state, add the literals to the solver, and loading the state again.  But assumption solving is more efficient since the assumption literals can be treated specially during solving and there is no explicit save/load state involved.  Assumptions can only be literals and not arbitrary formulas - for arbitrary formulas, use save/load state.</p> <p>There are many use cases for assumption solving, e.g. a large formula lies on the solver and one wants to check many assignments against this formula.  However, assumption solving has also a disadvantage: one can not generate a proof trace after solving with assumptions.  There you still need to use the save/load state mechanism.</p> <p>As an example, consider</p> <pre><code>Formula f1 = p.parse(\"A &amp; (~B | C)\");\nsolver.add(f1);\n</code></pre> <p>Then <code>solver.sat(f.literal(\"A\", true))</code> checks whether <code>f1</code> is satisfiable when <code>A</code> is assigned to <code>true</code>. The result is <code>TRUE</code>, but the result of <code>solver.sat(f.literal(\"A\", false))</code> is <code>FALSE</code>.</p> <p>Similarly, one can add multiple literals to the SAT solver in the following way:</p> <pre><code>List&lt;Literal&gt; literals =\n        Arrays.asList(f.literal(\"B\", true), f.literal(\"C\", false));\nTristate sat = solver.sat(literals);\n</code></pre> <p>The result of the last call is <code>FALSE</code> (because of <code>f1</code>).</p>"},{"location":"documentation/solvers/sat-solving/#solving-with-handlers","title":"Solving with Handlers","text":"<p>Further, one can control the solving process by using a SAT handler. For example, the <code>TimeoutSATHandler</code> cancels the solving process after a given timeout.  But there are also more advanced handlers which can count the number of conflicts or the number of restarts of the solver instance.  For more information about the handlers check out this chapter.</p> <p>As an example, the following code calls the solver and aborts the computation after 100 ms:</p> <pre><code>Tristate sat = solver.sat(new TimeoutSATHandler(100));\n</code></pre> <p>Handler Abortion</p> <p>Note that in this case when the solver can not compute the result within these 100 ms, the result will be <code>UNDEF</code>.</p>"},{"location":"documentation/solvers/sat-solving/#solve-with-a-variable-selection-order","title":"Solve with a Variable Selection Order","text":"<p>Let's reconsider the solving process of the SAT solvers: After each unit propagation step (which did not yield a conflict), the SAT solver makes a \"decision\", i.e. it chooses some variable and assigns it to a certain value (<code>true</code> or <code>false</code>) before starting unit propagation again. The order in which the variables are chosen and assigned to is usually an efficient activity heuristic.</p> <p>However, it is possible to change this order. This can be useful in certain circumstances when you e.g. have certain domain knowledge about your problem and know you can provide a better selection order.  Usually using a fixed order is slower than relying on the internal heuristics.</p> <p>Using <code>satWithSelectionOrder()</code> one can hand over</p> <ol> <li>A selection order</li> <li>A SAT handler (optional, see above)</li> <li>Assumptions (optional, see above)</li> </ol> <p>The selection order does not need to contain all variables known by the solver. After the solver has used all variables from the selection order, it will continue to choose from the remaining variables using its internal heuristics.</p> <p>Alternatively, if you want to use the same selection order over multiple <code>sat()</code> calls, you can set a selection order via <code>setSelectionOrder()</code> and later potentially reset it again with <code>resetSelectionOrder()</code> s.t. the solver will use its own heuristics again.</p>"},{"location":"documentation/solvers/sat-solving/#getting-models-from-the-solver","title":"Getting Models from the Solver","text":"<p>If the solver is <code>SAT</code>, you might be interested in the assignment (or \"model\") for the formula which the solver found.  The call to <code>model()</code> returns a model for the formulas which lie on the solver.  For example, the following code snippet returns a model for the formula <code>f1</code>:</p> <pre><code>MiniSat miniSat = MiniSat.miniSat(f);\nFormula f1 = p.parse(\"A | (~B &amp; C)\");\nminiSat.add(f1);\nminisat.model() // returns the model `~A, ~B, C`\n</code></pre> <p>When not changing any parameters, all of LogicNG's solvers are deterministic, i.e. when filled with the same formula of the same factory they will always produce the same model.  This is critical for industrial applications.</p> <p>You can get a list of all valid assignments using <code>solver.enumerateAllModels()</code>. Optionally, you can restrict the solver to specific variables by handing over those variables as parameters to this method call. For more information about this, see the chapter on model counting.  However, use this function very careful: even for few variables, the number of solutions can grow exponentially and therefore get fast out of hands.</p> <p>Unsatisfiable Formulas</p> <p>Note that it does not make sense to call a model when the conjunction of clauses which have been added to the solver is unsatisfiable. The method returns <code>null</code> in this case. If the solver is <code>UNSAT</code>, then you can compute an unsatisfiable core of the formulas on the solver by calling the <code>unsatCore()</code> method.  This method can only be called on MiniSat and Glucose when they were configured with <code>proofTracing = true</code> (this function is turned off by default).  More about this in the chapter explanations.</p>"},{"location":"documentation/solvers/sat-solving/#further-useful-methods","title":"Further Useful Methods","text":"<ul> <li>Compute the backbone of a formula using <code>backbone()</code></li> <li>Reset the solver using <code>reset()</code>, if you want to hold on to the configurations but get rid of all formulas</li> <li>Return the formula factory of this solver using <code>factory()</code></li> </ul>"},{"location":"documentation/solvers/sat-solving/#solver-configuration","title":"Solver Configuration","text":"<p>All SAT solvers implemented in LogicNG can be configured with many parameters.  MiniSat and MiniCARD can both be configured using <code>MiniSatConfig</code>, and <code>Glucose</code> can be configured using both the <code>MiniSatConfig</code> and the dedicated <code>GlucoseConfig</code>.  The parameters for the <code>GlucoseConfig</code> are those of the original implementation.  We recommend changing those only if you have an in-depth knowledge about the Glucose SAT solver.  The <code>MiniSatConfig</code> holds some LogicNG-specific parameters, which we recommend using. The other parameters are those of the original MiniSat implementation, which we again recommend to touch only if you know what you're doing. :)</p> <p>The following LogicNG specific fields in the <code>MiniSatConfig</code> can be changed:</p>"},{"location":"documentation/solvers/sat-solving/#incrementality","title":"Incrementality","text":"<p>The parameter <code>incremental</code> functions differently on MiniSat/MiniCARD vs. Glucose.  On MiniSat/MiniCARD it activates the incremental/decremental API.  So when this parameter is set to <code>true</code>, you can use the above-mentioned <code>saveState()</code> and <code>loadState()</code> methods.  Internally, this deactivates clause deletion since the save/load state functionality would not function with clause deletion.  Therefore, if you do not want to use the decremental/incremental interface, setting this parameter to <code>false</code> may yield some performance improvements.</p> <p>Glucose in LogicNG does not implement the save/load state functionality, but provides its own version of an incremental/decremental interface.  The parameter <code>incremental</code> does activate this mode on Glucose.  It is based on the idea of adding clauses with selector variables and activating and deactivating them via assumptions.  Details on this approach can be found in chapter 6 of this Glucose overview which is also a very nice overview of current techniques in modern SAT solving.</p>"},{"location":"documentation/solvers/sat-solving/#initial-phase","title":"Initial Phase","text":"<p>As mentioned above, a SAT solver has two phases: the decision phase and the deduction phase.  In the decision phase, a yet unassigned variable is chosen by some heuristics or a fixed order and then assigned to a truth value.  To which value the variable is initially set is decided by the parameter <code>initialPhase</code>.  If the parameter is set to <code>true</code>, every new variable is assigned to <code>true</code> first. Otherwise, every new variable is assigned to <code>false</code> first. In the actual (resulting) models this initial assignment can of course be changed through backtracking.  This parameter is available for all solvers.</p>"},{"location":"documentation/solvers/sat-solving/#proof-generation","title":"Proof Generation","text":"<p>The parameter <code>proofGeneration</code> indicates whether information for generating a proof is collected during the solving process.  In order to generate a proof, some internal information has to be stored during solving, therefore slowing the solving process a bit.  Therefore, the initial value for this parameter is <code>false</code>.</p> <p>Proof Generation</p> <p>Note that the parameter only steers whether this information is recorded or not.  The actual proof will only be generated when the <code>unsatCore()</code> method on the solver is called.  More information on proof tracing can be found in the chapter on explanations.  Proof tracing in LogicNG is only available for the MiniSat and Glucose solvers.</p>"},{"location":"documentation/solvers/sat-solving/#cnf-transformation","title":"CNF Transformation","text":"<p>The first step when adding a formula to a SAT solver is to transform the given formula to CNF.  The parameter <code>cnfMethod</code> decides how this is done.  There are three options:</p> <ol> <li><code>FACTORY_CNF</code>: Calls the <code>cnf()</code>-method on the formula. Thus, the CNF encoding of the underlying formula factory is used. This can be configured, see the relevant chapter.  This approach generates all CNFs on the formula factory.  If you do not need the CNF outside the SAT solver, this approach should be avoided since there is no advantage of having all the formulas on the factory.</li> <li><code>PG_ON_SOLVER</code>: Performs the Plaisted-Greenbaum transformation directly on the solver, therefore never generating the CNF on the formula factory.  However, it still generates the NNF of the formula on the factory.</li> <li><code>FULL_PG_ON_SOLVER</code>: Performs Plaisted-Greenbaum transformation directly on the solver and does not transform the formula to NNF first.</li> </ol> <p>Which CNF method to use heavily depends on the application.  Options 2. and 3. do not pollute the formula factory with the generated CNF (nor with the NNF in option 3.), but therefore do not cache the generated normal forms. Thus, if you add the formula to e.g. different solvers, the CNF/NNF will be re-generated every time.  Choosing option 1. caches both CNF and NNF in the formula factory.  Therefore, after the first computation, the normal forms are never computed again.</p> <p>This parameter is available for all solvers and is set by default to <code>PG_ON_SOLVER</code> - in our experience a good trade-off.</p>"},{"location":"documentation/solvers/sat-solving/#auxiliary-variables-in-models","title":"Auxiliary Variables in Models","text":"<p>The parameter <code>auxiliaryVariablesInModels</code> controls whether auxiliary variables which occur in the encoding of CNFs, cardinality constraints, or pseudo-Boolean constraints (e.g. <code>@RESERVED_CNF_</code>, <code>@RESERVED_CC_</code>, or <code>@RESERVED_PB_</code>) will also appear in the model which is created by the solver.  Usually one is not interested in these variables since they are generated automatically.  Therefore, this parameter is set to <code>false</code> by default.  This option is available for all solvers.</p>"},{"location":"documentation/solvers/sat-solving/#clause-minimization","title":"Clause Minimization","text":"<p>The parameter <code>clauseMin</code> controls how to minimize the learnt clauses.  This is a parameter present in the original MiniSat implementation. We mention this parameter, since it is a relatively easy way to control the solving process and can lead to performance improvements. The options are local minimization (<code>BASIC</code>), recursive minimization (<code>DEEP</code>) and no minimization (<code>NONE</code>). The parameter is available for all solvers and the default is <code>DEEP</code>.</p>"},{"location":"documentation/solvers/sat-solving/#solver-functions","title":"Solver Functions","text":"<p>Solver functions can be executed directly on the SAT solver and access its internal state.  You can implement your own functions, and some functions are implemented in LogicNG:</p> <ul> <li>FormulaOnSolverFunction returns the current formula on the solver.</li> </ul> <p>Formula on Solver</p> <p>Note that this formula is usually syntactically different from the formulas which were actually added to the solver, since the formulas are added as CNF and may be simplified or even removed, depending on the state of the solver.  Furthermore, the solver might add learnt clauses or propagate literals.  This can be useful to debug or analyze a solver at a given time.</p> <ul> <li>UpZeroLiteralsFunction returns all unit propagated literals on level 0 of the current formula on the solver.  These are direct implications from the original formula and a subset of the backbone.</li> <li>UnsatCoreFunction computes the Unsat Core if the formula is unsatisfiable. The function is used for the method <code>unsatCore()</code>.</li> <li>BackboneFunction: This function computes a backbone for the formula on the solver. The function is used for the <code>backbone()</code> call. However, here it is not possible to add a handler to the solver. This is why it can be useful to use the solver function directly.</li> <li>ModelEnumerationFunction: The solver function for model enumeration. The function is used for the <code>enumerateAllModels()</code> call. For more information see the chapter on model counting and enumeration.</li> <li>OptimizationFunction: This function can be used to compute a minimal or maximal model in the number of positive assigned literals.  I.e. when minimizing over a set of variables you can compute a model with a globally minimal number of positive assigned literals.  Of course this could be performed with MaxSAT solver, but sometimes you already have a SAT solver with the right formulas at hand, and it is more efficient to use it instead of generating a new MaxSAT solver.</li> </ul> <p>An example for the <code>OptimizationFunction</code> is the following: We want to return the assignment with a minimal number of positive literals.</p> <pre><code>Formula formula = p.parse(\"(A | B) &amp; (~C | D)\");\nsolver.add(formula);\nAssignment assignment = solver.execute(OptimizationFunction.builder()\n        .literals(f.variable(\"A\"), f.variable(\"B\"), f.variable(\"C\"))\n        .minimize()\n        .build());\n</code></pre> <p>In this example, either <code>A</code> or <code>B</code> can be set to <code>false</code> but not both.  The second clause can be satisfied by setting <code>C</code> to <code>false</code>.  Thus, two of the three desired literals can maximally be set to <code>true</code>.  The result in this case is <code>~A, B, ~C</code>. However, this result is not unique: <code>A, ~B, ~C</code> would also be an optimal solution.</p>"},{"location":"legal/corporate/","title":"Corporate Information","text":""},{"location":"legal/corporate/#name-and-address","title":"Name and Address","text":"<p>BooleWorks GmbH Radlkoferstr. 2 81373 M\u00fcnchen  GERMANY</p>"},{"location":"legal/corporate/#represented-by","title":"Represented By","text":"<p>Dr. Christoph Zengler, CEO</p>"},{"location":"legal/corporate/#legal-information","title":"Legal Information","text":"<ul> <li>Commercial Register: HRB 240898</li> <li>Registration Court: Munich District Court</li> <li>VAT: DE318312876</li> </ul>"},{"location":"legal/corporate/#contact","title":"Contact","text":"<ul> <li>BooleWorks:  info@booleworks.com</li> <li>LogicNG:  christoph@logicng.org</li> </ul>"},{"location":"legal/privacy/","title":"Privacy Policy","text":""},{"location":"legal/privacy/#github-pages","title":"GitHub Pages","text":"<p>This Website is hosted on GitHub Pages. GitHub may collect personal information from visitors, including logs of visitor IP addresses. See the GitHub Privacy Statement for details.</p>"},{"location":"legal/privacy/#data-collection-and-cookies","title":"Data Collection and Cookies","text":"<p>This website does not use website analytics, does not store any user data, and does not use cookies.</p>"},{"location":"legal/privacy/#links","title":"Links","text":"<p>This website contains links to other sites. We link to:</p> <ul> <li>GitHub for code and documentation repositories and our corporate profile</li> <li>LinkedIn for our corporate profile</li> </ul> <p>Additional links might occur in the documentation.</p>"},{"location":"tutorial/","title":"LogicNG Tutorial","text":"<p>This tutorial offers a gentle introduction into the usage and algorithms of LogicNG. We accompany Beatrice, the founder of a bike shop, by facing different incidents.</p> <p>Along this, we proceed from modelling a real-world problem into a configuration problem that can be solved with LogicNG to using the efficient SAT- and MaxSAT-solvers in LogicNG.</p> <p>In the tutorial, you will see applications for the following content:</p> <ul> <li>Formulate a real-world problem in LogicNG-syntax in chapter 1</li> <li>Different operations that you can perform on formulas, such as substituting the formulas or restricting the ruleset in chapter 2</li> <li>An example for formula functions for analyzing the rule set in chapter 3</li> <li>Propositions, what they are and how to use them in chapter 4</li> <li>SAT Solving, including backbones, explanations and model enumeration and counting in chapter 5</li> <li>MaxSAT Solving in chapter 6</li> </ul> <p>The code for this can be found under doc/tutorial/BicycleShopTutorial.java. Have fun!</p>"},{"location":"tutorial/chapter1/","title":"Tutorial Chapter 1","text":""},{"location":"tutorial/chapter1/#configuring-a-bike","title":"Configuring a Bike","text":"<p>The brand-new shop Build 'n Bike pursues a new business idea: It is the first shop in Boolea which offers customers to build their bike completely from scratch.</p> <p>The customers can configure their bike with the following components:</p> Component Feature Class Features Frame <code>frame</code> <code>f1</code> (carbon), <code>f2</code> (aluminium), <code>f3</code> (steel) Handlebar <code>handlebar</code> <code>h1</code> (cruiser bar),  <code>h2</code>  (drop bar), <code>h3</code> (touring  bar), <code>h4</code> (flat bar), <code>h5</code> (aero bar) Saddle <code>saddle</code> <code>s1</code> (touring), <code>s2</code> (comfort), <code>s3</code> (triathlon), <code>s4</code> (pro) Front wheel <code>frontWheel</code> <code>wf1</code> (24 inch), <code>wf2</code> (26 inch), <code>wf3</code> (27.5 inch), <code>wf4</code> (29 inch), <code>wf5</code> (32 inch) Back wheel <code>backWheel</code> <code>wb1</code> (24 inch), <code>wb2</code> (26 inch), <code>wb3</code> (27.5 inch), <code>wb4</code> (29 inch), <code>wb5</code> (32 inch) Bike bell <code>bell</code> <code>b1</code> (classic), <code>b2</code> (metal strip), <code>b3</code> (ladybug) Luggage rack <code>luggageRack</code> <code>r1</code> (aluminium), <code>r2</code> (titanium), <code>r3</code> (steel), <code>r4</code> (minimalistic) Color <code>color</code> <code>c1</code> (blue), <code>c2</code> (red), <code>c3</code> (white), <code>c4</code> (silver) <p>Beatrice, the founder of Build 'n Bike, did a course in propositional logic at university. She knows that for the configuration to result in a working bike, there are a couple of rules which have to be fulfilled.  Firstly, every bike needs:</p> <ul> <li>exactly one frame</li> <li>exactly one handlebar</li> <li>exactly one saddle</li> <li>exactly one front wheel</li> <li>exactly one back wheel</li> <li>exactly one color</li> <li>at most one bike bell</li> <li>at most one luggage rack</li> </ul> <p>She writes the rules down concisely:</p> <pre><code>f &lt;=&gt; f1 | f2 | f3\nf1 + f2 + f3 = 1\n\nh &lt;=&gt; h1 | h2 | h3 | h4 | h5\nh1 + h2 + h3 + h4 + h5= 1\n\ns &lt;=&gt; s1 | s2 | s3 | s4\ns1 + s2 + s3 + s4 = 1\n\nwf &lt;=&gt; wf1 | wf2 | wf3 | wf4 | wf5\nwf1 + wf2 + wf3 + wf4 + wf5 = 1\n\nwb &lt;=&gt; wb1 | wb2 | wb3 | wb4 | wb5\nwb1 + wb2 + wb3 + wb4 + wb5 = 1\n\nb &lt;=&gt; b1 | b2 | b3\nb1 + b2 + b3 &lt;= 1\n\nr &lt;=&gt; r1 | r2 | r3 | r4\nr1 + r2 + r3 + r4 &lt;= 1\n\nc &lt;=&gt; c1 | c2 | c3 | c4\nc1 + c2 + c3 + c4 = 1\n</code></pre> <p>The first type of formulas, e.g. <code>f &lt;=&gt; f1 | f2 | f3</code> is called an equivalence and can be read as an <code>if and only if</code> statement: A frame <code>f</code> is contained in the bike if and only if one of the frames <code>f1</code>, <code>f2</code> or <code>f3</code> are contained.</p> <p>The second type of formulas is called cardinality constraints. For example, <code>f1 + f2 + f3 = 1</code> is read as: Exactly one of the features <code>f1</code>, <code>f2</code> and <code>f3</code> has to be contained in the bike.  For more information check out the relevant section in the documentation.</p> <p>Further, with an intuitive understanding for bikes, Beatrice knows the following rules:</p> <ul> <li>if you take the carbon frame, you cannot take the touring saddle and you cannot take the touring bar: <code>f1 =&gt; ~s1 &amp; ~h3</code></li> <li>if you take the carbon frame, you can either take no luggage rack or the minimalistic luggage rack: <code>f1 =&gt; ~r | r4</code></li> <li>if you take the steel frame, you may not take the aero bar: <code>f3 =&gt; ~h5</code></li> <li>if you take the aero bar, you may not take a bike bell: <code>h5 =&gt; ~b</code></li> <li>if you take the minimalistic luggage rack, you may not take the bike bell with a metal strip, or you have to take the aluminium or the steel frame: <code>r4 =&gt; ~b2 | f2 | f3</code></li> <li>front and back wheel must fit together:</li> <li>you can take the front wheel of size 24-inch if and only if you take the back wheel of that size: <code>wf1 &lt;=&gt; wb1</code></li> <li>you can take front wheel of size 26-inch if and only if you take the back wheel of that size: <code>wf2 &lt;=&gt; wb2</code></li> <li>you can take front wheel of size 27.5-inch if and only if you take the back wheel of that size: <code>wf3 &lt;=&gt; wb3</code></li> <li>you can take front wheel of size 29-inch if and only if you take the back wheel of that size: <code>wf4 &lt;=&gt; wb4</code></li> <li>you can take front wheel of size 32-inch if and only if you take the back wheel of that size: <code>wf5 &lt;=&gt; wb5</code></li> <li>all frames need wheels of size 26 - 32 inch: <code>f =&gt; wf2 | wf3 | wf4 | wf5</code></li> <li>if you take the oversized wheels with 32-inch, you need a stable frame: You need to take the steel frame <code>f3</code>: <code>wf5 =&gt; f3</code></li> </ul> <p>Note that the last two rules can be written as concisely as they are because of the restrictions on \"front and back wheel must fit together\", so it suffices to make the rule for one of the wheels.  Written concisely, the rules are the following:</p> <pre><code>f1 =&gt; ~s1 &amp; ~h3\nf1 =&gt; ~r | r4\nf3 =&gt; ~h5\nh5 -&gt; ~b\nr4 =&gt; ~b2 | f2 | f3\nwf1 &lt;=&gt; wb1\nwf2 &lt;=&gt; wb2\nwf3 &lt;=&gt; wb3\nwf4 &lt;=&gt; wb4\nwf5 &lt;=&gt; wb5\nf =&gt; wf2 | wf3 | wf4 | wf5\nwf5 =&gt; f3\n</code></pre>"},{"location":"tutorial/chapter1/#translating-the-problem-in-java-code","title":"Translating the Problem in Java Code:","text":"<p>To use LogicNG, you always have to create a formula factory first.  The formula factory is used to create new variables, formulas, and so on, and is a very central concept in LogicNG, so after this tutorial, wie recommend reading its documentation.</p> <pre><code>FormulaFactory f = new FormulaFactory();\n</code></pre> <p>To parse formula strings you need a formula parser. In this tutorial we use the pseudo-Boolean parser which can be created with the previously created formula factory instance as follows:</p> <pre><code>PseudoBooleanParser p = new PseudoBooleanParser(f);\n</code></pre>"},{"location":"tutorial/chapter1/#specifying-that-each-configuration-contains-the-right-components","title":"Specifying that each configuration contains the right components","text":"<p>The first step for translating the problem into Java code is to specify that each configuration contains exactly one frame, one handlebar, at most one bike bell, etc.</p> <p>We show here how to specify rules that ensure that the configuration contains exactly one frame and at most one bike bell. The process is analogous for the other components.</p> <p>We begin by defining the variables. A variable with name <code>name</code> in LogicNG can be created using <code>f.variable(\"name\")</code>.</p> <pre><code>// frames\nVariable frame = f.variable(\"frame\"); // (1)!\nVariable f1 = f.variable(\"f1\");\nVariable f2 = f.variable(\"f2\");\nVariable f3 = f.variable(\"f3\");\n\n// bike bells\nVariable bell = f.variable(\"bell\"); // (2)!\nVariable b1 = f.variable(\"b1\");\nVariable b2 = f.variable(\"b2\");\nVariable b3 = f.variable(\"b3\");\n</code></pre> <ol> <li>variables for the feature class <code>frame</code> and frame 1, 2, and 3</li> <li>variables for the feature class <code>bell</code> and bell 1, 2, and 3</li> </ol> <p>Next, we define equivalence and cardinality constraints based on these variables, ensuring that exactly one frame and at most one bike bell is configured.  One way to do this is to parse the relevant formulas:</p> <pre><code>Formula f_equiv = p.parse(\"frame &lt;=&gt; f1 | f2 | f3\"); // (1)!\nFormula f_exo = p.parse(\"f1 + f2 + f3 = 1\"); // (2)!\n\nFormula b_equiv = p.parse(\"bell &lt;=&gt; b1 | b2 | b3\"); // (3)!\nFormula b_exo = p.parse(\"b1 + b2 + b3 &lt;= 1\"); // (4)!\n</code></pre> <ol> <li>a frame is configured if and only if one of f1, f2 and f3 is chosen</li> <li>exactly one of f1, f2 and f3 has to be chosen</li> <li>a bike bell is configured if and only if one of b1, b2 and b3 is chosen</li> <li>at most one of b1, b2 and b3 has to be chosen</li> </ol> <p>Another way to do this is to use the built-in functions from the formula factory: Equivalences can be created using <code>f.equivalence()</code> and exactly-one constraints can be generated using <code>f.exo()</code>. At-most-one constraints can be created using <code>f.amo()</code>.</p> <pre><code>Formula f_equiv = f.equivalence(frame, f.or(f1, f2, f3)); // (1)!\nFormula f_exo = f.exo(f1, f2, f3); // (2)!\n\nFormula b_equiv = f.equivalence(bell, f.or(b1, b2, b3));\nFormula b_amo = f.amo(b1, b2, b3); // (3)!\n</code></pre> <ol> <li>using the <code>equivalence</code> built-in function</li> <li>using the <code>exo</code> built-in function</li> <li>using the <code>amo</code> built-in function</li> </ol>"},{"location":"tutorial/chapter1/#specifying-inclusions-exclusions-and-equivalences","title":"Specifying inclusions, exclusions and equivalences","text":"<p>The second step for translating the problem into Java code is to encode the additional formulas. Again, we show how to encode formulas based on two examples, as the others are modelled analogously.</p> <p>Consider the first and the 6th formula (first examples for implication and equivalence): - If you take the carbon frame, you cannot take the touring saddle and you cannot take the touring bar: <code>f1 =&gt; ~s1 &amp; ~h3</code> - You can take the front wheel of size 24-inch if and only if you take the back wheel of that size: <code>wf1 &lt;=&gt; wb1</code></p> <p>Again, one can create these formulas either by parsing the string or by using the built-in functions from the formula factory.</p> <p>Parsing the formulas can be done in the following way:</p> <pre><code>Formula formula1 = p.parse(\"f1 =&gt; ~s1 &amp; ~h3\"); // (1)!\nFormula formula6 = p.parse(\"wf1 &lt;=&gt; wb1\");\n</code></pre> <ol> <li>generate formulas by parsing a string</li> </ol> <p>The relevant built-in functions are the following:</p> <p>A literal is a variable and its polarity (positive/negative) and can be created directly using <code>f.literal(\"v\", true)</code> for <code>v</code> or <code>f.literal(\"v\", false)</code> for <code>~v</code>.  A variable <code>v</code> (or generally any formula) can be negated with <code>v.negate()</code>.  Conjunctions (an And) can be created using <code>f.and(s1.negate(), h3.negate())</code>, meaning the conjunction of not saddle 1 and not handlebar 3. Similarly, disjunctions (an Or) can be created using <code>f.or(s1, s2)</code>, meaning the disjunction of saddle 1 and saddle 2.  Implications can be created using <code>f.implication()</code>. For an exclusion the right-hand side has to be negated.</p> <p>Therefore, the formulas can also be generated in the following way:</p> <pre><code>Formula formula1 = f.implication(f1, f.and(s1.negate(), h3.negate())); // (1)!\nFormula formula6 = f.equivalence(wf1, wb1);\n</code></pre> <ol> <li>generate using the built-in functions</li> </ol> <p>For more information on generating formulas check out the chapter on formula factories and for information about properties and useful methods the chapter on Formulas.</p> <p>The total rules are the following, using built-in functions:</p> <pre><code>Formula formula1 = f.implication(f1, f.and(s1.negate(), h3.negate()));\nFormula formula2 = f.implication(f1, f.or(luggageRack.negate(), r4));\nFormula formula3 = f.implication(f3, h5.negate());\nFormula formula4 = f.implication(h5, bell.negate());\nFormula formula5 = f.implication(r4, f.or(b2.negate(), f2, f3));\n\nFormula formula6 = f.equivalence(wf1, wb1);\nFormula formula7 = f.equivalence(wf2, wb2);\nFormula formula8 = f.equivalence(wf3, wb3);\nFormula formula9 = f.equivalence(wf4, wb4);\nFormula formula10 = f.equivalence(wf5, wb5);\n\nFormula formula11 = f.implication(frame, f.or(wf2, wf3, wf4, wf5));\nFormula formula12 = f.implication(wf5, f3);\n</code></pre> <p>The set of formulas which form the base for the rest of the tutorial is the conjunction of all rules; rules for each component and additional rules:</p> <pre><code>List&lt;Formula&gt; formulas = Arrays.asList(f_equiv, f_exo, h_equiv, h_exo, s_equiv,\n        s_exo, wf_equiv, wf_exo, wb_equiv, wb_exo, b_equiv, b_amo, r_equiv,\n        r_amo, c_equiv, c_exo, formula1, formula2, formula3, formula4, formula5,\n        formula6, formula7, formula8, formula9, formula10, formula11, formula12);\n</code></pre> <p>All variables and formulas and the overall set of rules are defined as fields in the class <code>BicycleShopData</code>.</p> <p>For the reminder of the tutorial, we introduce an object of this class:</p> <pre><code>BicycleShopData data = new BicycleShopData();\n</code></pre> <p>and will access fields of this class for example with <code>data.formulas</code>.</p>"},{"location":"tutorial/chapter2/","title":"Tutorial Chapter 2","text":"<p>In the example in the previous chapter we introduced a lot of variables and formulas. In this chapter, we will have a closer look at what one can do with formulas.</p>"},{"location":"tutorial/chapter2/#substituting-formulas","title":"Substituting Formulas:","text":"<p>Beatrice sometimes mixes up how big the different wheels are. Therefore, she decides to substitute the variables for the front and back wheel for variables whose name includes their size.</p> <p>She replaces:</p> <ul> <li><code>wf1</code> \u2192 <code>wf24</code></li> <li><code>wf2</code> \u2192 <code>wf26</code></li> <li><code>wf3</code> \u2192 <code>wf27</code> for the front wheel of size 27.5 inch</li> <li><code>wf4</code> \u2192 <code>wf29</code></li> <li><code>wf5</code> \u2192 <code>wf32</code></li> </ul> <p>and</p> <ul> <li><code>wb1</code> \u2192 <code>wb24</code></li> <li><code>wb2</code> \u2192 <code>wb26</code></li> <li><code>wb3</code> \u2192 <code>wb27</code> for the back wheel of size 27.5 inch</li> <li><code>wb4</code> \u2192 <code>wb29</code></li> <li><code>wb5</code> \u2192 <code>wb32</code></li> </ul> <p>Beatrice substitutes the variables in the following way (c.f. the function <code>substituteLiterals</code> in the Tutorial):</p> <pre><code>final Substitution substitution = new Substitution();\nsubstitution.addMapping(f.variable(\"wf1\"), f.variable(\"wf24\"));\nsubstitution.addMapping(f.variable(\"wf2\"), f.variable(\"wf26\"));\nsubstitution.addMapping(f.variable(\"wf3\"), f.variable(\"wf27\"));\nsubstitution.addMapping(f.variable(\"wf4\"), f.variable(\"wf29\"));\nsubstitution.addMapping(f.variable(\"wf5\"), f.variable(\"wf32\"));\n\nsubstitution.addMapping(f.variable(\"wb1\"), f.variable(\"wb24\"));\nsubstitution.addMapping(f.variable(\"wb2\"), f.variable(\"wb26\"));\nsubstitution.addMapping(f.variable(\"wb3\"), f.variable(\"wb27\"));\nsubstitution.addMapping(f.variable(\"wb4\"), f.variable(\"wb29\"));\nsubstitution.addMapping(f.variable(\"wb5\"), f.variable(\"wb32\"));\n\nfinal List&lt;Formula&gt; substituted = data.formulas.stream()\n        .map(formula -&gt; formula.substitute(substitution))\n        .collect(Collectors.toList());\n</code></pre> <p>The result is the rule set in terms of the new variables:</p> <pre><code>frame &lt;=&gt; f1 | f2 | f3, f1 + f2 + f3 = 1\nhandlebar &lt;=&gt; h1 | h2 | h3 | h4 | h5\nh1 + h2 + h3 + h4 + h5 = 1\nsaddle &lt;=&gt; s1 | s2 | s3 | s4\ns1 + s2 + s3 + s4 = 1\nfrontWheel &lt;=&gt; wf24 | wf26 | wf27 | wf29 | wf32\nwf24 + wf26 + wf27 + wf29 + wf32 = 1\nbackWheel &lt;=&gt; wb24 | wb26 | wb27 | wb29 | wb32\nwb24 + wb26 + wb27 + wb29 + wb32 = 1\nbell &lt;=&gt; b1 | b2 | b3\nb1 + b2 + b3 &lt;= 1\nluggageRack &lt;=&gt; r1 | r2 | r3 | r4\nr1 + r2 + r3 + r4 &lt;= 1\ncolor &lt;=&gt; c1 | c2 | c3 | c4\nc1 + c2 + c3 + c4 = 1\nf1 =&gt; ~s1 &amp; ~h3\nf1 =&gt; ~luggageRack | r4\nf3 =&gt; ~h5\nh5 =&gt; ~bell\nr4 =&gt; ~b2 | f2 | f3\nwf24 &lt;=&gt; wb24\nwf26 &lt;=&gt; wb26\nwf27 &lt;=&gt; wb27\nwf29 &lt;=&gt; wb29\nwf32 &lt;=&gt; wb32\nframe =&gt; wf26 | wf27 | wf29 | wf32\nwf32 =&gt; f3\n</code></pre>"},{"location":"tutorial/chapter2/#restricting-formulas","title":"Restricting Formulas:","text":"<p>Due to a global pandemic, there are issues with the supply chain.  Beatrice's supplier of trust Super Supplier cannot deliver a couple of components:  Back wheel 24-inch <code>wb24</code> and color <code>c3</code> are out of stock. However, Super Supplier delivered a lot of the minimalistic luggage racks <code>r4</code>.</p> <p>How can she still configure valid bikes with the given restrictions? She decides that all bikes from now on</p> <ul> <li>may not have the back wheel <code>wb24</code> or color <code>c3</code></li> <li>must have the minimalistic luggage rack <code>r4</code>, since her little storage space will otherwise be cram-full within a couple of days.</li> </ul> <p>Beatrice restricts the set of rules in the following way:</p> <ul> <li><code>wb24</code> and <code>c3</code> are not allowed (set to <code>false</code>)</li> <li><code>r4</code> must be contained (set to <code>true</code>).</li> </ul> <p>See the function <code>restrictRuleset</code> in the tutorial code, how to do this:</p> <pre><code>final Assignment assignment = new Assignment();\n\nassignment.addLiteral(data.f.variable(\"wb24\").negate());\nassignment.addLiteral(data.c3.negate()); // (1)!\nassignment.addLiteral(data.r4);\n\nfinal List&lt;Formula&gt; restricted = formulas.stream()\n        .map(formula -&gt; formula.restrict(assignment))\n        .collect(Collectors.toList());\n</code></pre> <ol> <li>cheap color sold out</li> </ol> <p>The result is the following rule set:</p> <pre><code>frame &lt;=&gt; f1 | f2 | f3\nf1 + f2 + f3 = 1\nhandlebar &lt;=&gt; h1 | h2 | h3 | h4 | h5\nh1 + h2 + h3 + h4 + h5 = 1\nsaddle &lt;=&gt; s1 | s2 | s3 | s4\ns1 + s2 + s3 + s4 = 1\nfrontWheel &lt;=&gt; wf24 | wf26 | wf27 | wf29 | wf32\nwf24 + wf26 + wf27 + wf29 + wf32 = 1\nbackWheel &lt;=&gt; wb26 | wb27 | wb29 | wb32\nwb26 + wb27 + wb29 + wb32 = 1\nbell &lt;=&gt; b1 | b2 | b3\nb1 + b2 + b3 &lt;= 1\nluggageRack\nr1 + r2 + r3 &lt;= 0\ncolor &lt;=&gt; c1 | c2 | c4\nc1 + c2 + c4 = 1\nf1 =&gt; ~s1 &amp; ~h3\n$true\nf3 =&gt; ~h5\nh5 =&gt; ~bell\n~b2 | f2 | f3\n~wf24\nwf26 &lt;=&gt; wb26\nwf27 &lt;=&gt; wb27\nwf29 &lt;=&gt; wb29\nwf32 &lt;=&gt; wb32\nframe =&gt; wf26 | wf27 | wf29 | wf32\nwf32 =&gt; f3\n</code></pre> <p>The following rules have changed:</p> Rule Restricted Rule Explanation <code>luggageRack &lt;=&gt; r1 | r2 | r3 | r4</code> <code>luggageRack</code> since  <code>r4</code> is chosen, a luggage rack is taken <code>r1 + r2 + r3 + r4 &lt;= 1</code> <code>r1 + r2 + r3 &lt;= 0</code> since <code>r4</code> is chosen, none of <code>r1</code>, <code>r2</code> and <code>r3</code> may be chosen too <code>color &lt;=&gt; c1 | c2 | c3 | c4</code> <code>color &lt;=&gt; c1 | c2 | c4</code> <code>~c3</code> is a restriction <code>c1 + c2 + c3 + c4 = 1</code> <code>c1 + c2 + c4 = 1</code> <code>~c3</code> is a restriction <code>f1 =&gt; ~luggageRack | r4</code> <code>$true</code> the right hand side is always <code>true</code>, since <code>r4</code> is chosen <code>r4 =&gt; ~b2 | f2 | f3</code> <code>~b2 | f2 | f3</code> the left hand side is satisfied, thus the right hand part has to hold <code>wf24 &lt;=&gt; wb24</code> <code>~wf24</code> <code>~wb24</code> is a restriction <p>Two remarks: 1. When a formula restricts to <code>$true</code> this means it is always fullfilled and therefore can be ommitted.  If a formula would restrict to <code>$false</code> the whole rule set would be contradictionary. 2. The restricted second rule <code>r1 + r2 + r3 &lt;= 0</code> is equivalent to <code>~r1 &amp; ~r2 &amp; ~r3</code>.</p> <p>Beatrice translates the changes of the rule set for the next customer.  The updated rules are the following:</p> <ul> <li>you must choose the luggage rack <code>r4</code> and may not choose any of <code>r1</code>, <code>r2</code>, <code>r3</code></li> <li>you must take exactly one of the colors <code>c1</code>, <code>c2</code>, <code>c4</code></li> <li>either you do not take the bike bell <code>b2</code> or you take frame 2 <code>f2</code> or you take <code>f3</code></li> <li>you may not take front wheel with 24-inch <code>wf24</code></li> </ul> <p>More information about substituting and restricting formulas can be found in the relevant section in the documentation.</p>"},{"location":"tutorial/chapter3/","title":"Tutorial Chapter 3","text":"<p>Beatrice wants to analyze her rule set. In particular, she is interested in the variable distribution: How often do given variables each occur in the set of rules?</p> <p>Luckily for her there is a LogicNG function to count the number of occurrences of each variable in a formula: <code>VariableProfileFunction</code> (c.f. the function <code>getVariableOccurrences</code> in the tutorial code). Beatrice uses the <code>VariableProfileFunction</code> in the following way:</p> <pre><code>Map&lt;Variable, Integer&gt; variables2Occurrences =\n        data.f.and(formulas).apply(new VariableProfileFunction());\n\nSortedMap&lt;Integer, List&lt;Variable&gt;&gt; occurrences2Vars = new TreeMap&lt;&gt;();\nvariables2Occurrences.forEach((var, occ) -&gt;\n        occurrences2Vars.computeIfAbsent(occ, y -&gt; new ArrayList&lt;&gt;()).add(var));\n</code></pre> <p>The <code>VariableProfileFunction</code> computes a map from each variable to its occurrence:</p> <pre><code>{r3=1, r2=1, color=1, saddle=1, h1=2, frontWheel=1, h3=3, f1=3, h2=2, h5=4, f3=5,\n h4=2, f2=3, b1=2, luggageRack=1, b3=2, b2=3, wf32=5, wb32=3, s2=2, s1=3, wf29=4,\n s4=2, s3=2, wf27=4, wb29=3, wf26=4, wb27=3, wf24=3, backWheel=1, bell=2, c2=2,\n c1=2, c4=2, handlebar=1, wb26=3, r1=1, frame=2}\n</code></pre> <p>In order to sort the variables by the number of their occurrences, she creates the map <code>occurrences2Vars</code>.  The result is:</p> <pre><code>{\n 1=[r3, r2, color, saddle, frontWheel, luggageRack, backWheel, handlebar, r1],\n 2=[h1, h2, h4, b1, b3, s2, s4, s3, bell, c2, c1, c4, frame],\n 3=[h3, f1, f2, b2, wb32, s1, wb29, wb27, wf24, wb26],\n 4=[h5, wf29, wf27, wf26], 5=[f3, wf32]\n}\n</code></pre> <p>For more information about formula functions check out the relevant chapter in the documentation.</p>"},{"location":"tutorial/chapter4/","title":"Tutorial Chapter 4","text":"<p>Beatrice wants to transform the rules in her rule set into so-called <code>Propositions</code>. These are objects which contain the formula, and some additional information for the formula.  This can be very useful to add additional information to formulas which are not relevant for logical computations but for interpreting results of algorithms and mapping formulas to original domain objects.</p> <p>In LogicNG, the abstract class <code>Proposition</code> is implemented by the <code>StandardProposition</code> and the <code>ExtendedProposition</code>.  The <code>StandardProposition</code> stores the formula and optionally a description, and the <code>ExtendedProposition</code> stores the formula and a freely defined backpack, which is an implementation of the interface <code>PropositionBackpack</code>.</p> <p>For a bike rule set, Beatrice finds that every formula should be equipped with an ID and the date on which it was created. Thus, she generates the backpack which she is going to add to the formula in the following way:</p> <pre><code>class MyBackpack implements PropositionBackpack {\n    private final long id;\n    private final LocalDate date;\n\n    MyBackpack(long id, LocalDate date) {\n        this.id = id;\n        this.date = date;\n    }\n}\n</code></pre> <p>Next, she creates propositions for every formula in her rule set. For this, she has the following logic:</p> <ul> <li>IDs are integers, starting with 0.</li> <li>For the creation date, luckily, she recalls when she created the different formulas which constitute the rule set:<ul> <li>She first created formulas of type \"exactly one\" and \"at most one\", and that was on the 01.01.2020.</li> <li>Then she created the other formulas, that was on the 01.06.2020.</li> <li>The pro saddle <code>s4</code> only came out in 2021, in fact on the 01.01.2021. Thus, every formula containing <code>s4</code> could have only been created then.</li> <li>The bike bell <code>b2</code> only came out recently, in fact on the 01.01.2022. Thus, every formula containing <code>b2</code> could have only been created then.</li> </ul> </li> </ul> <p>For example, the proposition for <code>f_equiv</code> (<code>frame &lt;=&gt; f1 | f2 | f3</code>), would be the following:</p> <pre><code>Proposition proposition = new ExtendedProposition&lt;&gt;(\n        new MyBackpack(1, LocalDate.of(2020, 1, 1)),\n        data.f_equiv\n      );\n</code></pre> <p>The following method transforms the current formulas to the propositions extended with the additional information.</p> <pre><code>public static List&lt;Proposition&gt; getPropositions(\n        BicycleShopData data,\n        List&lt;Formula&gt; formulas\n) {\n    long id = 0;\n    List&lt;Proposition&gt; propositions = new ArrayList&lt;&gt;();\n    for (Formula formula : formulas) {\n        LocalDate date;\n        if (formula.variables().contains(data.s4)) {\n            date = LocalDate.of(2021, 1, 1); // (1)!\n        } else if (formula.variables().contains(data.b2)) {\n            date = LocalDate.of(2022, 1, 1); // (2)!\n        } else if (formula.type() == FType.PBC) {\n            date = LocalDate.of(2020, 1, 1); // (3)!\n        } else {\n            date = LocalDate.of(2020, 6, 1); // (4)!\n        }\n        Proposition proposition = new ExtendedProposition&lt;&gt;(\n                new MyBackpack(id, date), formula); // (5)!\n        propositions.add(proposition);\n        id++;\n    }\n    return propositions;\n}\n</code></pre> <ol> <li>formulas for the pro saddle</li> <li>formulas for the metal strip bike bell</li> <li>exo and amo constraints</li> <li>implications and exclusions</li> <li>create a new proposition</li> </ol> <p>The result is the list of propositions:</p> <pre><code>ExtendedProposition{formula=frame &lt;=&gt; f1 | f2 | f3, backpack=MyBackpack{id=0, date=2020-06-01}}\nExtendedProposition{formula=f1 + f2 + f3 = 1, backpack=MyBackpack{id=1, date=2020-01-01}}\nExtendedProposition{formula=handlebar &lt;=&gt; h1 | h2 | h3 | h4 | h5, backpack=MyBackpack{id=2, date=2020-06-01}}\nExtendedProposition{formula=h1 + h2 + h3 + h4 + h5 = 1, backpack=MyBackpack{id=3, date=2020-01-01}}\nExtendedProposition{formula=saddle &lt;=&gt; s1 | s2 | s3 | s4, backpack=MyBackpack{id=4, date=2021-01-01}}\nExtendedProposition{formula=s1 + s2 + s3 + s4 = 1, backpack=MyBackpack{id=5, date=2021-01-01}}\nExtendedProposition{formula=frontWheel &lt;=&gt; wf24 | wf26 | wf27 | wf29 | wf32, backpack=MyBackpack{id=6, date=2020-06-01}}\nExtendedProposition{formula=wf24 + wf26 + wf27 + wf29 + wf32 = 1, backpack=MyBackpack{id=7, date=2020-01-01}}\nExtendedProposition{formula=backWheel &lt;=&gt; wb26 | wb27 | wb29 | wb32, backpack=MyBackpack{id=8, date=2020-06-01}}\nExtendedProposition{formula=wb26 + wb27 + wb29 + wb32 = 1, backpack=MyBackpack{id=9, date=2020-01-01}}\nExtendedProposition{formula=bell &lt;=&gt; b1 | b2 | b3, backpack=MyBackpack{id=10, date=2022-01-01}}\nExtendedProposition{formula=b1 + b2 + b3 &lt;= 1, backpack=MyBackpack{id=11, date=2022-01-01}}\nExtendedProposition{formula=luggageRack, backpack=MyBackpack{id=12, date=2020-06-01}}\nExtendedProposition{formula=r1 + r2 + r3 &lt;= 0, backpack=MyBackpack{id=13, date=2020-01-01}}\nExtendedProposition{formula=color &lt;=&gt; c1 | c2 | c4, backpack=MyBackpack{id=14, date=2020-06-01}}\nExtendedProposition{formula=c1 + c2 + c4 = 1, backpack=MyBackpack{id=15, date=2020-01-01}}\nExtendedProposition{formula=f1 =&gt; ~s1 &amp; ~h3, backpack=MyBackpack{id=16, date=2020-06-01}}\nExtendedProposition{formula=$true, backpack=MyBackpack{id=17, date=2020-06-01}}\nExtendedProposition{formula=f3 =&gt; ~h5, backpack=MyBackpack{id=18, date=2020-06-01}}\nExtendedProposition{formula=h5 =&gt; ~bell, backpack=MyBackpack{id=19, date=2020-06-01}}\nExtendedProposition{formula=~b2 | f2 | f3, backpack=MyBackpack{id=20, date=2022-01-01}}\nExtendedProposition{formula=~wf24, backpack=MyBackpack{id=21, date=2020-06-01}}\nExtendedProposition{formula=wf26 &lt;=&gt; wb26, backpack=MyBackpack{id=22, date=2020-06-01}}\nExtendedProposition{formula=wf27 &lt;=&gt; wb27, backpack=MyBackpack{id=23, date=2020-06-01}}\nExtendedProposition{formula=wf29 &lt;=&gt; wb29, backpack=MyBackpack{id=24, date=2020-06-01}}\nExtendedProposition{formula=wf32 &lt;=&gt; wb32, backpack=MyBackpack{id=25, date=2020-06-01}}\nExtendedProposition{formula=frame =&gt; wf26 | wf27 | wf29 | wf32, backpack=MyBackpack{id=26, date=2020-06-01}}\nExtendedProposition{formula=wf32 =&gt; f3, backpack=MyBackpack{id=27, date=2020-06-01}}\n</code></pre> <p>Beatrice is pleased.  It is more intuitive to work and it will be way easier to understand conflicts arising in her rule set with these propositions than with the original formulas.  For more information about Propositions, check out the relevant chapter in the documentation.</p> <p>If you're interested in what Beatrice is doing with those propositions, check out the next chapter on SAT solving.</p>"},{"location":"tutorial/chapter5/","title":"Tutorial Chapter 5","text":"<p>A large part of LogicNG is SAT Solving. In their most basic variant, SAT Solvers can compute whether a formula is satisfiable or not.  However, there are many algorithms which can compute more complex things by iteratively calling and modifying a SAT Solver.  Also, LogicNG provides many extensions to common SAT solvers which help solving real world problems.</p> <p>In this chapter we present five use cases for a SAT solver:</p> <ol> <li>Beatrice checks for the customer Sarah whether her desired configuration is satisfiable. Since it is satisfiable, she also completes her order.</li> <li>Beatrice checks for the customer Clemens whether his desired configuration is buildable. Since it is not buildable, she computes the reason for it.</li> <li>Beatrice wonders what configuration options there are, if she decides on a certain wheel size.</li> <li>Beatrice checks how many bike configurations she can sell overall, and how many configurations exist for a common combinations of features.</li> <li>Beatrice checks what the bike configuration with the minimum and maximum number of variables is.</li> </ol> <p>Along this chapter, we will cover the following related topics:</p> <ul> <li>The two techniques for incremental SAT solving (assumption solving and solving with save/load state)</li> <li>The difference between a satisfiable and a complete order</li> <li>Explanations for when the solver returns \"UNSAT\"</li> <li>Backbone computation</li> <li>Model counting and enumeration, projected model enumeration</li> <li>Performing functions on the solver</li> </ul>"},{"location":"tutorial/chapter5/#solving-with-assumptions","title":"Solving with Assumptions","text":"<p>The first customer, a young woman called Sarah, enters the shop.  After studying the feature table shortly, she claims that she knows exactly what she wants out of a bike.  Sarah wants the carbon frame <code>f1</code> in red <code>c2</code>, the drop bar <code>h2</code>, 26-inch front wheel <code>wf26</code> and the cute ladybug bike bell <code>b3</code>.</p> <p>\"Alright, let's see what we can do\", Beatrice concedes.</p> <p>Beatrice evaluates the set of rules that she has for configuring a bike with a SAT solver.</p> <pre><code>SATSolver solver = MiniSat.miniSat(data.f);\npropositions.forEach(solver::add);\n\nList&lt;Literal&gt; wishedFeaturesSarah = new ArrayList&lt;&gt;(Arrays.asList(\n        data.f1, data.c2, data.h2, data.f.variable(\"wf26\"), data.b3));\nTristate sat = solver.sat(wishedFeaturesSarah);\n</code></pre> <p>The result is <code>TRUE</code>, meaning that this configuration is satisfiable. That is, a bike with the features that Sarah requested is buildable. (We use \"satisfiable\" and \"buildable\" equivalently - Satisfiable is the mathematical term, and buildable is closer to the use case of bike configuration.)</p> <p>However, this is different from saying that the requested features result in a valid bike.  Sarah's order is satisfiable, but not complete: If you tried to build a bike with the features Sarah requested, you would miss a back wheel and a saddle.</p> <p>A complete order is always satisfiable, and a satisfiable order is complete only if all product rules evaluate to true under the given features.</p>"},{"location":"tutorial/chapter5/#satisfiable-vs-complete-configuration","title":"Satisfiable vs. Complete Configuration","text":"<p>Let's check whether Sarah's order is complete. In order to do this, we first build an assignment with Sarah's wished features. All other features will then automatically be set to <code>false</code>.</p> <p>Then, we go over each formula and check whether it is violated under the assignment.  If it is violated, then we print the rule.</p> <pre><code>wishedFeaturesSarah.addAll(Arrays.asList(\n        data.frame, data.handlebar, data.saddle, data.frontWheel,\n        data.backWheel, data.luggageRack, data.color, data.bell)); // (1)!\nAssignment assignment = new Assignment(wishedFeaturesSarah); // (2)!\nList&lt;Formula&gt; formulas = propositions.stream()\n        .map(Proposition::formula)\n        .collect(Collectors.toList());\n\nfor (Formula formula : formulas) {\n    boolean isViolated = !formula.evaluate(assignment); // (3)!\n    if (isViolated) {\n        System.out.println(formula);\n    }\n}\n</code></pre> <ol> <li>add the feature classes</li> <li>create an assignment with the wished features</li> <li>evaluate each formula with the given assignment</li> </ol> <p>The formulas which are violated under the assignment are:</p> <pre><code>saddle &lt;=&gt; s1 | s2 | s3 | s4\ns1 + s2 + s3 + s4 = 1\nbackWheel &lt;=&gt; wb26 | wb27 | wb29 | wb32\nwb26 + wb27 + wb29 + wb32 = 1\nwf26 &lt;=&gt; wb26\n</code></pre> <p>That makes sense. Sarah has to choose a saddle and a back wheel for the bike to result in a valid configuration! Also, back and front wheel must fit together.</p> <p>Sarah chooses the triathlon saddle <code>s3</code> and the back wheel with the same size as the front wheel, <code>wf26</code>. Thus, Build 'n bike sells their first bike!</p> <p>The approach with <code>solver.sat(wishedFeatures)</code> is called assumption solving, meaning the <code>wishedFeatures</code> are not actually put permanently on the solver, but the <code>sat</code>-call checks whether the formulas on the solver are satisfiable with the given assumptions.</p>"},{"location":"tutorial/chapter5/#solving-with-save-and-load-state","title":"Solving with Save and Load State","text":"<p>Just a little later a middle-aged man called Clemens enters the shop. He is an experienced biker and knows what he's looking for in a bike: He also wants the carbon frame <code>f1</code>, but in blue <code>c1</code>, front wheel 28-inch <code>wf28</code>. He would also like his bike to have the \"comfort\" saddle <code>s2</code>. Clemens doesn't mind the other components of the bike.</p> <p>Beatrice calls the method from above with new parameters:</p> <pre><code>List&lt;Literal&gt; wishedFeaturesClemens = Arrays.asList(\n        data.f1, data.c1, data.s2, data.f.variable(\"wf27\"), data.b2);\nsat = solver.sat(wishedFeaturesClemens);\n</code></pre> <p>However, this time, the result is <code>FALSE</code>, meaning the requested configuration is not satisfiable.</p>"},{"location":"tutorial/chapter5/#computing-the-reason-for-a-conflict","title":"Computing the Reason for a Conflict","text":"<p>But why is it not satisfiable? Beatrice wants to find the set of propositions which explain the conflict of the order.  This set of propositions is the Unsat Core of the formula in conjunction with Clemens' order, i.e. a set of rules which formulate a contradiction together.</p> <p>To compute the <code>UnsatCore</code>, she cannot use assumption solving.  Beatrice needs to put the <code>wishedFeatures</code> on the solver.  Further, the solver needs to have the flag <code>proofGeneration</code> in its configuration set to <code>true</code>.</p> <p>The solver with its configuration and all propositions is created like this:</p> <pre><code>SATSolver solver = MiniSat.miniSat(data.f,\n        MiniSatConfig.builder().proofGeneration(true).build());\npropositions.forEach(solver::add);\n</code></pre> <p>Since after checking Clemens' order against the rules, Beatrice perhaps wants to test another order, she saves the solver state after adding all the propositions and before adding Clemens' order:</p> <pre><code>SolverState initialState = solver.saveState();\n</code></pre> <p>Now she can add formulas to the solver and when she is done she can return to this saved solver state.  This functionality - adding and removing formulas from the solver - is very important in solving real problems.  Beatrice can now add Clemens' order to the solver and finally compute its unsat core.</p> <pre><code>List&lt;Literal&gt; wishedFeaturesClemens = Arrays.asList(\n        data.f1, data.c1, data.s2, data.f.variable(\"wf27\"), data.b2);\nwishedFeaturesClemens.forEach(feature -&gt;\n        solver.add(new StandardProposition(\"Order\", feature)));\nsolver.sat(); // (1)!\n\nUNSATCore&lt;Proposition&gt; unsatCore = solver.unsatCore();\n</code></pre> <ol> <li>the sat-call must be 'FALSE' for computing the unsat core</li> </ol> <p>The result that we obtain is the following:</p> <pre><code>ExtendedProposition{formula=f1 + f2 + f3 = 1, backpack=MyBackpack{id=1, date=2020-01-01}}\nExtendedProposition{formula=~b2 | f2 | f3, backpack=MyBackpack{id=20, date=2022-01-01}}\nStandardProposition{formula=f1, description=Order}\nStandardProposition{formula=b2, description=Order}\n</code></pre> <p>Beatrice translates the findings: The result of the <code>.unsatCore()</code> method is an unsatisfiable set of propositions:</p> <ul> <li><code>f1</code> has been chosen by Clemens</li> <li><code>b2</code> has been chosen by Clemens</li> <li><code>f1 + f2 + f3 = 1</code> with backpack <code>{id=1, date=2020-01-01}</code></li> <li><code>~b2 | f2 | f3</code> with backpack <code>id=20, date=2022-01-01}</code></li> </ul> <p>That makes sense! Since Clemens wants the carbon frame <code>f1</code>, he may not choose any of <code>f2</code> or <code>f3</code>. However, the last rule is: Either you do not take bike bell <code>b2</code>, or you take <code>f2</code> or <code>f3</code>.</p> <p>Thus, if Clemens removed the bike bell <code>b2</code> from his configuration, it should work, right?  Beatrice checks this by resetting the solver with <code>.loadState()</code> and checking the new configuration:</p> <pre><code>solver.loadState(initialState);\nList&lt;Literal&gt; wishedFeaturesFixed =\n        Arrays.asList(data.f1, data.c1, data.s2, data.f.variable(\"wf28\"));\nsolver.add(wishedFeaturesFixed);\nTristate sat = solver.sat();\n</code></pre> <p>The result now is <code>TRUE</code>, meaning this configuration is satisfiable. Note that the order may still not be complete, as explained above in the paragraph \"Satisfiable vs. complete configuration\".</p> <p>Note:  The set of rules returned by <code>.unsatCore()</code> may not be minimal.  For a minimal unsatisfiable set (MUS) there are special algorithms which are described in its own chapter.</p>"},{"location":"tutorial/chapter5/#computing-the-backbone","title":"Computing the Backbone","text":"<p>Beatrice wonders which features are still free to choose when she takes a certain back wheel. She starts with the biggest back wheel of size 32-inch.</p> <p>This set of forced and forbidden variables of a formula is called the backbone of a formula and can be computed with LogicNG (c.f. the method <code>computeBackbone()</code>).  The features which are still free to choose are the variables which are not contained in the positive or negative backbone.</p> <p>Beatrice computes the backbone in the following way:</p> <pre><code>MiniSat solver = MiniSat.miniSat(data.f);\npropositions.forEach(solver::add);\nsolver.add(data.f.variable(\"wb32\")); // (1)!\nList&lt;Variable&gt; variablesInFormula = propositions.stream()\n        .map(proposition -&gt; proposition.formula().variables())\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n\nBackbone backbone = solver.backbone(variablesInFormula);\n</code></pre> <ol> <li>restricting the backbone to wb32</li> </ol> <p>The result is:</p> <pre><code>Positive: [backWheel, color, f3, frame, frontWheel, handlebar, luggageRack,\n           saddle, wb32, wf32]\nNegative: [f1, f2, h5, r1, r2, r3, wb26, wb27, wb29, wf24, wf26, wf27, wf29]\n</code></pre> <p>Beatrice translates the output. In a bike with a back wheel of size 32-inch, - the following features have to be contained:   - The feature classes <code>backWheel</code>, <code>color</code>, <code>frame</code>, <code>frontWheel</code>, <code>handlebar</code>, <code>luggageRack</code> and <code>saddle</code> have to be present in any bike.   - Further, the features <code>f3</code> and <code>wf32</code> have to be present with the given restriction. She recalls that the rules <code>wf32 &lt;=&gt; wb32</code> and <code>wf32 =&gt; f3</code> are responsible for this. - the following features can never be contained in any configuration: Frame <code>f1</code> or <code>f2</code>, the aero bar <code>h5</code>, luggage rack <code>r1</code>, <code>r2</code> or <code>r3</code>, the other front and back wheels. - all other features are optional, meaning there are configurations with and without them</p>"},{"location":"tutorial/chapter5/#model-counting-and-enumeration","title":"Model Counting and Enumeration","text":"<p>Beatrice would like to know how many different bikes she can sell, and what they are.  Model counting answers how many different bike configurations there are, and model enumeration answers what these models are.  Check out the relevant chapter in the documentation.</p> <p>As a simple example, consider</p> <pre><code>SATSolver solver = MiniSat.miniSat(data.f);\npropositions.forEach(solver::add);\n\nsolver.sat(); // (1)!\n\nAssignment aModel = solver.model(); // (2)!\n\nList&lt;Assignment&gt; allModels = solver.enumerateAllModels(); // (3)!\n</code></pre> <ol> <li>the sat problem has to be solved before enumerating models</li> <li>give out one model</li> <li>return all models</li> </ol> <p>With the call to <code>solver.model()</code> one can find one assignment for the formulas. For example:</p> <pre><code>Assignment{\n  pos=[b1, backWheel, bell, c4, color, f3, frame, frontWheel, h1, handlebar,\n       luggageRack, s1, saddle, wb26, wf26],\n  neg=[~b2, ~b3, ~c1, ~c2, ~f1, ~f2, ~h2, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s2,\n       ~s3, ~s4, ~wb27, ~wb29, ~wb32, ~wf24, ~wf27, ~wf29, ~wf32]\n}\n</code></pre> <p>With the call to <code>solver.enumerateAllModels()</code> one finds all possible models, that is, in this example, all complete bike configurations.  The models distinguish in all sorts of features, for example whether they have a bike bell or not, which color they have, which saddle and which size of front and back wheel they have. Then <code>allModels.size()</code> returns <code>1650</code>. That is, there are 1650 possible assignments for the formulas, or in our case, configurations for a bike. Beatrice can sell 1650 different bike configurations!</p>"},{"location":"tutorial/chapter5/#enumerating-after-deciding-on-some-features","title":"Enumerating After Deciding on Some Features","text":"<p>Next, Beatrice knows that a certain combination of features is quite popular: color blue, wheel size 27.5-inch, carbon frame and ladybug bike bell.  The fitting handlebar and saddle, however, differ with every buy.  Beatrice would like to know how many different models there are with those features.  For this, she first adds the relevant features to the solver.</p> <pre><code>SATSolver solver = MiniSat.miniSat(data.f);\npropositions.forEach(solver::add);\nsolver.add(data.f.variable(\"wf27\"));\nsolver.add(data.f1);\nsolver.add(data.b3);\nsolver.add(data.c1);\nsolver.sat();\nList&lt;Assignment&gt; models = solver.enumerateAllModels();\n</code></pre> <p>Then <code>models.size()</code> returns <code>9</code>, meaning that there are 9 configurations possible with these restrictions. This is a dealable size, so we can print the models:</p> <pre><code>Assignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h1, handlebar, luggageRack, s2, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h2, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s3, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h1, handlebar, luggageRack, s3, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h2, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h4, handlebar, luggageRack, s3, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h2, ~h3, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h2, handlebar, luggageRack, s3, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h2, handlebar, luggageRack, s4, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s3, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h2, handlebar, luggageRack, s2, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s3, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h4, handlebar, luggageRack, s2, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h2, ~h3, ~h5, ~r1, ~r2, ~r3, ~s1, ~s3, ~s4, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h1, handlebar, luggageRack, s4, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h2, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s3, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\nAssignment{pos=[b3, backWheel, bell, c1, color, f1, frame, frontWheel, h4, handlebar, luggageRack, s4, saddle, wb27, wf27], neg=[~b1, ~b2, ~c2, ~c4, ~f2, ~f3, ~h1, ~h2, ~h3, ~h5, ~r1, ~r2, ~r3, ~s1, ~s2, ~s3, ~wb26, ~wb29, ~wb32, ~wf24, ~wf26, ~wf29, ~wf32]}\n</code></pre>"},{"location":"tutorial/chapter5/#projected-model-enumeration","title":"Projected Model Enumeration","text":"<p>The valid configurations distinguish only in their handlebars and saddles, because Beatrice has already decided on all other features (frame, color, wheel size, color).  One can also only enumerate over the features of interest.  For example Beatrice is now only interested which different saddles she can sell with the above configuration.  This is called projected model enumeration.  For this, Beatrice gives the method <code>enumerateAllModels()</code> a collection of variables over which the enumeration should be performed - in this case only the saddles.  The solver is the one defined above, with some features already added.</p> <pre><code>List&lt;Variable&gt; variables = Arrays.asList(data.s1, data.s2, data.s3, data.s4); // (1)!\nList&lt;Assignment&gt; modelsProjected = solver.enumerateAllModels(variables);\n</code></pre> <ol> <li>all possible saddles</li> </ol> <p>The result is:</p> <pre><code>Assignment{pos=[s4], neg=[~s1, ~s2, ~s3]}\nAssignment{pos=[s2], neg=[~s1, ~s3, ~s4]}\nAssignment{pos=[s3], neg=[~s1, ~s2, ~s4]}\n</code></pre> <p>Thus, there are 3 configuration options for the saddle for bikes in blue, with wheel size 27.5-inch, carbon frame and ladybug bike bell. They are: - <code>s2</code> - <code>s3</code> - <code>s4</code> And saddle <code>s1</code> is never buildable with this configuration.</p>"},{"location":"tutorial/chapter5/#performing-functions-on-the-solver","title":"Performing Functions on the Solver","text":"<p>Beatrice is curious about what the minimum and maximum number of features for a bike is. In order to find out, she executes an <code>OptimizationFunction</code> on the solver.  This function can be called with the <code>.minimize()</code> or <code>.maximize()</code> option.  For the minimum number of features in any configuration, she chooses the minimize function, and for the maximum number of features she chooses the maximize function.</p> <pre><code>SATSolver solver = MiniSat.miniSat(data.f);\npropositions.forEach(solver::add);\n\nSortedSet&lt;Variable&gt; vars = propositions.stream() // (1)!\n        .map(p -&gt; p.formula().variables())\n        .flatMap(Collection::stream)\n        .filter(v -&gt; !data.featureClasses.contains(v))\n        .collect(Collectors.toCollection(TreeSet::new));\n\nAssignment bikeWithMinNumberOfFeatures = solver.execute(\n        OptimizationFunction.builder().literals(vars).minimize().build());\n</code></pre> <ol> <li>all relevant features (without feature classes)</li> </ol> <p>The result is</p> <pre><code>Assignment{\n  pos=[c4, f3, h1, s4, wb32, wf32],\n  neg=[~b1, ~b2, ~b3, ~c1, ~c2, ~f1, ~f2, ~h2, ~h3, ~h4, ~h5, ~r1, ~r2, ~r3,\n       ~s1, ~s2, ~s3, ~wb26, ~wb27, ~wb29, ~wf24, ~wf26, ~wf27, ~wf29]\n}\n</code></pre> <p>meaning that the following features have to be taken: <code>c4</code>, <code>f3</code>, <code>h1</code>, <code>s4</code>, <code>wb32</code>, <code>wf32</code> and therefore 6 features are the minimum.  There may be other configurations with the minimum number of features (6), but not a configuration with less than 6 features.  To compute the maximum number of features, Beatrice can just use the <code>.maximize()</code> function</p> <pre><code>Assignment bikeWithMaxNumberOfFeatures = solver.execute(\n        OptimizationFunction.builder().literals(vars).maximize().build());\n</code></pre> <p>and gets a configuration with 7 positive variables.</p> <p>Another option to finding the bike with the minimum number of components is using a MaxSATSolver, as you will find out in the next chapter.</p>"},{"location":"tutorial/chapter6/","title":"Tutorial Chapter 6","text":"<p>After adding a set of rules to a SAT solver one can determine whether the conjunction of these rules is satisfiable or not and when it is not satisfiable, one can compute a proof/explanation for the unsatisfiability.  But there is a second question for an unsatisfiable set of rules: what is the maximum number of rules which can be satisfied?  This is not a decision problem anymore, but an optimization problem and a special kind of solver is used for this use case: a MaxSAT solver.  Many use cases can be solved with a MaxSAT solver.</p> <p>There are also two very interesting extensions to MaxSAT solvers which give them even more power:</p> <ol> <li>One can differentiate between so-called \"hard\" and \"soft\" formulas. Hard formulas are required to be satisfied while soft clauses are not.  The MaxSAT solver then only optimizes over the soft formulas while always satisfying the hard formulas.</li> <li>Soft formulas can also hava a weight.  Then the solver optimizes not the number of formulas, but their respective weight.</li> </ol> <p>Formulas with both soft and hard formulas are called partial problems, and problems where the soft formulas carry weights are called weighted problems.  LogicNG has solvers which can solve partial weighted MaxSAT problems.  For a detailed introduction to MaxSAT-Solving in LogicNG, check out the relevant chapter.</p> <p>In this chapter we will demonstrate two use cases of MaxSAT-Solving:</p> <ol> <li>Finding a configuration with the minimum number of features</li> <li>Finding the cheapest bike</li> </ol>"},{"location":"tutorial/chapter6/#solving-a-partial-maxsat-problem","title":"Solving a Partial MaxSAT Problem","text":"<p>As mentioned in the previous chapter, Beatrice can also formulate the problem of finding the minimum number of features as a MaxSAT problem.  In this case all the original product rules (the restricted propositions) are hard clauses, meaning each configuration must still adhere to all rules.  If we want to find the minimum number of features in a configuration, we add each feature as a negative literal to the MaxSAT solver as a soft formula.  Since we do not differentiate between the single features, all soft clauses have weight 1.  So ideally we want all features to be negative, i.e. not in the configuration.  This is not possible, so now the solver searches for the maximum number of rules it can satisfy - or in other terms, the minimum number of rules it has to ignore.  In this case the solver has to ignore 6 rules at a minimum.  Since each soft rule set the feature to false, this means, at least 6 features have to be set to true.  This yields the same result as the optimization in the last chapter.</p> <pre><code>MaxSATSolver solver = MaxSATSolver.msu3();\npropositions.forEach(x -&gt; solver.addHardFormula(x.formula()));\n\nSortedSet&lt;Variable&gt; vars = propositions.stream() // (1)!\n        .map(proposition -&gt; proposition.formula().variables())\n        .flatMap(Collection::stream)\n        .filter(v -&gt; !data.featureClasses.contains(v))\n        .collect(Collectors.toCollection(TreeSet::new));\n\nvars.forEach(v -&gt; solver.addSoftFormula(v.negate(), 1));\nsolver.solve();\nAssignment model = solver.model();\n</code></pre> <ol> <li>all relevant features (without feature classes)</li> </ol> <p>The result is:</p> <pre><code>Assignment{\n  pos=[f2, frame, h1, handlebar, s1, saddle, frontWheel, wf26, backWheel,\n       wb26, luggageRack, c1, color],\n  neg=[~f1, ~f3, ~h2, ~h3, ~h4, ~h5, ~s2, ~s3, ~s4, ~wf24, ~wf27, ~wf29, ~wf32,\n       ~wb27, ~wb29, ~wb32, ~b1, ~b2, ~b3, ~bell, ~r1, ~r2, ~r3, ~c2, ~c4]\n}\n</code></pre> <p>Note that the found configuration is different from the one in the last chapter, but the minimum number of features stays the same.  If you want to compute the maximum number of features in a configuration, you have to add the literals positively to the solver as soft clauses.  So maximizing the number of features, set to true.</p>"},{"location":"tutorial/chapter6/#solving-a-weighted-partial-maxsat-problem","title":"Solving a Weighted, Partial MaxSAT Problem","text":"<p>Beatrice has another customer: A young lady called Coco comes to the shop. Coco likes cycling, but she likes saving too.  Coco is interested in the cheapest bike. Still, a bike has to fit and Beatrices trained eye tells her that Coco needs wheel size 27.5-inch.</p> <p>This is Beatrice's price table:</p> Feature Price in Euros <code>f1</code> <code>1500</code> <code>f2</code> <code>900</code> <code>f3</code> <code>400</code> <code>h1</code> <code>380</code> <code>h2</code> <code>200</code> <code>h3</code> <code>120</code> <code>h4</code> <code>300</code> <code>s1</code> <code>200</code> <code>s2</code> <code>240</code> <code>s3</code> <code>160</code> <code>s4</code> <code>300</code> <code>r1</code> <code>130</code> <code>r2</code> <code>120</code> <code>r3</code> <code>20</code> <code>r4</code> <code>100</code> <p>For some features, however, the prices do not differentiate: The bike bells and the colors for example have all the same price.  Beatrice uses MaxSAT-Solving to find the cheapest bike. Like above, the product rules are added as hard clauses since each bike has to adhere them.  Beatrice then uses soft formulas with the features price as weight.  Since the solver searches the maximum weight but Beatrice wants the cheapest price (so the minimum) weight, she adds each feature negatively to the solver.  So now the solver tries to maximize the price of the features not in the configuration and thereby minimizing the price of the features actually in the configuration.  This technique (solving the dual problem) is very common in MaxSAT solving.</p> <pre><code>MaxSATSolver solver = MaxSATSolver.wbo();\npropositions.forEach(proposition -&gt;\n        solver.addHardFormula(proposition.formula()));\nsolver.addHardFormula(\"wf27\"); // (1)!\n\nsolver.addSoftFormula(f1.negate(), 1500); // (2)!\nsolver.addSoftFormula(f2.negate(), 900);\nsolver.addSoftFormula(f3.negate(), 400);\n\nsolver.addSoftFormula(h1.negate(), 380);\nsolver.addSoftFormula(h2.negate(), 200);\nsolver.addSoftFormula(h3.negate(), 120);\nsolver.addSoftFormula(h4.negate(), 300);\n\nsolver.addSoftFormula(s1.negate(), 200);\nsolver.addSoftFormula(s2.negate(), 240);\nsolver.addSoftFormula(s3.negate(), 160);\nsolver.addSoftFormula(s4.negate(), 300);\n\nsolver.addSoftFormula(r1.negate(), 130);\nsolver.addSoftFormula(r2.negate(), 120);\nsolver.addSoftFormula(r3.negate(), 20);\nsolver.addSoftFormula(r4.negate(), 100);\n\nsolver.solve(); // (3)\nsolver.model(); // (4)\n</code></pre> <ol> <li>add front wheel 27.5 inch</li> <li>add prices for the different features</li> <li>solve the problem</li> <li>give out the model</li> </ol> <p>The result is:</p> <pre><code>Assignment{\n  pos=[f3, frame, h3, handlebar, s3, saddle, frontWheel, wf27, backWheel,\n       wb27, luggageRack, c4, color],\n  neg=[~f1, ~f2, ~h1, ~h2, ~h4, ~h5, ~s1, ~s2, ~s4, ~wf24, ~wf27, ~wf29,\n       ~wf32, ~wb27, ~wb29, ~wb32, ~b1, ~b2, ~b3, ~bell, ~r1, ~r2, ~r3,\n       ~c1, ~c2, ~r4]\n}\n</code></pre> <p>This means that the cheapest bike consists of the following features: <code>f3</code>, <code>h3</code>, <code>s3</code>, <code>wf27</code>, <code>wb27</code>, <code>c4</code>.  The color <code>c4</code> is chosen randomly, since all colors cost the same.  The price of the configuration can be found with <code>solver.result()</code>. It is <code>680</code>.</p>"},{"location":"whitepaper/abstract/","title":"Solving Configuration Problems with LogicNG","text":"<p>This white paper gives an overview of the open source software library LogicNG developed by BooleWorks and its applications to configuration problems.  A PDF version of this paper can be downloaded here.</p>"},{"location":"whitepaper/abstract/#logicng","title":"LogicNG","text":"<p>LogicNG is a Java library for creating, manipulating and solving Boolean and pseudo-Boolean formulas, containing many algorithms and solver engines for efficiently working with large rule sets arising in product configuration. It is used by many companies around the globe to solve their configuration problems, most notably some German premium car manufacturers. The library is open source under the Apache 2 license and published at GitHub.</p>"},{"location":"whitepaper/abstract/#booleworks","title":"BooleWorks","text":"<p> BooleWorks is a Munich-based company specialized in the application of mathematical logic. The team at BooleWorks is developing algorithms and methods for variant and complexity management. With a strong focus on open source software, \"own-your-code\", and transparency, all code developed by BooleWorks is either open source or customer-specific. BooleWorks is a tier 1 software supplier for some of the German premium car manufacturers.</p>"},{"location":"whitepaper/abstract/#sofdcar","title":"SofDCar","text":"<p>  BooleWorks is a member of the SofDCar project which is part of a research program sponsored by the Federal Ministry for Economic Affairs and Climate Action of Germany (Bundesministerium der Wirtschaft und Klimaschutz, BMWK). All project partners of the SofDCar Alliance are focusing their research on the challenges of future electric/electronic (E/E) &amp; software architecture in vehicles. Within the SofDCar project, BooleWorks is working both on LogicNG itself and an extension of its use cases to the software world. The library will be rewritten in Rust, enabling its application within the vehicle and as the base of small, memory-efficient containerized services.</p>"},{"location":"whitepaper/contact/","title":"Contact","text":"<p>BooleWorks GmbH Radlkoferstr. 2  81373 Munich, Germany</p> <p>Mail: info@booleworks.com Web: www.booleworks.com</p>"},{"location":"whitepaper/references/","title":"References","text":"<p>BooleWorks' employees published many scientific articles on algorithms for solving configuration problems over the last years. Comprehensive introductions are provided by two PhD theses:</p> <ul> <li>New Formal Methods for Automotive Configuration (2014) by Christoph Zengler</li> <li>SAT-based Analysis,(Re-) Configuration &amp; Optimization in the Context of Automotive Product Documentation (2018) by Rouven Walter</li> </ul> <p>The SofDCar project is funded by</p> <p></p>"},{"location":"whitepaper/problem/common-configuration-problems/","title":"Common Configuration Problems","text":"<p>Typically, complex products do not have a single set of rules to describe all aspects of the product, but instead there are many different rule sets describing dependencies between features in different domains.  A few of these rule sets with examples from the automotive industry are presented in the following table.</p> Domain Example High Level Configuration Technical Rules the feature for the park computer depends on the feature for park sensors Legal Rules in Germany, each vehicle must have a breakdown triangle Homologation Requirements in the EU, exhaust emission standard EU6 is mandatory Marketing Rules the US market forces air condition in every vehicle Bill of Materials (BOM) which steering wheel is built in a vehicle is dependent on features like the wheel itself, interior color, multimedia system, ... Electronig Control Unit (ECU) Configuration the parameter for the vehicle length of the park assistant's ECU is dependent on the exterior package and the existence of a trailer hitch Software Configuration different versions of a parking assistant's software require different sensors built in the vehicle and are dependent on the software versions of the camera firmware <p>As depicted in the next figure, these rule sets have intersections, but single rule sets can also describe more variants than other rule sets allow.  This is due to the fact that each domain describes only the variance which is relevant to it: a bill of material (BOM), e.g., can describe hardware variants which are currently not sold in any market, but might be in the future.</p> <p></p> <p>Each rule set can be verified individually for certain validation criteria, e.g. that there is no contradiction in the set of rules. Further, verifications across different rule sets are common. Usually, the high level configuration (HLC) is used as base rule set, since it describes all buildable products on a certain level (technical, for a certain legislator, in a certain marketing region, ...). Other rule sets are then verified against this HLC to prove certain properties. The next table presents some tasks commonly performed and properties commonly validated on the example of a vehicle.</p> Domain Example Tasks and Verifications General <ul><li>simplification of rules with and without consideration of the HLC</li><li>visualization of rules, transformation of rules into certain formats</li><li>evaluation of rules for single configurations</li></ul> ** High Level Configuration ** <ul><li>validation of the consistency of the rule set</li><li>computation of non-buildable and enforced features</li><li>projection of the rule set to certain scopes</li><li>computation of impacts of changes in the rule set</li></ul> ** Bill of Materials (BOM)** <ul><li>verification that positions (e.g. side mirror) are unique, meaning exactly one variant is taken for each buildable vehicle</li><li>computation of non-buildable parts in the BOM</li></ul> ** Electronic Control Unit (ECU) Configuration** <ul><li>verification that parameter values are uniquely defined for each parameter</li><li>validation of the consistency between ECUs in the BOM and the ECU configuration</li><li>simplification of ECU parameter conditions to speed up flashing on the moving assembly line</li></ul> ** Software Configuration** <ul><li>solving software update problems</li><li>computation and optimization of software update paths</li><li>validation of software releases in combination with hardware releases</li></ul>"},{"location":"whitepaper/problem/mass-customization/","title":"Mass Customization","text":"<p>When considering interesting use cases for automated reasoning in product configuration, first we have to look at two aspects: product variance, i.e., how many different product configurations are buildable, and product volume, i.e., how many of these configurations are produced every day.  The following figure illustrates this situation.</p> <p> </p> <p>In today's world there are highly customizable products like airplanes or cruise ships. These products possess high product variance, yet they are not mass-produced (upper left quadrant). The configuration process involves many months of planning and coordination.  On the other hand there are products, which are produced in great numbers, yet having only a very limited variance of only dozens or hundreds of different models (lower right quadrant), with a typical example being, e.g., microprocessors. In these cases, all possible configurations can be verified beforehand and there is almost no configuration process during production.</p> <p>In the upper right quadrant we find products having both a high variance and are produced in large numbers. One such class of products are premium cars: A Mercedes E-Series in 2012, e.g., had over 10<sup>102</sup> different buildable configurations and yet thousands of vehicles are produced every day. This is called Mass Customization, a term coined by Stan Davis in 1987 and defined by Mitchell M. Tseng and Jianxin Jiao in 1996 as</p> <p>Mass Customization</p> <p>producing goods and services to meet individual customer's needs with near mass production efficiency</p> <p>In mass customization, very interesting but hard configuration problems arise: It is not possible to verify each single buildable configuration by hand or individually, even when this process is automated. Additionally, the mass production aspect allows no room for misconfigurations since a car leaves the moving assembly line every one to two minutes. Line stoppage hence can cost hundreds of thousands of Euros.</p> <p>Configuration problems do exist in all four quadrants, and LogicNG can support the whole process from product development over production to sales here.  But the upper right quadrant is where it really shines.</p>"},{"location":"whitepaper/real-solutions/software-world/","title":"Towards a Software-Defined World","text":"<p>The above use cases have a strong focus on the development, production and sales processes of the hardware of the product. Since the rise of the Software Defined Vehicle, software plays an equally important part in all phases of the life cycle of a vehicle.</p>"},{"location":"whitepaper/real-solutions/software-world/#management-of-software-packages","title":"Management of Software Packages","text":"<p>One of the most important aspects is the management of software packages: which versions of a software or library are compatible with which other versions, which packages have dependencies to or restrictions with other packages. This is an area where SAT solvers are traditionally used to resolve package update problems. Linux package managers or the Eclipse plugin manager, e.g., use SAT solvers to resolve their packages. A very small (&lt; 300 lines of codes) proof of concept package solver with different optimization strategies based on LogicNG was released on GitHub:</p>"},{"location":"whitepaper/real-solutions/software-world/#release-and-update-validation","title":"Release and Update Validation","text":"<p>Another use case is to validate a whole software release including ECUs, libraries, and software packages. But this is no static process: over-the-air (OTA) updates make it necessary to constantly verify all software packages and updates against regulations like, e.g., the UNECE R 156. A change in a single rule in any of the rule sets (be it high level, BOM, ECU, or software) can for example have an effect on the homologation of a vehicle. A software update to a motor ECU, e.g., could change its emission values and invalidate a homologation. Within the SofDCar project, BooleWorks is working with its partners from industry and research to develop holistic data models for all relevant data and rule sets, which can then be validated both for all planned but also all already produced vehicles, perpetually and automatically.</p>"},{"location":"whitepaper/real-solutions/software-world/#computation-of-selectable-software-and-services","title":"Computation of Selectable Software and Services","text":"<p>A use case which is already present today, but which will play an even more important role in the future is the whole aspect of after-sales software and service add-ons. While the customer today can buy some new services online, in the future, whole vehicle features will be available on-demand. Thus, the computation of selectable services and software features will play an important role, as well as re-configuration algorithms, enabling customers to buy a feature which is currently not possible in their vehicle.</p>"},{"location":"whitepaper/real-solutions/use-cases/","title":"Today's Use Cases","text":"<p>In this chapter we present use cases where LogicNG is used today to solve problems in the German automotive industry. All of the presented use cases are implemented in production systems and have been running for many years, some of them used millions of times a day. Many of these use cases are, however, not specific to the automotive industry and could easily be transformed to other application areas.</p>"},{"location":"whitepaper/real-solutions/use-cases/bill-of-materials/","title":"Bill of Materials","text":"<p>Bill of Materials</p> <p>The bill of material (BOM) maps high level configurations to physical parts of the product. E.g., for a vehicle, a high level feature like \"Sport Steering Wheel\" gets resolved into many parts like the steering wheel itself but also encompasses cables, mounts, or screws. Its validation is very important since a product-individual 100% BOM is computed for each configuration which is produced. This is called a \"BOM explosion\". Errors in the BOM can yield wrong parts at the moving assembly line and, in the worst case, causes line stoppage which potentially costs hundreds of thousands of Euro.</p>"},{"location":"whitepaper/real-solutions/use-cases/bill-of-materials/#bom-validation","title":"BOM Validation","text":"<p>One of the first use cases of LogicNG was to validate the BOM for correctness criteria, e.g., that each buildable configuration gets exactly one steering wheel. These computations are always performed over the whole product variance, not only for certain vehicles. Therefore errors can be spotted before a vehicle is ordered or produced, because every possible vehicle is implicitly validated. It is also used, e.g., for computing if there are parts which are not buildable in a certain plant for a certain time period. This is key for advanced supply chain management.</p>"},{"location":"whitepaper/real-solutions/use-cases/bill-of-materials/#bom-explosion","title":"BOM Explosion","text":"<p>Today, our algorithms are also often employed for the traditional BOM explosion for a given product. Although this is a standard functionality of every BOM system, the achieved speed is often far superior to these systems. In the automotive context, our algorithms can resolve &gt; 100,000 BOM positions per second on a standard laptop, single-threaded on one processor core.</p>"},{"location":"whitepaper/real-solutions/use-cases/bill-of-materials/#bom-visualization","title":"BOM Visualization","text":"<p>Thanks to the library's extensible BDD implementation, it is also used to visualize BOM positions and allows a graphical maintenance of parts at a position. It can first visualize the position as a graph, allowing the maintainer to add and remove parts or to draw and re-route edges, and then computes the new resulting constraints for the BOM system.</p>"},{"location":"whitepaper/real-solutions/use-cases/ecu-configuration/","title":"ECU Configuration","text":"<p>Electronic Control Units</p> <p>Electronic control units (ECU) play an ever growing part in today's vehicles. A modern vehicle has over one hundred ECUs. The validation of both the correct usage of the ECUs as well as their configuration is as important as the validation of the BOM. Since the ECUs of vehicles often are flashed on the moving assembly line with only a short time to flash the right configuration, concise and simplified formulas are required. Last but not least, not only the ECUs are highly configurable, but also the cable harnesses connecting them throughout the vehicle.</p>"},{"location":"whitepaper/real-solutions/use-cases/ecu-configuration/#verification-of-the-ecu-parameters","title":"Verification of the ECU Parameters","text":"<p>Similar to the validation of BOMs, LogicNG is used for the verification of the ECU parameter configuration for all possible buildable vehicles. In contrast to the BOM, which is usually documented for a vehicle series, ECUs are often documented for all series and product lines. This leads to very large and complex formulas in their configuration. Also some ECUs have thousands of parameters with tens of thousands of different possible parameter values. Once again the speed of our algorithms and solver engines is very important, enabling interactive verification of parameters over all product lines.</p>"},{"location":"whitepaper/real-solutions/use-cases/ecu-configuration/#simplification-of-flash-conditions","title":"Simplification of Flash Conditions","text":"<p>The formula simplification algorithms provided in the library are used to simplify the flash conditions for ECU parameters, allowing for a fast flash process on the assembly line. Formulas are not only simplified mathematically, but also with additional domain knowledge, providing even shorter representations.</p>"},{"location":"whitepaper/real-solutions/use-cases/ecu-configuration/#optimization-of-module-building-in-cable-harnesses","title":"Optimization of Module Building in Cable Harnesses","text":"<p>The library is also used to optimize module building in cable harnesses. Today's cable harnesses consist of many modules (if they are not customer-specific). But the questions are: how many modules should you design and produce?  Are there modules which are always required? Modules which force other modules?  Or modules which are not required anymore? By taking take-rates into account one can also optimize the module building process by producing specific modules for popular feature combinations, enabling cost reductions.</p>"},{"location":"whitepaper/real-solutions/use-cases/high-level-configuration/","title":"High-Level Configuration","text":""},{"location":"whitepaper/real-solutions/use-cases/high-level-configuration/#rule-set-validation","title":"Rule Set Validation","text":"<p>The high level rule set describes every buildable product configuration and therefore often is the base of all subsequent design, product development, production, sales, and after-sales processes. Its correctness is of uttermost importance. The library is used to validate rule sets for given criteria, e.g., are there features which are not buildable at any point in time, are there rules which contradict other rules, etc. Our algorithms are used to search for time gaps in rules, e.g., that a new rule supersedes an old one but there is a time gap between the two. The library is also used in interactive rule generation and maintenance processes and checks if a new or modified rule is consistent with the current rule set, if it can be simplified, or if it contains parts which contradict other rules.</p>"},{"location":"whitepaper/real-solutions/use-cases/high-level-configuration/#projections-and-simplifications-of-rules","title":"Projections and Simplifications of Rules","text":"<p>Typically, the high level rule set consists of thousands of rules over many product lines, countries, and releases. Hence, it is often useful to project these rules to arbitrary filter conditions. LogicNG can be used to perform these projections, or simplify the resulting rules, showing which rules are affected by the projection, and also highlight the differences within milliseconds.</p>"},{"location":"whitepaper/real-solutions/use-cases/high-level-configuration/#enumerate-buildable-configurations","title":"Enumerate Buildable Configurations","text":"<p>Another very important supported use case, used in many software systems, is to generate the buildable variance over a certain set of features: a maintainer for breaking systems, e.g., knows exactly which features influence the configuration of the breaking system and wants to know which combinations between these features are buildable with respect to the high level rule set. Very efficient model enumeration algorithms allow to enumerate these buildable configurations, even for millions of combinations within seconds.</p>"},{"location":"whitepaper/real-solutions/use-cases/high-level-configuration/#optimization-of-required-product-configurations","title":"Optimization of Required Product Configurations","text":"<p>Also a very popular use case is to optimize the number of required product configurations. Thinking of the production of test vehicles, there are hundreds or thousands of requirements for physical test vehicles: For a desert test drive, e.g., someone needs a vehicle with air conditioning, while for a photo shoot a red vehicle in the luxury line is needed, and so on. The question now is: How many physical vehicles do you need to produce at least in order to satisfy all these constraints. Since test vehicles are very expensive, saving one or two vehicles can be lucrative. Previously, these processes were often performed by hand, taking days or even weeks. With the library's optimization algorithms, the corresponding computations can be performed in minutes, yielding guaranteed minima.</p>"},{"location":"whitepaper/real-solutions/use-cases/homologation/","title":"Homologation Requirements","text":"<p>With the introduction of the Worldwide harmonized Light vehicles Test Procedure (WLTP) in the automotive industry in 2019, the homologation process and the computation of vehicle-individual CO<sub>2</sub> and consumption values got much more complex. LogicNG has been used from day one to help in both use cases.</p>"},{"location":"whitepaper/real-solutions/use-cases/homologation/#computing-best-and-worst-vehicle-configurations","title":"Computing Best and Worst Vehicle Configurations","text":"<p>Computing the best and worst vehicles with respect to their energy consumption is necessary for the homologation process. Since this is a linear programming problem, a linear optimizer like CPLEX or Gurobi is the best tool for the job. However, the state of the art tools could not yield the performance required to perform tens of thousands of computations a day. Our algorithms have been used to simplify all involved rules and pre-process many of the data in order to improve the performance of the linear optimizers. This helped to speed up the computation time from some minutes to a few seconds.</p>"},{"location":"whitepaper/real-solutions/use-cases/homologation/#computing-individual-co2-and-consumption-values","title":"Computing individual CO<sub>2</sub> and Consumption Values","text":"<p>Computing the individual CO<sub>2</sub> and consumption values for a vehicle requires the exact weight, aerodynamic values and rolling resistance of that particular vehicle. The library is used to calculate those physical data by efficiently computing the BOM explosion. Since these computations are integrated in the online configurators, speed and response time is extremely important. With our algorithms, the computation of a single vehicle's individual values requires less than one millisecond, and such operations are being performed millions of times a day in production systems.</p>"},{"location":"whitepaper/real-solutions/use-cases/ordering-process/","title":"Ordering Process","text":""},{"location":"whitepaper/real-solutions/use-cases/ordering-process/#interactive-configuration","title":"Interactive Configuration","text":"<p>LogicNG is used in configurators for both in-house product development, and customer touchpoints. Besides the standard functions like supporting an interactive configuration, where in each step the remaining selectable features are highlighted, it supports some advanced use cases.</p>"},{"location":"whitepaper/real-solutions/use-cases/ordering-process/#explanation-of-conflicts","title":"Explanation of Conflicts","text":"<p>In the case of a conflict, one can easily explain why a certain configuration is not buildable by employing one of many available explanation algorithms like, e.g., finding the shortest explanation for the conflict. During the product development process, this can often save many hours of analysing the rule sets manually.</p>"},{"location":"whitepaper/real-solutions/use-cases/ordering-process/#re-configuration","title":"Re-Configuration","text":"<p>However, if the user explicitly wants to select a feature which contradicts the current configuration, you can compute possible re-configurations for user-provided criteria. As such, it is possible to compute the, e.g., cheapest re-configuration or the one with fewest changes to the current order. This is also used in automated processes like validating all currently active orderings every night, computing which vehicles are not buildable any longer because of changes in the rule sets, and proposing possible re-configurations to the user.</p>"},{"location":"whitepaper/solution/computation-vs-compilation/","title":"On-the-fly Computation vs. Compilation","text":"<p>As shown in the general approach, there are two fundamentally different approaches to answer queries on product rules: (1) using a solver engine, and (2) compiling the rules in a knowledge compilation format. LogicNG has support for both approaches. In our real-world projects in the automotive industry, however, we use solver engines &gt; 95% of the time, and knowledge compilation only for special use cases. The big advantage of knowledge compilation is that compiled formats can be very succinct and allow for answering many questions very rapidly (often in constant or linear time). However, the computation time for the compilation itself can grow exponentially. A solver, on the other hand, can take exponential time to answer questions in the worst case, but it allows for very fast initial loading, addition and removal of rules. The following considerations indicate why the solver-approach is frequently superior in practice:</p> <ul> <li>Real industrial problems tend to be easily solvable for modern solver engines - often in a few milliseconds - rendering the performance advantage of knowledge compilations irrelevant.</li> <li>Large rule sets are very hard to compile into knowledge compilation formats. Typically taking minutes, often it is not even possible at all due to the exponential growth of compilation time.</li> <li>With some ground-breaking techniques been developed within the last twenty year, SAT solvers have advanced quickly in the recent past. Research on, e.g., BDDs did not progress comparably.</li> </ul> <p>As a practical example, we take a small rule set from a German premium car manufacturer - for large rule sets a compilation into BDDs or DNNFs is infeasible. For this small rule set the compilation into a BDD can take minutes, whereas loading the formulas onto a solver takes only a few hundred milliseconds. Solving such formulas with a modern solver usually takes only few milliseconds - approximately the same time as for a compiled BDD. I.e., in the same time in which the BDD is generated, the solver could  have solved hundreds of thousands of queries already. Plus, even when looking at the compiled format, the BDD does not yield any performance advantages. Even worse: in an interactive environment where someone creates or changes rules in the rule set and wants to perform on-the-fly validations and computations, the BDD had to be recompiled after each change.</p> <p>There are, of course, also useful scenarios for knowledge compilation: usually, when the rule set is small, when not the whole rule set has to be considered, or for visualizing formulas.</p> <p>Therefore, we want to pursue and support both approaches, the solver-approach and knowledge compilation. To this respect, LogicNG on one hand hand provides three different kinds of solver engines:</p> <ul> <li>SAT solvers for solving Boolean and pseudo-Boolean formulas.</li> <li>Cardinality solvers specialized for formulas with many cardinality constraints.</li> <li>MaxSAT solvers including partial weighted MaxSAT solvers for optimizations on Boolean and pseudo-Boolean formulas.</li> </ul> <p>On the other hand, the library also features two knowledge compilers:</p> <ul> <li>A BDD implementation with interactive reordering and different variable ordering strategies.</li> <li>A d-DNNF compiler based on DTrees.</li> </ul>"},{"location":"whitepaper/solution/decision-vs-optimization/","title":"Decision Problems vs. Optimization Problems","text":"<p>Another interesting question is whether the query at hand is a decision problem or an optimization problem. A decision problem can be answered with a simple yes/no answer, e.g., if a certain feature is buildable for a given configuration. An optimization problem on the other hand involves attaching weight factors to certain features, e.g., prices or mass in kg, and then searching for an optimal solution by minimizing or maximizing the cumulative weight factors of the configuration. The result would be for example the cheapest product configuration or the heaviest. Whereas decision problems can be solved with both solver engines and knowledge compilation formats, optimization problems usually are solved with optimizing solvers like a MaxSAT solver.</p> <p>LogicNG supports solving with hard and soft rules: a part of the rules can be defined as hard which must be fulfilled by every configuration, whereas soft rules should be fulfilled. The solver then searches for a solution which satisfies a maximum number of the soft rules. Weighted problems are also possible, where each formula can have a weight and then a solution with a maximum weight is searched for by the solver. These are very powerful tools to model and solve many kinds of real-world optimization problems.</p>"},{"location":"whitepaper/solution/general-approach/","title":"The General Approach","text":"<p>Many of the above mentioned rule sets are formulated as Boolean rules or slight extensions of Boolean algebra. Therefore, algorithms from the area of Boolean logic and automated reasoning are well suited for solving the associated problems. LogicNG provides many algorithms to work with Boolean and pseudo-Boolean formulas; the most important ones for solving complex problems being a variety of solvers, namely SAT-, Cardinality-, and MaxSAT Solvers. These can decide the satisfiability of large Boolean formulas, compute configurations, explain conflicts, and optimize solutions for given criteria. Alternatively, one can compile the problem into a knowledge compilation format like binary decision diagrams (BDD) or disjunctive negation normal forms (DNNF), and then perform computations on this compiled format. This general process is presented in the next figure.</p> <p> </p> <p>The product rules are translated to a Boolean formula, describing the entire solution space. I.e., each solution of this formula is one valid configuration of the product. This product formula is then either loaded onto a solver, or compiled into a knowledge compilation format. These two steps are usually performed only once, and then hundreds, thousands, or sometimes millions of requests are queried against the solver or compiled format.</p> <p>To do this, the concrete query is also translated into a Boolean formula - the query formula - and then checked against the solver or compiled format. To illustrate this, imagine a vehicle as a product. All product rules are added onto a solver such that each solution found by the solver represents one valid vehicle configuration. Now take as an example the bill of material for this vehicle. For a premium car, typically, there are hundreds of different physical steering wheels, each with its own selection condition specifying in which vehicle the respective steering wheel is used. The question now is, whether there exists any valid vehicle which does not feature a steering wheel.  The translation of this query into a Boolean formula is the conjunction of all possible steering wheels negated. If this query formula is satisfiable together with the product formula on the solver, then there is at least one vehicle which satisfies all product rules, but on the other hand does not satisfy any selection condition of a steering wheel - therefore we found a vehicle without steering wheel. If the product formula and the query formula are not satisfiable together, then we now know that each valid vehicle configuration indeed has a steering wheel.</p> <p>LogicNG does not only provide the solvers and knowledge compilers, but also very efficient data structures for formulas, plus many algorithms to generate and manipulate these formulas.  This is especially important for implementing product and query translators.</p>"},{"location":"whitepaper/solution/testing-vs-reasoning/","title":"Manual Testing vs. Automated Reasoning","text":"<p>Traditionally, certain properties of rule sets were verified by manual tests. But with up to 10<sup>100</sup> buildable configurations, each manual testing approach will yield a test coverage of de facto 0% - even when testing billions of different configurations manually. The problem is that if your manual tests do not find an invalid configuration, you never know whether there is no invalid configuration or you just did not find it. The left graphic in the next figure illustrates the situation.  The green space is the set of all buildable variants. The large red area are invalid configurations and the white dots are your tested configurations.  In this case your tests do not hit an invalid configuration.</p> <p></p> <p>However, a product formula as introduced in the last section describes every buildable variant, implicitly.  When using a solver or knowledge compilation engine we either find an invalid configuration or we get a mathematical proof that there can be none.  There is no uncertainty like in manual testing.  The right graphic in the figure illustrates this: all buildable vehicles are implicitly tested and therefore we quickly find an invalid configuration.</p> <p>The advantage of always considering the complete solution space translates also to other algorithms.  When searching an optimal product configuration, e.g., the heaviest configuration, the solution is a mathematical global optimum, not some approximation.  When computing all possible combinations between a set of features, the result indeed is each mathematically possible configuration, not just a sample of it.</p>"},{"location":"blog/archive/2022/","title":"2022","text":""}]}